/*
  File: .gitignore
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/.gitignore
  Directory: .
*/

--- File: .gitignore ---

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# clerk configuration (can include secrets)
/.clerk/

# Playwright
node_modules/
/test-results/
/playwright-report/
/blob-report/
/playwright/.cache/

# Database backups
/backups/

# LLM contexts for third party tools
llm-convex.txt

# Convex
.convex/
convex/_generated/
.env.local

# clerk configuration (can include secrets)
/.clerk/

/*
  File: .prettierrc
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/.prettierrc
  Directory: .
*/

--- File: .prettierrc ---

{
  "endOfLine": "lf",
  "printWidth": 200,
  "semi": false,
  "singleQuote": false,
  "tabWidth": 2,
  "trailingComma": "es5"
}


/*
  File: README.md
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/README.md
  Directory: .
*/

--- File: README.md ---

# d20adventures.com

A new narrative-driven RPG platform that blends play-by-post gameplay and real-time updates facilitated by an AI Game Master.

---

The prototype for D20 Adventures is a proof of concept for a turn based narrative driven RPG platform where players work their way through an adventure module run by an AI game master.

Each turn begins with an introduction and a character response order randomly determined by a D20 initiative roll. When it is the player’s turn, they can reply to update the narrative of the adventure with their character’s actions and dialogue. 

If it is determined that a dice role is needed, the player can roll their D20 and the result will determine the direction of the story.

The AI is trained to choose an appopriate dice roll check and the target for success, then will update the narrative based on the roll result and the instructions for the encounter in the adventure module.

At the end of each turn, the AI decides whether to move to a new encounter or continue with the current scenario.

Each encounter has its own image, intro, title, NPCs and instructions for the AI Game Master.

If the player enters well written prose, it will be preserved as as, otherwise it will be enhanced to fit the story’s narrative, cleaning up spelling and grammar while preserving the intent of the original response.

Similarly each NPC will have an opportunity to respond and make dice rolls, all coordinated against an overall adventure plan linking one encounter to another.

This initial D20 Adventures prototype is a simple one shot single player character adventure inspired by Deborah Ann Woll’s appearance on the Real Ones with Jon Bernthal podcast where she spontaneously invented an adventure scenario to demonstrate the fun of D and D gameplay.

The simple confrontation she concocted between a ranger and an owlbear in the forest at night could also be a good test of whether a game can be led by an AI game master and actually be fun.

When you are working with AI, it is best to avoid lots of complicated game mechanics, so I tried to keep it simple. Just roll a D20. If you roll high, good things happen. Roll low, not so much.

We keep track of the characters turn over turn, including adjusting status and health percentage.

With a name like D20 Adventures, of course we have to pay special attention to natural twenties and ones. Hopefully more twenties for the players but sometimes that's not how it goes.

Hopefully Jon Bernthal and Deborah Ann Woll don't object to my homage! 

In the future, I want to build true multiplayer, where you can form a group of friends and play through an adventure together. 

Eventually I would like to allow anyone create their own settings and adventure modules for a community of players to discover.

D20 Adventures is a fun project for me to see if I can create a cool new multiplayer narrative rpg experience with AI. 

Head over to D20 Adventures.com to join the discord, sign up for the wait list or find the source code on Github.

You can also follow me on X, Bluesky and Medium for project updates.



/*
  File: app/[settingId]/[adventurePlanId]/[adventureId]/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/[settingId]/[adventurePlanId]/[adventureId]/page.tsx
  Directory: app/[settingId]/[adventurePlanId]/[adventureId]
*/

--- File: app/[settingId]/[adventurePlanId]/[adventureId]/page.tsx ---

import { notFound } from "next/navigation"
import type { Metadata } from "next"
import AdventureHome from "@/components/views/adventure-home"
import { loadAdventureWithNpc } from "@/app/_actions/load-adventure"
import type { Id } from "@/convex/_generated/dataModel"
import type { Adventure } from "@/types/adventure"
import { mapConvexTurnToTurn } from "@/lib/utils"
import { AdventurePlan } from "@/types/adventure-plan"

export const dynamic = "force-dynamic"

// Helper to map Convex adventure to frontend Adventure type
function mapConvexAdventureToAdventure(raw: unknown): Adventure | null {
  if (!raw || typeof raw !== "object" || !("_id" in raw)) return null
  const a = raw as { _id: string; title: string; planId: string; startedAt: number; endedAt?: number; settingId?: string }
  return {
    id: a._id,
    title: a.title,
    adventurePlanId: a.planId,
    settingId: a.settingId ?? "",
    party: [],
    turns: [],
    startedAt: a.startedAt ? new Date(a.startedAt).toISOString() : "",
    endedAt: a.endedAt ? new Date(a.endedAt).toISOString() : undefined,
    pausedAt: undefined,
  }
}

export async function generateMetadata({ params }: { params: Promise<{ settingId: string; adventurePlanId: string; adventureId: string }> }): Promise<Metadata> {
  const { adventurePlanId } = await params
  return {
    title: `Adventure | ${adventurePlanId}`,
  }
}

function findEncounter(adventurePlan: AdventurePlan, encounterIdToFind: string | undefined) {
  if (!encounterIdToFind) return null
  for (const section of adventurePlan.sections) {
    for (const scene of section.scenes) {
      for (const encounter of scene.encounters) {
        if (encounter.id === encounterIdToFind) {
          return encounter
        }
      }
    }
  }
  return null
}

export default async function AdventurePage(props: { params: Promise<{ settingId: string; adventurePlanId: string; adventureId: string }> }) {
  const { adventurePlanId, adventureId, settingId } = await props.params
  let adventurePlan = null
  try {
    // Dynamically import the adventure plan JSON file
    adventurePlan = (await import(`@/data/${adventurePlanId}.json`)).default
  } catch {
    return notFound()
  }
  if (!adventurePlan) return notFound()
  const adventureData = await loadAdventureWithNpc(adventureId as Id<"adventures">)
  const adventure = mapConvexAdventureToAdventure(adventureData?.adventure)
  const currentTurn = mapConvexTurnToTurn(adventureData?.currentTurn)

  if (!adventure) return notFound()

  const encounter = findEncounter(adventurePlan, currentTurn?.encounterId)

  return <AdventureHome settingId={settingId} adventurePlanId={adventurePlanId} adventure={adventure} encounterImage={encounter?.image || adventurePlan.image} currentTurn={currentTurn} />
}


/*
  File: app/[settingId]/[adventurePlanId]/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/[settingId]/[adventurePlanId]/page.tsx
  Directory: app/[settingId]/[adventurePlanId]
*/

--- File: app/[settingId]/[adventurePlanId]/page.tsx ---

import { readJsonFromS3 } from "@/lib/s3-utils"
import AdventureHome from "@/components/views/adventure-home"
import type { AdventurePlan } from "@/types/adventure-plan"
import { thalbern } from "@/data/demo"
import { TurnCharacter } from "@/types/adventure"

export default async function AdventureHomePage(props: { params: Promise<{ settingId: string; adventurePlanId: string }> }) {
  const { settingId, adventurePlanId } = await props.params
  const key = `settings/${settingId}/${adventurePlanId}.json`
  let adventurePlan: AdventurePlan | null = null
  try {
    adventurePlan = (await readJsonFromS3(key)) as AdventurePlan
  } catch (err) {
    console.error("Error fetching JSON from S3:", err)
    return <div>Error loading adventure data.</div>
  }

  const demoAdventure = {
    id: "demo-adventure",
    title: adventurePlan.title,
    adventurePlanId: adventurePlan.id,
    settingId: settingId,
    party: [],
    turns: [],
    startedAt: new Date().toISOString(),
  }

  const demoTurn = {
    id: "demo-turn",
    adventureId: "demo-adventure",
    encounterId: "broken-silence",
    title: adventurePlan.title,
    subtitle: adventurePlan.sections[0].scenes[0].encounters[0].title,
    narrative: adventurePlan.sections[0].scenes[0].encounters[0].intro,
    characters: [
      {
        ...thalbern,
        initiative: 10,
      } as TurnCharacter,
    ],
  }

  return (
    <div className="flex min-h-screen flex-col relative">
      <AdventureHome adventure={demoAdventure} adventurePlanId={adventurePlanId} settingId={settingId} encounterImage={adventurePlan.image} teaser={adventurePlan.teaser} currentTurn={demoTurn} />
    </div>
  )
}


/*
  File: app/[settingId]/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/[settingId]/page.tsx
  Directory: app/[settingId]
*/

--- File: app/[settingId]/page.tsx ---

import { textShadow, textShadowSpread } from "@/components/typography/styles"
import Image from "next/image"

export default async function SettingHome(props: { params: Promise<{ settingId: string }> }) {
  const { settingId } = await props.params

  return (
    <div className="flex min-h-screen flex-col relative">
      <div className="fade-in delay-[2s] relative z-10">
        <h2 className="text-6xl font-display text-center w-full mt-36" style={textShadowSpread}>
          Setting Home
        </h2>
        <p className="text-center font-semibold text-xl" style={textShadow}>
          {settingId}
        </p>
      </div>
      <Image className="object-cover fade-in" fill={true} src="/images/app/backgrounds/d20-hero.png" alt="D20" />
    </div>
  )
}


/*
  File: app/_actions/advance-turn.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/advance-turn.ts
  Directory: app/_actions
*/

--- File: app/_actions/advance-turn.ts ---

"use server"
import { convex } from "@/lib/convex/server";
import { api } from "@/convex/_generated/api";
import { readJsonFromS3 } from "@/lib/s3-utils";
import { generateObject } from "@/lib/ai";
import { z } from "zod";
import type { Id } from "@/convex/_generated/dataModel";
import type { AdventurePlan } from "@/types/adventure-plan";
import type { Turn, TurnCharacter } from "@/types/adventure";
import { processNpcTurnsAfterCurrent } from "@/lib/services/npc-turn-service";
import { mapConvexTurnToTurn, rollD20 } from "@/lib/utils";
import wait from "waait"
import { appendNarrative } from "@/lib/services/narrative-service";

const encounterProgressionSchema = z.object({
  nextEncounterId: z.string(),
  narrative: z.string(),
});

// Type guard for characters with rollRequired and rollResult
function hasRollFields(
  c: TurnCharacter
): c is TurnCharacter & { rollRequired: { rollType: string; difficulty: number; modifier?: number }; rollResult: number } {
  return (
    "rollResult" in c &&
    typeof c.rollResult === "number" &&
    "rollRequired" in c &&
    typeof c.rollRequired === "object" &&
    c.rollRequired !== null
  );
}

export async function advanceTurn({ turnId, settingId, adventurePlanId }: { turnId: Id<"turns">; settingId: string; adventurePlanId: string }) {
  let shouldProcessNpcTurns = true; // Initialize to true by default
  // 1. Fetch the turn from Convex
  const turnData = await convex.query(api.adventure.getTurnById, { turnId });
  if (!turnData) throw new Error("Turn not found");
  const turn = mapConvexTurnToTurn({ ...turnData, adventureId: turnData.adventureId.toString() });
  if (!turn) throw new Error("Turn not found");

  // 2. Load the plan from S3
  console.log("[advanceTurn] settingId:", settingId, "adventurePlanId:", adventurePlanId);
  const plan = (await readJsonFromS3(`settings/${settingId}/${adventurePlanId}.json`)) as AdventurePlan;
  if (!plan || !plan.id || !plan.sections || !plan.title) {
    throw new Error("Adventure plan is missing required fields");
  }

  // 3. Find current encounter
  const findCurrentEncounter = (plan: AdventurePlan, currentEncounterId: string) =>
  plan.sections
    .flatMap(section => section.scenes)
    .flatMap(scene => scene.encounters)
    .find(encounter => encounter.id === currentEncounterId) ?? null;

  const currentEncounter = findCurrentEncounter(plan, turn.encounterId);
  if (!currentEncounter) throw new Error("Current encounter not found in plan");

  const encounterIntro = currentEncounter.intro ?? "";
  const encounterInstructions = currentEncounter.instructions ?? "";
  const narrativeContext = (turn.narrative ?? "")
    .split(/\n\n/)
    .slice(-3)
    .join("\n\n");

  // Extract the player's most recent action from the narrative
  const mostRecentNarrativeBlock = (turn.narrative ?? "").split(/\n\n/).filter(Boolean).at(-1) ?? "";

  // Try to parse the last DiceRoll from the narrative to construct rollInfo
  const diceRollRegex = /\[DiceRoll:([^\]]+)\]/g;
  const narrativeForRollParsing = turn.narrative ?? "";
  let matches;
  let lastDiceRollParamsStr: string | null = null;
  while ((matches = diceRollRegex.exec(narrativeForRollParsing)) !== null) {
    lastDiceRollParamsStr = matches[1];
  }

  let rollInfo = "No character-specific dice roll was identified as the immediate precursor to this state."; // Default

  if (lastDiceRollParamsStr) {
    const params = lastDiceRollParamsStr.split(';').reduce((acc, part) => {
      const [key, ...valueParts] = part.split('=');
      const value = valueParts.join('=');
      if (key && value !== undefined) acc[key.trim()] = value.trim();
      return acc;
    }, {} as Record<string, string>);

    const characterName = params.character;
    const rollType = params.rollType;
    const resultStr = params.result;
    const difficultyStr = params.difficulty;
    const successStr = params.success;
    const modifierStr = params.modifier;

    if (characterName && rollType && resultStr && difficultyStr && successStr) {
      const rollResult = parseInt(resultStr, 10);
      const difficulty = parseInt(difficultyStr, 10);
      const success = successStr === 'true';
      let modifier: number | undefined = undefined;
      let modifierText = "";

      if (modifierStr) {
          const parsedModifier = parseInt(modifierStr, 10);
          if (!isNaN(parsedModifier)) {
              modifier = parsedModifier;
              modifierText = `, modifier: ${modifier}`;
          }
      }

      if (!isNaN(rollResult) && !isNaN(difficulty)) {
        rollInfo = `Regarding the most recent dice roll: Character '${characterName}' attempted a '${rollType}'. The result was ${rollResult} (difficulty: ${difficulty}${modifierText}). This roll was a ${success ? 'SUCCESS' : 'FAILURE'}.`;
        console.log("[advanceTurn] Constructed rollInfo from parsed narrative:", rollInfo);
      } else {
        console.log("[advanceTurn] Failed to parse numeric rollResult/difficulty from DiceRoll tag. Parsed params:", JSON.stringify(params));
      }
    } else {
      console.log("[advanceTurn] Could not parse all required fields (character, rollType, result, difficulty, success) from DiceRoll tag. Parsed params:", JSON.stringify(params));
    }
  } else {
    console.log("[advanceTurn] No DiceRoll tag found in narrative. Attempting fallback to character object data for rollInfo.");
    const lastRollingCharacter = (turn.characters as TurnCharacter[]).find(hasRollFields);
    if (lastRollingCharacter) {
      const { name, rollRequired, rollResult: charRollResult } = lastRollingCharacter;
      const { rollType: charRollType, difficulty: charDifficulty, modifier: charModifier = 0 } = rollRequired;
      const charSuccess = charRollResult >= charDifficulty;
      rollInfo = `Regarding the most recent dice roll (from character data): Character '${name}' attempted a '${charRollType}'. The result was ${charRollResult} (difficulty: ${charDifficulty}, modifier: ${charModifier}). This roll was a ${charSuccess ? 'SUCCESS' : 'FAILURE'}.`;
      console.log("[advanceTurn] Constructed rollInfo from character data (fallback):", rollInfo);
    } else {
      console.log("[advanceTurn] No specific roll found in character data either (fallback). Using default message for rollInfo.");
    }
  }

  // Identify player characters
  const playerCharacters = (turn.characters as TurnCharacter[]).filter(c => c.type === 'pc');
  const playerCharacterNames = playerCharacters.map(c => c.name).join(", ");

  // 4. Ask LLM if encounter is resolved
  const transitionsText = currentEncounter.transitions
    ? (currentEncounter.transitions as { condition: string; encounter: string }[]).map(
        (t, i) =>
          `Transition Option ${i + 1} (leads to encounter ID: '${t.encounter}'):\n  Condition to check: ${t.condition}`
      ).join("\n")
    : "No explicit transitions defined for this encounter.";

  // --- DETAILED LOGGING FOR LLM PROMPT INPUTS ---
  console.log("\n[advanceTurn] --- LLM PROMPT INPUTS ---");
  console.log("[advanceTurn] Adventure Plan Overview:", plan.overview);
  console.log("[advanceTurn] Current Encounter Title:", currentEncounter.title);
  console.log("[advanceTurn] Current Encounter ID:", currentEncounter.id);
  console.log("[advanceTurn] Current Encounter Intro:", encounterIntro);
  console.log("[advanceTurn] Current Encounter Instructions:", encounterInstructions);
  console.log("[advanceTurn] Recent Narrative (context):\n", narrativeContext);
  console.log("[advanceTurn] Most Recent Narrative Block (action/event):\n", mostRecentNarrativeBlock);
  console.log("[advanceTurn] Roll Information For Context:", rollInfo);
  console.log("[advanceTurn] Available Transitions Text:\n", transitionsText);
  console.log("[advanceTurn] Player Character Names:", playerCharacterNames);
  console.log("--- END LLM PROMPT INPUTS ---\n");
  // --- END DETAILED LOGGING ---

  const prompt = `
Adventure Plan Overview:
${plan.overview}

Current Encounter Title: ${currentEncounter.title}
Current Encounter ID: ${currentEncounter.id}
Current Encounter Intro:
${encounterIntro}
Current Encounter Instructions:
${encounterInstructions}

Recent Narrative Context (last few paragraphs):
${narrativeContext}

Most Recent Action/Event from the narrative (this is what the player/environment JUST DID):
${mostRecentNarrativeBlock}

${rollInfo ? `Key Information Regarding Recent Dice Roll (related to the 'Most Recent Action/Event'):
${rollInfo}
` : 'No specific dice roll outcome to report for the most recent action.'}
Available Transition Options for '${currentEncounter.id}':
${transitionsText}

Your Task:
1. Carefully review the 'Recent Narrative Context', the 'Most Recent Action/Event', and any 'Key Information Regarding Recent Dice Roll'. These describe events that HAVE ALREADY HAPPENED.
2. Evaluate if the 'Most Recent Action/Event' and its 'Key Information Regarding Recent Dice Roll' (if present) DIRECTLY and EXPLICITLY fulfill any of the 'Condition to check' for the 'Available Transition Options'. A condition is only met if the player's PAST actions/rolls satisfy it. DO NOT assume the player takes a NEW action to meet a condition.
3. Determine the 'nextEncounterId':
    - If a transition condition IS MET by the player's PAST actions/rolls: Use the 'leads to encounter ID' from that met transition.
    - If MULTIPLE transition conditions appear to be met by PAST actions/rolls: Prioritize conditions related to explicit success or failure of a recent dice roll if applicable. If still ambiguous, use the first one that clearly applies.
    - If NO transition condition is clearly met by PAST actions/rolls, OR if meeting a condition would require a NEW player action (e.g., deciding to use stealth, choosing a dialogue option, attacking a new target): The 'nextEncounterId' MUST be the Current Encounter ID ('${currentEncounter.id}').
4. Generate a 'narrative' response:
    - If transitioning (because a condition was met by PAST actions/rolls): The narrative should briefly describe the events or state that fulfill the transition condition and logically lead into the new encounter. This acts as a bridge.
    - If NOT transitioning (i.e., 'nextEncounterId' is '${currentEncounter.id}'): The narrative MUST describe what happens next in the current encounter based on the 'Most Recent Action/Event' and 'Key Information Regarding Recent Dice Roll'. It should set the stage for the player's NEXT decision. For example, if a creature was detected, the narrative might describe the creature appearing or its immediate reaction, prompting the player to decide their next move. DO NOT write new actions or decisions for the player character(s).

IMPORTANT GUIDELINES:
- Only use encounter IDs explicitly listed in the 'Available Transition Options' or the 'Current Encounter ID' ('${currentEncounter.id}').
- Your 'narrative' response will set the stage for the player's NEXT turn.
- **CRITICAL REMINDER: DO NOT write new actions, dialogue, choices, or internal thoughts for the player character(s) (e.g., ${playerCharacterNames}).** The narrative must describe NPC actions, environmental changes, or the direct, immediate consequences of the player's PAST action/roll. The goal is to prepare for the player's *next actual decision*, not to make it for them.
- If a transition occurs due to a failed dice roll (that already happened), ensure the narrative reflects the consequences of that failure leading to the new situation.
- If a transition occurs due to a successful dice roll (that already happened), ensure the narrative reflects the consequences of that success.
- If no transition occurs, the narrative should clearly end in a way that prompts the player for their next action. For instance, describe the scene and end with a question like "What does Thalbern do next?" or simply describe the immediate situation that demands a response.

Respond in JSON:
{
  "nextEncounterId": string, // ID of the next/current encounter based on your evaluation
  "narrative": string      // Narrative for the transition OR for continuing the current encounter and prompting the player's next decision.
}
`;

  // Log the full prompt for debugging
  console.log("[advanceTurn] FULL LLM PROMPT:\n" + prompt);

  await wait(1000);
  const llmResult = (await generateObject({ prompt, schema: encounterProgressionSchema })).object;

  // Log the LLM's raw response
  console.log("[advanceTurn] LLM result:", JSON.stringify(llmResult, null, 2));

  // Log what the LLM decided about encounter progression
  console.log("[advanceTurn] Next encounterId:", llmResult.nextEncounterId);

  // 6. Build the new turn object
  let newTurn: Turn | null = null;
  if (llmResult.nextEncounterId === turn.encounterId) {
    // Continue current encounter
    let newCharacters: TurnCharacter[] = (turn.characters as TurnCharacter[]).filter((c) => c.status !== "dead" && c.status !== "fled");
    const narrative = llmResult.narrative || ""; // Use LLM narrative
    // Reset hasReplied, isComplete, and re-roll initiative for all characters
    newCharacters = newCharacters.map((c) => ({
      ...c,
      hasReplied: false,
      isComplete: false,
      initiative: rollD20(), // Re-roll initiative
    }));

    // Sort by new initiative
    newCharacters.sort((a, b) => (b.initiative ?? 0) - (a.initiative ?? 0));

    newTurn = {
      id: "", // placeholder, Convex will generate
      adventureId: turnData.adventureId,
      encounterId: turn.encounterId,
      title: currentEncounter.title,
      narrative,
      characters: newCharacters,
    };
  } else {
    // Transition to new encounter
    const nextEncounter = findCurrentEncounter(plan, llmResult.nextEncounterId);

    if (nextEncounter && nextEncounter.skipInitialNpcTurns) {
      console.log(`[advanceTurn] Skipping initial NPC turns for new encounter: ${nextEncounter.id}`);
      shouldProcessNpcTurns = false;
    }

    if (!nextEncounter) {
      await convex.mutation(api.turns.patchAdventure, { adventureId: turnData.adventureId, patch: { endedAt: Date.now(), updatedAt: Date.now() } });
      return { status: "adventure_complete" };
    }
    // PCs: persist from previous turn (remove dead/fled) and re-roll initiative
    const pcs: TurnCharacter[] = (turn.characters as TurnCharacter[])
      .filter((c) => c.type === "pc" && c.status !== "dead" && c.status !== "fled")
      .map((pc) => ({
        ...pc,
        initiative: rollD20(), // Re-roll PC initiative
      }));

    // NPCs: add from next encounter
    const npcs: TurnCharacter[] = (nextEncounter.npc || []).map((npcRef: { id: string; initialInitiative?: number }) => {
      const npc = plan.npcs[npcRef.id];
      return {
        ...npc,
        id: npcRef.id,
        type: "npc",
        isComplete: false,
        hasReplied: false,
        initiative: typeof npcRef.initialInitiative === 'number' ? npcRef.initialInitiative : rollD20(),
      };
    });
    let allCharacters: TurnCharacter[] = [...pcs, ...npcs];
    // Reset hasReplied and isComplete for all characters
    allCharacters = allCharacters.map((c) => ({
      ...c,
      hasReplied: false,
      isComplete: false,
    }));
    // Sort by new initiative
    allCharacters.sort((a, b) => (b.initiative ?? 0) - (a.initiative ?? 0));

    // Use appendNarrative utility for new encounter intro and new narrative
    const narrative = appendNarrative(llmResult.narrative || "", nextEncounter.intro || "");
    newTurn = {
      id: "", // placeholder, Convex will generate
      adventureId: turnData.adventureId,
      encounterId: nextEncounter.id,
      title: nextEncounter.title,
      narrative,
      characters: allCharacters, // Use the sorted and updated list
    };
  }

  // Determine if this new turn is for the final encounter
  const resolvedNextEncounterForFinalCheck = findCurrentEncounter(plan, newTurn.encounterId);
  const isFinalEncounter = resolvedNextEncounterForFinalCheck
    ? !resolvedNextEncounterForFinalCheck.transitions || resolvedNextEncounterForFinalCheck.transitions.length === 0
    : false;

  // 7. Create the new turn in Convex
  const newTurnId = await convex.mutation(api.turns.createTurn, {
    adventureId: turnData.adventureId,
    encounterId: newTurn.encounterId,
    title: newTurn.title,
    narrative: newTurn.narrative,
    characters: newTurn.characters,
    order: (turnData.order || 0) + 1,
    isFinalEncounter: isFinalEncounter,
  });

  // 8. Patch adventure with new currentTurnId
  await convex.mutation(api.turns.patchAdventure, {
    adventureId: turnData.adventureId,
    patch: { currentTurnId: newTurnId },
  });

  // 9. After creating the new turn, process NPC turn if needed
  if (shouldProcessNpcTurns) {
    await processNpcTurnsAfterCurrent(newTurnId);
  } else {
    console.log(`[advanceTurn] NPC turns processing was skipped for turnId: ${newTurnId}`);
  }

  // 10. Return the new turn/adventure state
  return { status: "turn_advanced", turn: newTurn };
} 

/*
  File: app/_actions/adventure.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/adventure.ts
  Directory: app/_actions
*/

--- File: app/_actions/adventure.ts ---

'use server'
import { api } from "@/convex/_generated/api"
import { convex } from "@/lib/convex/server"
import { auth } from "@clerk/nextjs/server"
import type { Id } from "@/convex/_generated/dataModel"
import type { TurnCharacter } from "@/types/adventure"
import { getRollRequirementHelper, getRollModifier, appendNarrative } from "@/lib/services/narrative-service"
import { generateText } from "@/lib/ai"
import { readJsonFromS3 } from "@/lib/s3-utils"
import type { AdventurePlan } from "@/types/adventure-plan"
import { getRollRequirementForAction } from "@/lib/services/roll-requirement-service"
import { processNpcTurnsAfterCurrent } from "@/lib/services/npc-turn-service"
import { analyzeAndApplyDiceRoll } from "@/lib/services/turn-update-service"
import wait from "waait"

// Placeholder type for ActionAssessment until it's defined in roll-requirement-service.ts
interface ActionAssessment {
  isPlausible?: boolean;
  feedback?: string | null;
  rollRequirement?: {
    rollType: string;
    difficulty: number;
    modifier?: number;
  } | null;
  rollType?: string;
  difficulty?: number;
  modifier?: number;
}

export async function processTurnReply({ turnId, characterId, narrativeAction }: { turnId: Id<"turns">; characterId: string; narrativeAction: string }) {
  console.log('[processTurnReply] CALLED')
  const { userId } = await auth()
  if (!userId) {
    console.error('[processTurnReply] Unauthorized access attempt.');
    throw new Error("Unauthorized")
  }
  
  const turn = await convex.query(api.adventure.getTurnById, { turnId })
  if (!turn) {
    console.error('[processTurnReply] Turn not found for turnId:', turnId);
    throw new Error("Turn not found")
  }
  console.log('[processTurnReply] Fetched turn:', JSON.stringify(turn, null, 2));
  
  const adventure = await convex.query(api.adventure.getAdventureById, { adventureId: turn.adventureId })
  if (!adventure) {
    console.error('[processTurnReply] Adventure not found for adventureId:', turn.adventureId);
    throw new Error("Adventure not found")
  }
  
  const planPath = `settings/${adventure.settingId}/${adventure.planId}.json`;
  console.log('[processTurnReply] Attempting to read adventure plan from S3:', planPath);
  const plan = (await readJsonFromS3(planPath)) as AdventurePlan
  if (!plan) {
    console.error('[processTurnReply] Adventure plan not found at path:', planPath);
    throw new Error("Adventure plan not found")
  }
  
  const encounter = plan.sections
    .flatMap((section) => section.scenes)
    .flatMap((scene) => scene.encounters)
    .find((e) => e.id === turn.encounterId)
  if (!encounter) {
    console.error('[processTurnReply] Encounter not found for encounterId:', turn.encounterId);
    throw new Error("Encounter not found")
  }
  console.log('[processTurnReply] Fetched encounter:', JSON.stringify(encounter, null, 2));
  
  const characterPerformingAction = turn.characters.find(c => c.id === characterId);
  if (!characterPerformingAction) {
    console.error('[processTurnReply] Character performing action not found for characterId:', characterId);
    throw new Error("Character performing action not found in turn data");
  }
  console.log('[processTurnReply] Character performing action:', JSON.stringify(characterPerformingAction, null, 2));

  // Prepare context for the updated getRollRequirementForAction
  const actionContext = {
    character: {
      name: characterPerformingAction.name,
      // You might need to fetch richer character data if it's not already on the turn.characters object.
      // For example, if character class, stats, or specific abilities are crucial for plausibility:
      // class: characterPerformingAction.class, 
      // abilities: characterPerformingAction.abilities,
    },
    encounter: {
      id: encounter.id,
      // name: encounter.name || "Unnamed Encounter", // Removed as 'name' might not exist
      // description: encounter.description || "No description", // Removed as 'description' might not exist
      instructions: encounter.instructions || "", // Keep instructions if available
    },
    plan: {
      planId: adventure.planId, // Use existing planId
      settingId: adventure.settingId, // Use existing settingId
      // name: plan.name || "Unnamed Plan", // Removed as 'name' might not exist
      // settingDescription: plan.setting?.description || "No setting description", // Removed
    }
  };
  console.log('[processTurnReply] Action context for getRollRequirementForAction:', JSON.stringify(actionContext, null, 2));

  // Call the (soon to be updated) getRollRequirementForAction
  // This function will now also return plausibility and feedback
  // @ts-expect-error // Expecting getRollRequirementForAction to be updated to accept 2 arguments
  const assessment: ActionAssessment = await getRollRequirementForAction(narrativeAction, actionContext)
  console.log("[processTurnReply] action assessment from getRollRequirementForAction:", JSON.stringify(assessment, null, 2));

  if (assessment && assessment.isPlausible === false) {
    // Action is not plausible, return feedback to the user to try again
    console.log('[processTurnReply] Action deemed implausible. Feedback:', assessment.feedback);
    return {
      actionImplausible: true,
      feedback: assessment.feedback || "This action is not possible or doesn't make sense in the current situation. Please try something else.",
    }
  }
  console.log('[processTurnReply] Action deemed plausible or plausibility check not present.');

  // If plausible, proceed with existing logic
  let rollRequirementDetails = null;
  if (assessment?.rollRequirement) {
    rollRequirementDetails = assessment.rollRequirement;
  } else if (assessment?.rollType && typeof assessment.difficulty === 'number') {
    rollRequirementDetails = {
      rollType: assessment.rollType,
      difficulty: assessment.difficulty,
      modifier: assessment.modifier,
    };
  }

  console.log('[processTurnReply] Derived rollRequirementDetails:', JSON.stringify(rollRequirementDetails, null, 2));

  if (rollRequirementDetails && rollRequirementDetails.rollType && typeof rollRequirementDetails.difficulty === 'number') {
    console.log('[processTurnReply] Roll IS required. Submitting reply with rollRequirementDetails.');
    // Set rollRequirement for the character, do not mark as complete
    const submitReplyArgs = {
      turnId,
      characterId,
      narrativeAction,
      rollRequirement: rollRequirementDetails, // Pass the extracted details
    };
    console.log('[processTurnReply] Convex mutation api.adventure.submitReply ARGS (roll required):', JSON.stringify(submitReplyArgs, null, 2));
    await convex.mutation(api.adventure.submitReply, submitReplyArgs)
    console.log('[processTurnReply] Convex mutation api.adventure.submitReply successful (roll required).');
    return { rollRequired: rollRequirementDetails }
  } else {
    console.log('[processTurnReply] Roll IS NOT required or rollRequirementDetails is malformed. Marking character complete.');
    // Mark character as complete and hasReplied
    const submitReplyArgs = {
      turnId,
      characterId,
      narrativeAction,
      rollRequirement: undefined,
    };
    console.log('[processTurnReply] Convex mutation api.adventure.submitReply ARGS (no roll):', JSON.stringify(submitReplyArgs, null, 2));
    await convex.mutation(api.adventure.submitReply, submitReplyArgs)
    console.log('[processTurnReply] Convex mutation api.adventure.submitReply successful (no roll).');
    // After marking player complete, process NPCs
    console.log('[processTurnReply] Processing NPC turns after player reply.');
    await processNpcTurnsAfterCurrent(turnId);
    console.log('[processTurnReply] NPC turn processing complete.');
    return { rollRequired: null }
  }
}

export async function createAdventureWithFirstTurn(payload: {
  planId: string;
  settingId: string;
  ownerId: string;
  playerIds: string[];
  title: string;
  startedAt: number;
  playerInput: string;
  turn: {
    encounterId: string;
    narrative: string;
    characters: TurnCharacter[];
    order: number;
  };
}) {
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");

  // Read the adventure plan to get the encounter title
  const plan = (await readJsonFromS3(`settings/${payload.settingId}/${payload.planId}.json`)) as AdventurePlan;
  if (!plan || !plan.sections) {
    throw new Error("Adventure plan not found or is invalid");
  }
  const firstEncounter = plan.sections
    .flatMap(section => section.scenes)
    .flatMap(scene => scene.encounters)
    .find(encounter => encounter.id === payload.turn.encounterId);

  if (!firstEncounter || !firstEncounter.title) {
    throw new Error(`First encounter (ID: ${payload.turn.encounterId}) not found in plan or is missing a title.`);
  }

  const turnWithTitle = {
    ...payload.turn,
    title: firstEncounter.title,
  };

  // Prepare context for AI
  const paragraphs = (payload.turn.narrative || "").split(/\n\n+/).filter(Boolean);
  const lastAction = paragraphs[paragraphs.length - 1] || "";
  const encounterIntro = "";
  const encounterInstructions = "";
  const narrativeContext = paragraphs.slice(-2).join("\n\n");
  let rollRequirement = null;
  if (payload.playerInput && payload.playerInput.trim().length > 0) {
    rollRequirement = await getRollRequirementHelper(payload.playerInput, {
      encounterIntro,
      encounterInstructions,
      narrativeContext,
    });
    if (rollRequirement) {
      const actor = payload.turn.characters[0];
      const modifier = await getRollModifier({
        scenario: { encounterIntro, encounterInstructions, narrativeContext },
        rollRequirement,
        character: actor,
      });
      if (typeof modifier === "number") {
        rollRequirement.modifier = modifier;
      }
    }
  }
  if (!rollRequirement && lastAction && lastAction.trim().length > 0) {
    rollRequirement = await getRollRequirementHelper(lastAction, {
      encounterIntro,
      encounterInstructions,
      narrativeContext,
    });
    if (rollRequirement) {
      const actor = payload.turn.characters[0];
      const modifier = await getRollModifier({
        scenario: { encounterIntro, encounterInstructions, narrativeContext },
        rollRequirement,
        character: actor,
      });
      if (typeof modifier === "number") {
        rollRequirement.modifier = modifier;
      }
    }
  }

  // Overwrite ownerId with the authenticated user
  return convex.mutation(api.adventure.createAdventureWithFirstTurn, {
    ...payload,
    settingId: payload.settingId,
    ownerId: userId,
    turn: turnWithTitle, // Pass the turn object with the title
    rollRequirement,
  });
}

export async function resolvePlayerRollResult({
  turnId,
  characterId,
  result,
}: {
  turnId: Id<"turns">;
  characterId: string;
  result: number;
}) {
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");

  // 1. Fetch the turn
  const turn = await convex.query(api.adventure.getTurnById, { turnId });
  if (!turn) throw new Error("Turn not found");
  const character = turn.characters.find((c) => c.id === characterId);
  if (!character) throw new Error("Character not found");
  if (!character.rollRequired) throw new Error("No roll required for this character");
  if (typeof character.rollResult === "number") throw new Error("Roll already completed");

  // 2. Fetch the adventure and plan
  const adventure = await convex.query(api.adventure.getAdventureById, { adventureId: turn.adventureId });
  if (!adventure) throw new Error("Adventure not found");
  const planKey = `settings/${adventure.settingId}/${adventure.planId}.json`;
  const plan = (await readJsonFromS3(planKey)) as AdventurePlan;
  if (!plan || !Array.isArray(plan.sections)) throw new Error("Adventure plan not found or invalid");

  // 3. Extract encounter instructions
  let encounterInstructions = "";
  for (const section of plan.sections) {
    for (const scene of section.scenes) {
      const encounter = scene.encounters.find((e: { id: string }) => e.id === turn.encounterId);
      if (encounter) {
        encounterInstructions = encounter.instructions || "";
        break;
      }
    }
    if (encounterInstructions) break;
  }

  // 4. Build the prompt and call the LLM
  const { rollType, difficulty, modifier = 0 } = character.rollRequired;
  const baseRoll = result;
  const totalResult = baseRoll + modifier;
  const success = totalResult >= difficulty;
  const margin = totalResult - difficulty;
  const shortcode = `[DiceRoll:rollType=${rollType};baseRoll=${baseRoll};modifier=${modifier >= 0 ? "+" + modifier : modifier};result=${totalResult};difficulty=${difficulty};character=${character.name};image=${character.image};success=${success}]\n`;

  let newNarrative = appendNarrative(turn.narrative || "", shortcode);
  
  const narrativeContext = (turn.narrative || "").split(/\n\n+/).slice(-2).join("\n\n");
  const rollOutcomePrompt = `
Context:
${narrativeContext}

Encounter Instructions:
${encounterInstructions}

Player action: "${shortcode}"

A dice roll was made for ${character.name}: ${rollType} (Result: ${totalResult}, Difficulty: ${difficulty}, Margin: ${margin}).

The margin indicates how close the roll was to the target number. Use this information to inspire the drama, tension, or impact of the outcome, but write a creative, immersive narrative that fits the context. Do not use game terms like "margin" or "DC" in the narrative.

Write a single, concise, immersive third-person PRESENT-tense narrative paragraph (exactly two sentences, max 60 words) describing the direct outcome of the roll. Focus on what the character perceives or the immediate result of their action (e.g., a lock clicking open, a rope snapping, information gained). If the roll was for perception, describe what is now sensed or known. **Do not narrate combat actions, damage, or status effects inflicted by other entities as part of this roll\'s outcome; these will be handled by subsequent game mechanics.** Only describe self-inflicted effects if the character\'s own roll was a critical failure of an action they were taking. Only reference things present in the context. Do not invent new objects, people, or events not implied by the context or encounter instructions. Write in third person PRESENT tense. Do not use lists, bullet points, or markdown formatting. Do not use semicolons. Never mention game mechanics, dice, or rules.

Output only the narrative paragraph.`.trim();

  let rollOutcome = "";
  try {
    const { text } = await generateText({ prompt: rollOutcomePrompt });
    rollOutcome = text;
    // LOGGING: Before appending rollOutcome
    console.log("[appendNarrative] BEFORE rollOutcome", { prev: newNarrative, rollOutcome });
    newNarrative = appendNarrative(newNarrative, rollOutcome);
    // LOGGING: After appending rollOutcome
    console.log("[appendNarrative] AFTER rollOutcome", { newNarrative });
  } catch (err) {
    console.error("[resolvePlayerRollResult] Error generating roll outcome:", err);
  }

  // 5. Use analyzeAndApplyDiceRoll to update healthPercent/status if needed
  const diceRoll = {
    rollType,
    baseRoll,
    modifier,
    result: totalResult,
    difficulty,
    character: character.name,
    success,
  };
  await wait(500)
  const updatedTurn = await analyzeAndApplyDiceRoll({
    turn: { 
      ...turn, 
      characters: turn.characters.map(c => ({
        ...c,
        healthPercent: typeof c.healthPercent === "number" ? c.healthPercent : 100,
      })),
    },
    diceRoll,
    narrative: newNarrative,
  });

  // Ensure the rolling character is marked complete and roll fields are set
  const updatedCharacters = updatedTurn.characters.map(c =>
    c.id === characterId
      ? {
          ...c,
          rollRequired: undefined,
          rollResult: totalResult,
          isComplete: true,
          hasReplied: true,
        }
      : c
  );

  // 6. Patch the turn with the new narrative and character state
  await convex.mutation(api.turns.updateTurn, {
    turnId,
    patch: {
      narrative: newNarrative,
      characters: updatedCharacters,
      updatedAt: Date.now(),
    },
  });

  // After marking player complete, process NPCs
  await processNpcTurnsAfterCurrent(turnId);

  // 7. Return the updated turn
  return await convex.query(api.adventure.getTurnById, { turnId });
} 

/*
  File: app/_actions/ban-user.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/ban-user.ts
  Directory: app/_actions
*/

--- File: app/_actions/ban-user.ts ---

'use server'

import { auth, clerkClient } from "@clerk/nextjs/server"
import { revalidatePath } from "next/cache"
import { isAdmin } from "@/lib/auth-utils"

export async function banUser(userId: string, reason?: string) {
  try {
    // Get the current user's ID
    const { userId: adminId } = await auth()
    
    if (!adminId) {
      throw new Error("Not authenticated")
    }

    // Verify the user is an admin
    const isUserAdmin = await isAdmin()
    if (!isUserAdmin) {
      throw new Error("Not authorized")
    }

    // Initialize Clerk client
    const client = await clerkClient()

    // Get current user to check if they're banned
    const user = await client.users.getUser(userId)
    const isBanned = user.banned

    if (isBanned) {
      // Unban the user
      await client.users.unbanUser(userId)
    } else {
      // Ban the user and store reason in metadata
      await client.users.banUser(userId)
      
      // Store the ban reason in metadata if provided
      if (reason) {
        await client.users.updateUser(userId, {
          publicMetadata: {
            ...user.publicMetadata,
            banReason: reason
          }
        })
      }
    }

    // Revalidate the admin users page
    revalidatePath("/admin/users")

    return { success: true }
  } catch (error) {
    console.error("Error managing user ban status:", error)
    return { success: false, error: (error as Error).message }
  }
} 

/*
  File: app/_actions/check-encounter-final.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/check-encounter-final.ts
  Directory: app/_actions
*/

--- File: app/_actions/check-encounter-final.ts ---

"use server"

import { convex } from "@/lib/convex/server"
import { api } from "@/convex/_generated/api"
import { readJsonFromS3 } from "@/lib/s3-utils"
import type { Id } from "@/convex/_generated/dataModel"
import type { AdventurePlan } from "@/types/adventure-plan"

export async function checkIsEncounterFinal(turnId: Id<"turns">): Promise<boolean> {
  // 1. Fetch the turn from Convex
  const turn = await convex.query(api.adventure.getTurnById, { turnId })
  if (!turn) throw new Error("Turn not found")

  // 2. Fetch the adventure to get settingId and planId
  const adventure = await convex.query(api.adventure.getAdventureById, { adventureId: turn.adventureId })
  if (!adventure) throw new Error("Adventure not found")

  // 3. Load the plan from S3
  const plan = (await readJsonFromS3(`settings/${adventure.settingId}/${adventure.planId}.json`)) as AdventurePlan
  if (!plan || !plan.sections) throw new Error("Adventure plan not found")

  // 4. Find current encounter
  const currentEncounter = plan.sections
    .flatMap(section => section.scenes)
    .flatMap(scene => scene.encounters)
    .find(encounter => encounter.id === turn.encounterId)

  if (!currentEncounter) throw new Error("Current encounter not found in plan")

  // 5. Check if encounter has no transitions (indicating it's the final encounter)
  return !currentEncounter.transitions || currentEncounter.transitions.length === 0
} 

/*
  File: app/_actions/contact.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/contact.ts
  Directory: app/_actions
*/

--- File: app/_actions/contact.ts ---

"use server"

import { z } from "zod"
import sgMail from "@sendgrid/mail"
import { verifyCaptcha } from "./verifyCaptcha"

const contactFormSchema = z.object({
  name: z.string().min(1, "Name is required"),
  email: z.string().email("Invalid email address"),
  message: z.string().min(1, "Message is required"),
  subject: z.string().default("Contact Form Submission"),
  captchaToken: z.string().optional(),
})

type ContactFormData = z.infer<typeof contactFormSchema>

export async function sendContactEmail(data: ContactFormData) {
  try {
    // Validate the input data
    const validatedData = contactFormSchema.parse(data)

    // Verify captcha if token is provided
    if (validatedData.captchaToken) {
      try {
        await verifyCaptcha(validatedData.captchaToken)
      } catch (error) {
        console.error("Error verifying captcha:", error)
        return {
          success: false as const,
          error: "reCAPTCHA verification failed. Please try again.",
        }
      }
    }

    // Configure SendGrid
    sgMail.setApiKey(process.env.SENDGRID_API_KEY!)

    // Prepare the email
    const msg = {
      to: process.env.CONTACT_EMAIL!,
      from: process.env.SENDGRID_SENDER!, // Must be verified sender in SendGrid
      replyTo: validatedData.email,
      subject: validatedData.subject,
      text: `Name: ${validatedData.name}\nEmail: ${validatedData.email}\n\nMessage:\n${validatedData.message}`,
      html: `
        <h2>New Contact Form Submission</h2>
        <p><strong>Name:</strong> ${validatedData.name}</p>
        <p><strong>Email:</strong> ${validatedData.email}</p>
        <p><strong>Message:</strong></p>
        <p>${validatedData.message.replace(/\n/g, "<br>")}</p>
      `,
    }

    // Send the email
    await sgMail.send(msg)

    return {
      success: true as const,
    }
  } catch (error) {
    console.error("Error sending contact email:", error)
    return {
      success: false as const,
      error: error instanceof Error ? error.message : "Failed to send email",
    }
  }
} 

/*
  File: app/_actions/get-roll-requirement.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/get-roll-requirement.ts
  Directory: app/_actions
*/

--- File: app/_actions/get-roll-requirement.ts ---

import { getRollRequirementForAction } from "@/lib/services/roll-requirement-service";

export async function getRollRequirement(reply: string) {
  return getRollRequirementForAction(reply);
} 

/*
  File: app/_actions/load-adventure.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/load-adventure.ts
  Directory: app/_actions
*/

--- File: app/_actions/load-adventure.ts ---

'use server'
import { api } from "@/convex/_generated/api";
import { convex } from "@/lib/convex/server";
import { auth } from "@clerk/nextjs/server";
import type { Id } from "@/convex/_generated/dataModel";

export async function loadAdventureWithNpc(adventureId: Id<"adventures">, refreshKey?: number) {
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");
  return convex.mutation(api.adventure.getCurrentAdventureWithNpcProcessing, { adventureId, refreshKey });
} 

/*
  File: app/_actions/mailing-list.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/mailing-list.ts
  Directory: app/_actions
*/

--- File: app/_actions/mailing-list.ts ---

"use server"

import { auth } from "@clerk/nextjs/server"
import sgMail from "@sendgrid/mail"
import { revalidatePath } from "next/cache"
import {
  addMailingListSubscription,
  removeMailingListSubscription,
  getMailingListSubscriptions
} from "@/lib/services/mailing-list"

// Configure SendGrid and track availability
let isEmailServiceConfigured = false

if (process.env.SENDGRID_API_KEY) {
  sgMail.setApiKey(process.env.SENDGRID_API_KEY)
  isEmailServiceConfigured = true
} else {
  console.warn("SENDGRID_API_KEY not found. Email service will be disabled.")
}

// Helper to check if email service is available
function isEmailServiceAvailable() {
  return isEmailServiceConfigured
}

export async function subscribe(data: {
  userId: string
  email: string
  name: string | null
}) {
  try {
    const result = await addMailingListSubscription({
      userId: data.userId,
      email: data.email,
      name: data.name ?? undefined,
      // Preferences are no longer passed for waitlist
    })
    revalidatePath("/mailing-list") // Consider if this path is still relevant or needs to be /waitlist
    return {
      success: !!result,
      emailServiceAvailable: isEmailServiceAvailable()
    }
  } catch (error) {
    console.error("Error in subscribe:", error)
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to subscribe",
      emailServiceAvailable: isEmailServiceAvailable()
    }
  }
}

export async function unsubscribe(email: string) {
  try {
    const result = await removeMailingListSubscription(email)
    revalidatePath("/mailing-list") // Consider if this path is still relevant
    return {
      success: result,
      emailServiceAvailable: isEmailServiceAvailable()
    }
  } catch (error) {
    console.error("Error in unsubscribe:", error)
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to unsubscribe",
      emailServiceAvailable: isEmailServiceAvailable()
    }
  }
}

export async function getSubscription() {
  try {
    const { userId } = await auth()
    if (!userId) {
      return {
        success: true as const,
        data: null,
      }
    }
    const subscriptions = await getMailingListSubscriptions()
    // Assuming the shape of subscription object and how to find the relevant one might need adjustment
    // if `unsubscribedAt` or other fields were tied to preferences.
    const sub = subscriptions.find(s => s.userId === userId && s.unsubscribedAt === null)
    return {
      success: true as const,
      data: sub || null,
    }
  } catch (error) {
    console.error("Error in getSubscription:", error)
    return {
      success: false as const,
      error: error instanceof Error ? error.message : "Failed to get subscription",
    }
  }
} 

/*
  File: app/_actions/profile.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/profile.ts
  Directory: app/_actions
*/

--- File: app/_actions/profile.ts ---

"use server"

import { clerkClient } from "@clerk/nextjs/server"
import { revalidatePath } from "next/cache"

interface Link {
  label: string
  url: string
}

interface UpdateProfileData {
  firstName: string
  lastName: string
  bio: string
  website?: string
  twitter?: string
  github?: string
  customLinks?: Link[]
}

export async function updateProfile(userId: string, data: UpdateProfileData) {
  try {
    const client = await clerkClient()
    await client.users.updateUser(userId, {
      firstName: data.firstName || "",
      lastName: data.lastName || "",
      unsafeMetadata: {
        bio: data.bio || "",
        website: data.website || "",
        twitter: data.twitter || "",
        github: data.github || "",
        customLinks: data.customLinks || [],
      },
    })

    return { success: true }
  } catch (error) {
    console.error("Error updating profile:", error)
    return { success: false, error: "Failed to update profile" }
  }
}

export async function refreshProfile(path: string) {
  revalidatePath(path)
} 

/*
  File: app/_actions/tokens.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/tokens.ts
  Directory: app/_actions
*/

--- File: app/_actions/tokens.ts ---

'use server'

import { auth } from "@clerk/nextjs/server";
import { convex } from "@/lib/convex/server"; // Assuming you have a server client setup
import { api } from "@/convex/_generated/api";
// import type { Id } from "@/convex/_generated/dataModel"; // Not used

interface DecrementTokensArgs {
  tokensUsed: number;
  transactionType: "usage_generate_text" | "usage_generate_object";
  description?: string;
  modelId?: string;
}

export async function decrementUserTokensAction(args: DecrementTokensArgs) {
  const { userId } = await auth(); 

  if (!userId) {
    console.error("decrementUserTokensAction: User not authenticated. Cannot decrement tokens.");
    // Depending on strictness, you might throw an error or return a specific failure response
    return { success: false, error: "User not authenticated" };
  }

  if (args.tokensUsed <= 0) {
    console.log("decrementUserTokensAction: No tokens to decrement or invalid amount.", args);
    return { success: true, message: "No tokens to decrement or invalid amount." };
  }

  try {
    const description = args.description || `Token usage for ${args.transactionType}${args.modelId ? ' (' + args.modelId + ')' : ''}`;
    const result = await convex.mutation(api.userTokenManagement.decrementTokens, {
      userId,
      tokensUsed: args.tokensUsed,
      transactionType: args.transactionType,
      description: description,
    });
    console.log("decrementUserTokensAction: Tokens decremented successfully for user:", userId, "Result:", result);
    return { success: true, data: result };
  } catch (error) {
    console.error(
      "decrementUserTokensAction: Failed to decrement tokens for user:",
      userId,
      "Error:",
      error
    );
    // Handle specific errors from decrementTokens if needed, e.g., insufficient tokens
    return { success: false, error: "Failed to decrement tokens", details: error };
  }
} 

/*
  File: app/_actions/track-visit.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/track-visit.ts
  Directory: app/_actions
*/

--- File: app/_actions/track-visit.ts ---

'use server'

import { auth } from "@clerk/nextjs/server"
import { headers } from "next/headers"
import { validRoutes } from "@/lib/generated/routes"
import { ConvexHttpClient } from "convex/browser"
import { api } from "@/convex/_generated/api"

// Initialize Convex HTTP client
const convex = new ConvexHttpClient(process.env.NEXT_PUBLIC_CONVEX_URL!)

// Check if the user agent is from a common legitimate browser
function isValidBrowser(userAgent: string | null): boolean {
  if (!userAgent) return false
  
  const commonBrowsers = [
    'Chrome',
    'Firefox',
    'Safari',
    'Edge',
    'Opera',
    'Edg',  // Edge's newer user agent
    'OPR',  // Opera's newer user agent
  ]
  
  const lowerUA = userAgent.toLowerCase()
  return commonBrowsers.some(browser => 
    lowerUA.includes(browser.toLowerCase())
  )
}

// Check if a path exists in our app
function isValidPath(path: string): boolean {
  // Special case for root path
  if (path === '/') {
    return true
  }

  // Normalize the path by removing leading slash
  const normalizedPath = path.startsWith('/') ? path.slice(1) : path
  
  // Check exact match first
  if (validRoutes.has(normalizedPath)) {
    return true
  }

  // Check if the path matches any dynamic routes
  // Split the path into segments
  const segments = normalizedPath.split('/')
  
  // Try matching each segment level
  let currentPath = ''
  for (const segment of segments) {
    currentPath = currentPath + (currentPath === '' ? segment : '/' + segment)
    // Check if there's a wildcard route at this level
    if (validRoutes.has(currentPath + '/*')) {
      return true
    }
  }

  return false
}

export async function trackVisit(path: string) {
  try {
    // Get the current user's ID if they're authenticated
    const { userId } = await auth()
    
    // Get headers for user agent and referrer
    const headersList = await headers()
    const userAgent = headersList.get('user-agent')
    const referrer = headersList.get('referer') // Note: 'referer' is the standard header name
    
    // Skip recording visits from non-browser user agents
    if (!isValidBrowser(userAgent)) {
      return { success: true }
    }

    // Skip recording visits to invalid paths
    if (!isValidPath(path)) {
      return { success: true }
    }

    // Record the visit using Convex
    await convex.mutation(api.visits.recordVisit, {
      path,
      userId: userId || null,
      metadata: {
        userAgent: userAgent || null,
        referrer: referrer || null,
      }
    })

    return { success: true }
  } catch (error) {
    console.error('Error tracking visit:', error)
    return { success: false, error: (error as Error).message }
  }
} 

/*
  File: app/_actions/user-token-actions.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/user-token-actions.ts
  Directory: app/_actions
*/

--- File: app/_actions/user-token-actions.ts ---

'use server';

import { auth } from "@clerk/nextjs/server";
import { convex } from "@/lib/convex/server";
import { api } from "@/convex/_generated/api";

export async function fetchUserTokenBalance() {
  const { userId } = await auth();
  if (!userId) {
    // Or return a specific error object/status
    throw new Error("User not authenticated. Cannot fetch token balance.");
  }

  try {
    // Step 1: Ensure the user token record exists (and grant initial tokens if new)
    await convex.mutation(api.userTokenManagement.ensureUserTokenRecord, { userId });

    // Step 2: Fetch the latest token balance
    const balance = await convex.query(api.userTokenManagement.getTokenBalance, { userId });
    
    return {
      tokensRemaining: balance.tokensRemaining,
      alltimeTokens: balance.alltimeTokens,
      // You could also return balance.needsInitialization if the client needs to know
    };
  } catch (error) {
    console.error(`Error fetching token balance for user ${userId}:`, error);
    // Depending on client-side handling, you might want to throw the error
    // or return a specific error structure.
    // For the context provider, returning null or an error object might be better.
    throw new Error(`Failed to fetch token balance: ${error instanceof Error ? error.message : String(error)}`);
    // Or: return { tokensRemaining: null, alltimeTokens: null, error: "Failed to fetch balance." };
  }
} 

/*
  File: app/_actions/verifyCaptcha.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/verifyCaptcha.ts
  Directory: app/_actions
*/

--- File: app/_actions/verifyCaptcha.ts ---

export async function verifyCaptcha(captchaToken: string) {
  "use server";

  const RECAPTCHA_SECRET_KEY = process.env.RECAPTCHA_SECRET_KEY;

  const response = await fetch(`https://www.google.com/recaptcha/api/siteverify`, {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
    },
    body: `secret=${RECAPTCHA_SECRET_KEY}&response=${captchaToken}`,
  });

  const captchaValidation = await response.json();
  if (captchaValidation.success) {
    return true;
  } else {
    throw new Error("reCAPTCHA validation failed");
  }
}

/*
  File: app/_hooks/useGenerateImage.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_hooks/useGenerateImage.ts
  Directory: app/_hooks
*/

--- File: app/_hooks/useGenerateImage.ts ---

import { useState } from "react"

interface ImageResponse {
  imageUrl: string
  success: boolean
  error?: string
}

export function useGenerateImage() {
  const [error, setError] = useState<string>("")
  const [isLoading, setIsLoading] = useState(false)
  const [imageUrl, setImageUrl] = useState<string>("")

  const generate = async (prompt: string) => {
    setError("")
    setIsLoading(true)
    try {
      const response = await fetch("/api/ai/generate/image", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          input: prompt,
          userId: "demo", // Using a demo folder for the AI demo
          deckId: "ai-demo" // Using a fixed demo deck ID
        }),
      })

      const data: ImageResponse = await response.json()

      if (!data.success) {
        throw new Error(data.error || "Failed to generate image")
      }

      setImageUrl(data.imageUrl)
    } catch (err) {
      console.error("Error generating image:", err)
      setError(err instanceof Error ? err.message : "Failed to generate image")
    } finally {
      setIsLoading(false)
    }
  }

  return {
    imageUrl,
    isLoading,
    error,
    generate,
  }
} 

/*
  File: app/_hooks/useGenerateObject.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_hooks/useGenerateObject.ts
  Directory: app/_hooks
*/

--- File: app/_hooks/useGenerateObject.ts ---

import { experimental_useObject as useObject } from "@ai-sdk/react"
import { z } from "zod"
import { useState } from "react"
import { zodToJsonSchema } from "zod-to-json-schema"

export function useGenerateObject<T extends z.ZodTypeAny>(schema: T) {
  const [error, setError] = useState<string>("")
  
  type InferredType = z.infer<T>
  
  const { object, isLoading, submit } = useObject<InferredType>({
    api: "/api/ai/generate/object",
    schema,
  })

  const generate = async (prompt: string) => {
    setError("")
    try {
      // Convert Zod schema to JSON schema
      const jsonSchema = zodToJsonSchema(schema)
      
      await submit({
        schema: jsonSchema,
        prompt,
      })
    } catch (err) {
      console.error("Error generating object:", err)
      setError("Failed to generate structured data")
    }
  }

  return {
    object,
    isLoading,
    error,
    generate,
  }
}

// Example usage:
// const { object, isLoading, error, generate } = useGenerateObject(personSchema)


/*
  File: app/_hooks/useGenerateStrings.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_hooks/useGenerateStrings.ts
  Directory: app/_hooks
*/

--- File: app/_hooks/useGenerateStrings.ts ---

import { experimental_useObject as useObject } from '@ai-sdk/react';
import { z } from "zod"
import { useState, useEffect, useRef } from "react"

const responseSchema = z.object({
  strings: z.array(z.string()),
})

type ResponseType = z.infer<typeof responseSchema>

export function useGenerateStrings() {
  const [strings, setStrings] = useState<string[]>([])
  const [error, setError] = useState<string>("")
  const promiseRef = useRef<{
    resolve: (value: string[]) => void;
    reject: (reason?: Error | unknown) => void;
  } | null>(null);

  const {
    object: response,
    isLoading,
    submit,
    error: objectError,
  } = useObject<ResponseType>({
    api: "/api/ai/generate/strings",
    schema: responseSchema,
  })

  useEffect(() => {
    if (objectError) {
      console.error("useGenerateStrings error:", objectError)
      setError("An error occurred while generating strings.")
      if (promiseRef.current) {
        promiseRef.current.reject(objectError);
        promiseRef.current = null;
      }
    }
  }, [objectError])

  useEffect(() => {
    if (response?.strings) {
      const validStrings = response.strings.filter((s): s is string => typeof s === "string")
      setStrings(validStrings)
    }
  }, [response])

  // Effect to resolve the promise when loading completes
  useEffect(() => {
    // If we were loading and now we're not, and we have a promise to resolve
    if (!isLoading && promiseRef.current && response?.strings) {
      const validStrings = response.strings.filter((s): s is string => typeof s === "string")
      promiseRef.current.resolve(validStrings);
      promiseRef.current = null;
    }
  }, [isLoading, response]);

  const generate = async (prompt: string, count: number = 6) => {
    setError("")
    setStrings([])
    
    return new Promise<string[]>((resolve, reject) => {
      try {
        // Store the promise callbacks
        promiseRef.current = { resolve, reject };
        
        // Submit the request
        submit({
          prompt,
          count,
        })
        
        // Set a timeout of 30 seconds
        const timeoutId = setTimeout(() => {
          if (promiseRef.current) {
            promiseRef.current.reject(new Error("Timed out waiting for string generation"));
            promiseRef.current = null;
          }
        }, 30000);
        
        // Clean up timeout if component unmounts
        return () => clearTimeout(timeoutId);
      } catch (error) {
        console.error("Error submitting string generation:", error)
        setError("An error occurred while generating strings.")
        reject(error);
        promiseRef.current = null;
      }
    })
  }

  return {
    strings,
    isLoading,
    error,
    generate,
  }
}


/*
  File: app/_hooks/useGenerateText.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_hooks/useGenerateText.ts
  Directory: app/_hooks
*/

--- File: app/_hooks/useGenerateText.ts ---

"use client"
import { useChat } from "@ai-sdk/react"

export function useGenerateText() {
  const { messages, input, handleInputChange, handleSubmit } = useChat({
    api: "/api/ai/generate/text",
  })

  const streamText = async (prompt: string, onUpdate: (output: string) => void) => {
    
    const response = await fetch("/api/ai/generate/text", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ input: prompt + " - Use smart quotes and avoid using backslashes" }),
    })

    if (!response.ok) {
      throw new Error(response.statusText)
    }

    const data = response.body
    if (!data) {
      return
    }

    const reader = data.getReader()
    const decoder = new TextDecoder()
    let done = false
    let accumulatedResponse = ""

    while (!done) {
      const { value, done: doneReading } = await reader.read()
      done = doneReading
      const chunkValue = decoder.decode(value)

      // Handle chunks with "0:" prefix
      const chunks = chunkValue.split(/(?=\d+:"|[ed]:"|f:)/).filter(Boolean)

      for (const chunk of chunks) {
        // Skip metadata chunks (including messageId)
        if (chunk.startsWith("f:") || chunk.startsWith("e:") || chunk.startsWith("d:")) {
          continue
        }

        if (chunk.startsWith('0:"')) {
          // Extract content between quotes for "0:" prefixed chunks
          const content = chunk.match(/0:"([^"]*)"/)
          if (content) {
            // Replace literal \n\n with actual newlines and clean up backslashed quotes
            accumulatedResponse += content[1]
              .replace(/\\n\\n/g, "\n\n")
              .replace(/\\"/g, '"')
              .replace(/\\\\/g, "\\")
          }
        } else {
          // Fallback: try to extract any quoted content
          const content = chunk.match(/"([^"]*)"/)
          if (content) {
            // Replace literal \n\n with actual newlines and clean up backslashed quotes
            accumulatedResponse += content[1]
              .replace(/\\n\\n/g, "\n\n")
              .replace(/\\"/g, '"')
              .replace(/\\\\/g, "\\")
          } else {
            // Replace literal \n\n with actual newlines and clean up backslashed quotes
            accumulatedResponse += chunk
              .replace(/\\n\\n/g, "\n\n")
              .replace(/\\"/g, '"')
              .replace(/\\\\/g, "\\")
          }
        }
      }
      onUpdate(accumulatedResponse)
    }

    return accumulatedResponse
  }

  return {
    messages,
    input,
    handleInputChange,
    handleSubmit,
    streamText,
  }
}

/*
  File: app/about/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/about/page.tsx
  Directory: app/about
*/

--- File: app/about/page.tsx ---

import { Heading } from "@/components/typography/heading"
export default function AboutPage() {
  return (
    <div className="container py-12">
      <div className="mx-auto max-w-4xl">
        <div className="mb-12 text-center">
          <Heading variant="h2" as="h1">
            About
          </Heading>
        </div>

        <div className="mb-8 space-y-6">
          <p>Replace this with your about page content...</p>
        </div>
      </div>
    </div>
  )
}


/*
  File: app/account/[[...rest]]/components/account-profile.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/account/[[...rest]]/components/account-profile.tsx
  Directory: app/account/[[...rest]]/components
*/

--- File: app/account/[[...rest]]/components/account-profile.tsx ---

"use client"

import { UserProfile, useUser } from "@clerk/nextjs"
import { BookText } from "lucide-react"
import { BioSection } from "./bio-section"

export function AccountProfile() {
  const { isLoaded, isSignedIn } = useUser()

  if (!isLoaded) {
    return null // or a loading spinner
  }

  if (!isSignedIn) {
    return null // we already handle this case in the parent
  }

  return (
    <UserProfile
      appearance={{
        elements: {
          rootBox: "mx-auto max-w-3xl",
          card: "shadow-none",
        },
      }}
      path="/account"
    >
      <UserProfile.Page label="Bio" url="bio" labelIcon={<BookText className="h-4 w-4" />}>
        <BioSection />
      </UserProfile.Page>
    </UserProfile>
  )
}


/*
  File: app/account/[[...rest]]/components/bio-section.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/account/[[...rest]]/components/bio-section.tsx
  Directory: app/account/[[...rest]]/components
*/

--- File: app/account/[[...rest]]/components/bio-section.tsx ---

"use client"

import { useUser } from "@clerk/nextjs"
import { useState } from "react"
import { Button } from "@/components/ui/button"
import { Textarea } from "@/components/ui/textarea"

export function BioSection() {
  const { user } = useUser()
  const [bio, setBio] = useState((user?.unsafeMetadata?.bio as string) || "")
  const [isSaving, setIsSaving] = useState(false)

  const saveBio = async () => {
    if (!user) return
    setIsSaving(true)
    try {
      await user.update({
        unsafeMetadata: {
          ...user.unsafeMetadata,
          bio,
        },
      })
    } catch (error) {
      console.error("Error saving bio:", error)
    }
    setIsSaving(false)
  }

  return (
    <div className="rounded-lg border p-4">
      <h2 className="text-lg font-semibold mb-4">Your Bio</h2>
      <Textarea placeholder="Tell us about yourself..." value={bio} onChange={(e) => setBio(e.target.value)} className="mb-4" rows={4} />
      <Button onClick={saveBio} disabled={isSaving}>
        {isSaving ? "Saving..." : "Save Bio"}
      </Button>
    </div>
  )
}


/*
  File: app/account/[[...rest]]/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/account/[[...rest]]/page.tsx
  Directory: app/account/[[...rest]]
*/

--- File: app/account/[[...rest]]/page.tsx ---

import { auth } from "@clerk/nextjs/server"
import { Container } from "@/components/ui/container"
import { Card, CardContent } from "@/components/ui/card"
import { SignInButton } from "@clerk/nextjs"
import { Button } from "@/components/ui/button"
import { AccountProfile } from "./components/account-profile"

export default async function AccountPage() {
  const { userId } = await auth()

  if (!userId) {
    return (
      <Container>
        <div className="py-16">
          <Card className="max-w-xl mx-auto">
            <CardContent className="flex flex-col items-center gap-6 py-16">
              <div className="text-center space-y-2">
                <h2 className="text-2xl font-semibold">Sign in to Access Your Account</h2>
                <p className="text-muted-foreground">Create an account or sign in to manage your profile</p>
              </div>
              <SignInButton mode="modal">
                <Button size="lg">Sign in to Continue</Button>
              </SignInButton>
            </CardContent>
          </Card>
        </div>
      </Container>
    )
  }

  return (
    <Container>
      <div className="py-16">
        <AccountProfile />
      </div>
    </Container>
  )
}


/*
  File: app/admin/mailing-list/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/admin/mailing-list/page.tsx
  Directory: app/admin/mailing-list
*/

--- File: app/admin/mailing-list/page.tsx ---

import { requireAdmin } from "@/lib/auth-utils"
import { AdminBreadcrumb } from "@/components/nav/admin-breadcrumb"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { MailingListSubscriberTable } from "@/components/admin/mailing-list/mailing-list-subscriber-table"
import { getMailingListSubscriptions } from "@/lib/services/mailing-list"
import { Doc } from "@/convex/_generated/dataModel"

type ConvexSubscription = Doc<"mailing_list_subscriptions">

function serializeForClient(subscriber: ConvexSubscription) {
  return {
    id: subscriber._id,
    userId: subscriber.userId,
    email: subscriber.email,
    name: subscriber.name ?? null,
    preferences: subscriber.preferences,
    subscribedAt: new Date(subscriber.subscribedAt).toISOString(),
    unsubscribedAt: subscriber.unsubscribedAt ? new Date(subscriber.unsubscribedAt).toISOString() : null,
    createdAt: new Date(subscriber.createdAt).toISOString(),
    updatedAt: new Date(subscriber.updatedAt).toISOString(),
  }
}

export default async function AdminMailingListPage() {
  // Check if the user is an admin
  await requireAdmin()

  // Fetch subscribers through the service layer
  const subscribers = await getMailingListSubscriptions()

  // Serialize the data for client components
  const serializedSubscribers = subscribers.map(serializeForClient)

  return (
    <div className="container py-8">
      <AdminBreadcrumb items={[{ label: "Mailing List" }]} />

      <div className="mb-8">
        <h1 className="text-4xl font-bold">Mailing List Subscribers</h1>
        <p className="text-muted-foreground">View and manage newsletter subscribers</p>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>All Subscribers</CardTitle>
        </CardHeader>
        <CardContent className="pb-6">
          <MailingListSubscriberTable subscribers={serializedSubscribers} />
        </CardContent>
      </Card>
    </div>
  )
}


/*
  File: app/admin/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/admin/page.tsx
  Directory: app/admin
*/

--- File: app/admin/page.tsx ---

import { Metadata } from "next"
import Link from "next/link"
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { requireAdmin } from "@/lib/auth-utils"
import { AdminConfigMessage } from "@/components/admin/admin-config-message"
import { DevEnvNotice } from "@/components/admin/dev-env-notice"
import { Heading } from "@/components/typography/heading"

export const metadata: Metadata = {
  title: "Admin Dashboard",
  description: "Vibecode.party Admin Dashboard",
}

export default async function AdminPage() {
  const { isAdmin, requiresSetup } = await requireAdmin()
  const isDev = process.env.NODE_ENV === "development"

  if (requiresSetup) {
    return (
      <div className="container max-w-2xl py-8 md:py-12">
        <AdminConfigMessage />
      </div>
    )
  }

  if (!isAdmin) {
    return (
      <div className="container py-8 md:py-12">
        <div className="mx-auto max-w-2xl text-center">
          <Heading variant="h1" className="mb-4">
            Access Denied
          </Heading>
          <p className="text-muted-foreground text-balance mb-8">You don&apos;t have permission to access this page. Please contact an administrator if you believe this is an error.</p>
          {isDev && <DevEnvNotice />}
        </div>
      </div>
    )
  }

  return (
    <div className="container py-8 md:py-12">
      <div className="mx-auto max-w-6xl">
        <Heading variant="h3" className="mb-8 text-center text-primary">
          Admin Dashboard
        </Heading>
        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          <Card>
            <CardHeader>
              <CardTitle>Users</CardTitle>
              <CardDescription>Manage user accounts</CardDescription>
            </CardHeader>
            <CardContent>
              <p className="text-sm text-muted-foreground">View user information and manage admin access.</p>
            </CardContent>
            <CardFooter>
              <Link href="/admin/users" className="w-full">
                <Button className="w-full">Manage Users</Button>
              </Link>
            </CardFooter>
          </Card>
          <Card>
            <CardHeader>
              <CardTitle>Mailing List</CardTitle>
              <CardDescription>Manage subscribers</CardDescription>
            </CardHeader>
            <CardContent>
              <p className="text-sm text-muted-foreground">View and manage newsletter subscribers and preferences.</p>
            </CardContent>
            <CardFooter>
              <Link href="/admin/mailing-list" className="w-full">
                <Button className="w-full">Manage Subscribers</Button>
              </Link>
            </CardFooter>
          </Card>
        </div>
      </div>
    </div>
  )
}


/*
  File: app/admin/users/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/admin/users/page.tsx
  Directory: app/admin/users
*/

--- File: app/admin/users/page.tsx ---

import { requireAdmin } from "@/lib/auth-utils"
import { AdminBreadcrumb } from "@/components/nav/admin-breadcrumb"
import { AdminUserList } from "@/components/admin/user-list"
import { clerkClient } from "@clerk/nextjs/server"
import type { User } from "@clerk/nextjs/server"

async function getInitialUsers() {
  const client = await clerkClient()
  const { data: users } = await client.users.getUserList()
  const adminUserIds = process.env.ADMIN_USER_IDS?.split(",") || []

  return users.map((user: User) => ({
    id: user.id,
    email: user.emailAddresses[0]?.emailAddress,
    username: user.username,
    firstName: user.firstName,
    lastName: user.lastName,
    imageUrl: user.imageUrl,
    createdAt: new Date(user.createdAt).toLocaleDateString(),
    isAdmin: adminUserIds.includes(user.id),
    banned: user.banned,
    publicMetadata: user.publicMetadata,
  }))
}

export default async function AdminUsersPage() {
  // Check if the user is an admin
  await requireAdmin()

  // Fetch initial users data
  const initialUsers = await getInitialUsers()

  return (
    <div className="container py-8">
      <AdminBreadcrumb items={[{ label: "Users" }]} />

      <div className="mb-8">
        <h1 className="text-4xl font-bold">Users</h1>
        <p className="text-muted-foreground">Manage and view user information</p>
      </div>

      <AdminUserList initialUsers={initialUsers} />
    </div>
  )
}


/*
  File: app/api/adventure/stream/[adventureId]/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/adventure/stream/[adventureId]/route.ts
  Directory: app/api/adventure/stream/[adventureId]
*/

--- File: app/api/adventure/stream/[adventureId]/route.ts ---

import { auth } from "@clerk/nextjs/server";
import { api } from "@/convex/_generated/api";
import type { Id } from "@/convex/_generated/dataModel";
import { ConvexClient } from "convex/browser";

export async function GET(
  _: Request,
  { params }: { params: Promise<{ adventureId: string }> }
) {
  const convex = new ConvexClient(process.env.CONVEX_URL!);
  const { adventureId } = await params;
  console.log("[SSE API] adventureId:", adventureId);
  const { userId } = await auth();
  if (!userId) {
    console.warn("[SSE API] Unauthorized access attempt");
    return new Response("Unauthorized", { status: 401 });
  }

  if (!adventureId || typeof adventureId !== "string" || adventureId.length < 10) {
    console.error("[SSE API] Invalid adventureId:", adventureId);
    return new Response("Invalid adventureId", { status: 400 });
  }

  let interval: NodeJS.Timeout;
  const stream = new ReadableStream({
    async start(controller) {
      let lastTurnId: string | null = null;
      let lastTurn: unknown = null;
      // Send initial data immediately
      try {
        const adventure = await convex.query(api.adventure.getAdventureById, { adventureId: adventureId as Id<"adventures"> });
        let turn = null;
        if (adventure && adventure.currentTurnId) {
          turn = await convex.query(api.adventure.getTurnById, { turnId: adventure.currentTurnId });
        }
        controller.enqueue(`data: ${JSON.stringify(turn)}\n\n`);
        lastTurnId = adventure?.currentTurnId ?? null;
        lastTurn = turn;
      } catch (err) {
        console.error("[SSE API] Error fetching initial adventure/turn:", err);
        controller.enqueue(`event: error\ndata: ${JSON.stringify({ error: 'Failed to fetch adventure/turn' })}\n\n`);
      }
      interval = setInterval(async () => {
        try {
          const adventure = await convex.query(api.adventure.getAdventureById, { adventureId: adventureId as Id<"adventures"> });
          let turn = null;
          if (adventure && adventure.currentTurnId) {
            turn = await convex.query(api.adventure.getTurnById, { turnId: adventure.currentTurnId });
          }
          if (adventure?.currentTurnId !== lastTurnId || JSON.stringify(turn) !== JSON.stringify(lastTurn)) {
            controller.enqueue(`data: ${JSON.stringify(turn)}\n\n`);
            lastTurnId = adventure?.currentTurnId ?? null;
            lastTurn = turn;
            console.log("[SSE API] Updated turn sent:", JSON.stringify(turn));
          }
        } catch (err) {
          console.error("[SSE API] Error fetching adventure/turn in interval:", err);
          controller.enqueue(`event: error\ndata: ${JSON.stringify({ error: 'Failed to fetch adventure/turn' })}\n\n`);
        }
      }, 2000);
    },
    cancel() {
      clearInterval(interval);
      console.log("[SSE API] Stream cancelled for adventureId:", adventureId);
    },
  });

  return new Response(stream, {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      Connection: "keep-alive",
    },
  });
} 

/*
  File: app/api/ai/_auth.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/ai/_auth.ts
  Directory: app/api/ai
*/

--- File: app/api/ai/_auth.ts ---

import { auth } from "@clerk/nextjs/server"
import { NextResponse } from "next/server"

export async function requireAuthMiddleware() {
  const { userId } = await auth()

  if (!userId) {
    return NextResponse.json(
      { error: "Authentication required" },
      { status: 401 }
    )
  }

  return null // Continue to route handler
} 

/*
  File: app/api/ai/generate/image/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/ai/generate/image/route.ts
  Directory: app/api/ai/generate/image
*/

--- File: app/api/ai/generate/image/route.ts ---

import { replicate } from '@ai-sdk/replicate';
import { experimental_generateImage as generateImage } from 'ai';
import { NextRequest } from 'next/server';
import { PutObjectCommand } from '@aws-sdk/client-s3';
import { s3Client, AWS_BUCKET_PUBLIC } from '@/lib/aws';
import { requireAuthMiddleware } from "../../_auth"

export async function POST(request: NextRequest) {
  // Check authentication
  const authError = await requireAuthMiddleware()
  if (authError) return authError

  try {
    const { input, userId, deckId, aspectRatio } = await request.json();
    const userFolder = userId || 'guest';

    // Check if placeholder images should be used
    if (process.env.NEXT_PUBLIC_USE_PLACEHOLDER_IMAGES === 'true') {
      return Response.json({
        imageUrl: 'https://placehold.co/600x900',
        success: true
      });
    }

    if (!s3Client) {
      return Response.json({ error: 'S3 client not initialized', success: false }, { status: 500 });
    }

    const { image } = await generateImage({
      model: replicate.image(process.env.REPLICATE_MODEL || "black-forest-labs/flux-schnell"),
      prompt: input,
      aspectRatio: aspectRatio || '1:1',
    });

    // Upload to S3
    const key = `decks/${userFolder}/${deckId}/${Date.now()}.webp`;
    await s3Client.send(
      new PutObjectCommand({
        Bucket: AWS_BUCKET_PUBLIC,
        Key: key,
        Body: image.uint8Array,
        ContentType: 'image/webp',
      })
    );

    // Return both the image and the S3 URL
    return Response.json({
      imageUrl: `https://${AWS_BUCKET_PUBLIC}.s3.${process.env.AWS_REGION || 'us-east-1'}.amazonaws.com/${key}`,
      success: true
    });
  } catch (error) {
    console.error('Error generating or uploading image:', error);
    return Response.json({ error: 'Failed to generate or upload image', success: false }, { status: 500 });
  }
}


/*
  File: app/api/ai/generate/object/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/ai/generate/object/route.ts
  Directory: app/api/ai/generate/object
*/

--- File: app/api/ai/generate/object/route.ts ---

import { streamObject } from "@/lib/ai/"
import { z } from "zod"
import { requireAuthMiddleware } from "../../_auth"

// Allow streaming responses up to 30 seconds
export const maxDuration = 30

// Helper function to get a readable schema description
// function describeSchema(schema: z.ZodTypeAny): any {
//   if (schema instanceof z.ZodObject) {
//     const shape: Record<string, any> = {}
//     for (const [key, value] of Object.entries(schema.shape)) {
//       shape[key] = describeSchema(value as z.ZodTypeAny)
//     }
//     return { type: "object", shape }
//   } else if (schema instanceof z.ZodArray) {
//     return { type: "array", items: describeSchema(schema.element) }
//   } else if (schema instanceof z.ZodString) {
//     return { type: "string" }
//   } else if (schema instanceof z.ZodNumber) {
//     return { type: "number" }
//   } else if (schema instanceof z.ZodBoolean) {
//     return { type: "boolean" }
//   }
//   return { type: "unknown" }
// }

// Define schema field type interface
interface SchemaField {
  type: "string" | "number" | "boolean" | "array" | "object"
  optional?: boolean
  items?: SchemaField
  properties?: Record<string, SchemaField>
}

// Define the schema for field definitions
const fieldSchema: z.ZodType<SchemaField> = z.object({
  type: z.enum(["string", "number", "boolean", "array", "object"]),
  optional: z.boolean().optional(),
  properties: z.record(z.lazy(() => fieldSchema)).optional(),
  items: z.lazy(() => fieldSchema).optional(),
})

// Define the schema for the request body
const requestSchema = z.object({
  schema: fieldSchema,
  prompt: z.string(),
})

function createZodSchema(shape: SchemaField | Record<string, SchemaField>): z.ZodTypeAny {
  // If it's a record of fields (root schema), create an object schema
  if (!("type" in shape)) {
    const schema: Record<string, z.ZodTypeAny> = {}
    for (const [key, def] of Object.entries(shape)) {
      schema[key] = createZodSchema(def)
    }
    return z.object(schema)
  }

  // Handle individual field schemas
  if (shape.type === "object" && shape.properties) {
    const schema: Record<string, z.ZodTypeAny> = {}
    for (const [key, def] of Object.entries(shape.properties)) {
      schema[key] = createZodSchema(def)
    }
    return z.object(schema)
  }

  let fieldSchema: z.ZodTypeAny

  switch (shape.type) {
    case "string":
      fieldSchema = z.string()
      break
    case "number":
      fieldSchema = z.number()
      break
    case "boolean":
      fieldSchema = z.boolean()
      break
    case "array":
      fieldSchema = z.array(shape.items ? createZodSchema(shape.items) : z.any())
      break
    default:
      fieldSchema = z.any()
  }

  if (shape.optional) {
    fieldSchema = fieldSchema.optional()
  }

  return fieldSchema
}

export async function POST(req: Request) {
  // Check authentication
  const authError = await requireAuthMiddleware()
  if (authError) return authError

  try {
    const body = await req.json()
    const { schema: schemaShape, prompt } = requestSchema.parse(body)

    // Create a new schema from the shape
    const schema = createZodSchema(schemaShape)
    
    const result = streamObject({
      schema,
      prompt,
    })
    
    return result.toTextStreamResponse()
  } catch (error) {
    console.error("Error in generate object route:", error)
    return new Response(JSON.stringify({ error: "Invalid request" }), { status: 400 })
  }
}


/*
  File: app/api/ai/generate/strings/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/ai/generate/strings/route.ts
  Directory: app/api/ai/generate/strings
*/

--- File: app/api/ai/generate/strings/route.ts ---

import { streamObject } from "@/lib/ai/"
import { z } from "zod"
import { requireAuthMiddleware } from "../../_auth"

// Allow streaming responses up to 30 seconds
export const maxDuration = 30

export async function POST(req: Request) {
  // Check authentication
  const authError = await requireAuthMiddleware()
  if (authError) return authError

  try {
    const body = await req.json()
    const { prompt, count = 6 } = body

    const result = streamObject({
      schema: z.object({
        strings: z.array(z.string()).describe("Array of generated strings based on the prompt"),
      }),
      prompt: `${prompt}\n\nGenerate exactly ${count} responses. Return them in a JSON object with a "strings" array property.`,
    })
    
    return result.toTextStreamResponse()
  } catch (error) {
    console.error("Error in generate strings route:", error)
    return new Response(JSON.stringify({ error: "Failed to generate strings" }), { status: 500 })
  }
}


/*
  File: app/api/ai/generate/text/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/ai/generate/text/route.ts
  Directory: app/api/ai/generate/text
*/

--- File: app/api/ai/generate/text/route.ts ---

import { generateText } from "@/lib/ai/"
import { NextRequest } from "next/server"
import { requireAuthMiddleware } from "../../_auth"

type Message = { content: string }

export async function POST(request: NextRequest) {
  // Check authentication
  const authError = await requireAuthMiddleware()
  if (authError) return authError

  const body = await request.json()

  const { input, messages, system } = body

  let prompt = input
  if (messages) {
    // If you want to support chat-style messages, concatenate them
    prompt = (messages as Message[]).map((m) => m.content).join("\n")
  }
  if (system) {
    prompt = `${system}\n${prompt}`
  }

  const result = await generateText({
    prompt,
  })

  // Return as JSON for backend use
  return Response.json({ result: result.text })
}


/*
  File: app/api/ai/get-encounter-context/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/ai/get-encounter-context/route.ts
  Directory: app/api/ai/get-encounter-context
*/

--- File: app/api/ai/get-encounter-context/route.ts ---

import { NextRequest, NextResponse } from "next/server";
import adventureData from "@/data/the-midnight-summons.json";

export async function POST(req: NextRequest) {
  const { encounterId } = await req.json();
  console.log("[get-encounter-context] Request for encounterId:", encounterId);
  // Traverse the adventure structure to find the encounter
  let found = null;
  for (const section of adventureData.sections) {
    for (const scene of section.scenes) {
      for (const encounter of scene.encounters) {
        if (encounter.id === encounterId) {
          found = encounter;
          break;
        }
      }
      if (found) break;
    }
    if (found) break;
  }
  if (!found) {
    console.log("[get-encounter-context] Encounter not found for id:", encounterId);
    return NextResponse.json({ error: "Not found" }, { status: 404 });
  }
  console.log("[get-encounter-context] Found encounter:", found.id);
  return NextResponse.json({
    intro: found.intro,
    instructions: found.instructions,
    transitions: found.transitions ?? [],
  });
} 

/*
  File: app/api/ai/get-roll-requirement/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/ai/get-roll-requirement/route.ts
  Directory: app/api/ai/get-roll-requirement
*/

--- File: app/api/ai/get-roll-requirement/route.ts ---

import { NextRequest } from "next/server";
import { getRollRequirement } from "@/app/_actions/get-roll-requirement";

export async function POST(req: NextRequest) {
  const { reply } = await req.json();
  const rollRequirement = await getRollRequirement(reply);
  return Response.json({ rollRequirement });
} 

/*
  File: app/api/check-admin/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/check-admin/route.ts
  Directory: app/api/check-admin
*/

--- File: app/api/check-admin/route.ts ---

import { NextResponse } from 'next/server';
import { auth } from '@clerk/nextjs/server';

export async function GET() {
  try {
    const { userId } = await auth();
    
    // If no user is authenticated, they're not an admin
    if (!userId) {
      return NextResponse.json({ isAdmin: false });
    }
    
    // Get the list of admin user IDs from environment variables
    const adminUserIds = process.env.ADMIN_USER_IDS?.split(",") || [];
    
    // Check if the current user's ID is in the admin list
    const isAdmin = adminUserIds.includes(userId);
    
    return NextResponse.json({ isAdmin });
  } catch (error) {
    console.error("Error checking admin status:", error);
    return NextResponse.json({ isAdmin: false }, { status: 500 });
  }
} 

/*
  File: app/api/convex-status/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/convex-status/route.ts
  Directory: app/api/convex-status
*/

--- File: app/api/convex-status/route.ts ---

import { NextResponse } from "next/server"

export async function GET() {
  try {
    // Check if Convex URL is configured
    const isConfigured = Boolean(process.env.NEXT_PUBLIC_CONVEX_URL)

    if (!isConfigured) {
      return NextResponse.json(
        {
          status: "not_configured",
          message: "Convex is not configured. Please set NEXT_PUBLIC_CONVEX_URL in your .env file.",
        },
        { status: 400 }
      )
    }

    return NextResponse.json(
      {
        status: "ready",
        message: "Convex is configured and ready to use.",
        url: process.env.NEXT_PUBLIC_CONVEX_URL,
      },
      { status: 200 }
    )
  } catch (error) {
    console.error("Error checking Convex status:", error)
    return NextResponse.json(
      {
        status: "error",
        message: "Failed to check Convex status",
        error: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    )
  }
} 

/*
  File: app/api/pay/intent/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/pay/intent/route.ts
  Directory: app/api/pay/intent
*/

--- File: app/api/pay/intent/route.ts ---

import { auth } from "@clerk/nextjs/server"
import { NextResponse } from "next/server"
import { stripe, isStripeConfigured } from "@/lib/stripe"

export async function POST(request: Request) {
  try {
    // Check if Stripe is configured
    if (!isStripeConfigured()) {
      return NextResponse.json(
        { error: "Payment system not configured" },
        { status: 503 }
      )
    }

    // Check authentication
    const authResult = await auth()
    if (!authResult.userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    const { amount } = await request.json()

    // We can safely use stripe here because we checked isStripeConfigured()
    const paymentIntent = await stripe!.paymentIntents.create({
      amount,
      currency: "usd",
      metadata: {
        userId: authResult.userId,
        type: "donation"
      }
    })

    return NextResponse.json({
      clientSecret: paymentIntent.client_secret,
    })
  } catch (error) {
    console.error("Error creating payment intent:", error)
    return NextResponse.json(
      { error: "Error creating payment intent" },
      { status: 500 }
    )
  }
} 

/*
  File: app/api/sendgrid/inbound/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/sendgrid/inbound/route.ts
  Directory: app/api/sendgrid/inbound
*/

--- File: app/api/sendgrid/inbound/route.ts ---

import { NextRequest, NextResponse } from "next/server"
import sgMail from "@sendgrid/mail"

export async function POST(request: NextRequest) {
  try {
    // Parse the multipart form data from SendGrid
    const formData = await request.formData()
    const from = formData.get("from") as string
    const subject = formData.get("subject") as string
    const text = formData.get("text") as string
    const html = formData.get("html") as string

    // Configure SendGrid
    sgMail.setApiKey(process.env.SENDGRID_API_KEY!)

    // Forward the email to the contact email
    const msg = {
      to: process.env.CONTACT_EMAIL!,
      from: process.env.SENDGRID_SENDER!,
      replyTo: from,
      subject: `[Forwarded] ${subject}`,
      text: `Original From: ${from}\n\n${text}`,
      html: `
        <p><strong>Original From:</strong> ${from}</p>
        <hr/>
        ${html}
      `,
    }

    await sgMail.send(msg)

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error("Error processing inbound email:", error)
    return NextResponse.json(
      { error: "Failed to process inbound email" },
      { status: 500 }
    )
  }
} 

/*
  File: app/api/upload/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/upload/route.ts
  Directory: app/api/upload
*/

--- File: app/api/upload/route.ts ---

import { NextRequest, NextResponse } from "next/server"
import { uploadFileToS3 } from "@/lib/s3-utils"
import { isAwsConfigured } from "@/lib/aws"
import { v4 as uuidv4 } from "uuid"
import { auth } from "@clerk/nextjs/server"

export async function POST(request: NextRequest) {
  try {
    // Check if AWS is configured
    if (!isAwsConfigured()) {
      return NextResponse.json(
        { error: "File upload system not configured" },
        { status: 503 }
      )
    }

    const { userId } = await auth()

    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    const formData = await request.formData()
    const file = formData.get("file") as File
    const folder = formData.get("folder") as string || "images"
    
    if (!file) {
      return NextResponse.json({ error: "No file provided" }, { status: 400 })
    }
    
    // Validate file type
    const allowedTypes = ["image/jpeg", "image/png", "image/webp", "image/gif", "image/svg+xml"]
    if (!allowedTypes.includes(file.type)) {
      return NextResponse.json({ error: "File type not allowed. Please upload an image (JPEG, PNG, WebP, SVG, or GIF)." }, { status: 400 })
    }
    
    // Validate file size (max 5MB)
    const maxSize = 5 * 1024 * 1024 // 5MB
    if (file.size > maxSize) {
      return NextResponse.json({ error: "File size exceeds 5MB limit" }, { status: 400 })
    }
    
    // Generate a unique filename
    const fileExtension = file.name.split(".").pop()
    const fileName = `${folder}/${uuidv4()}.${fileExtension}`
    
    // Upload to S3
    const fileUrl = await uploadFileToS3(file, fileName)
    
    return NextResponse.json({ url: fileUrl })
  } catch (error) {
    console.error("Error uploading file:", error)
    if (error instanceof Error && error.message === "AWS S3 is not configured") {
      return NextResponse.json(
        { error: "File upload system not configured" },
        { status: 503 }
      )
    }
    return NextResponse.json({ error: "Failed to upload file" }, { status: 500 })
  }
} 

/*
  File: app/contact/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/contact/page.tsx
  Directory: app/contact
*/

--- File: app/contact/page.tsx ---

import { Metadata } from "next"
import { ContactForm } from "@/components/contact/contact-form"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { ConfigCard } from "@/components/admin/config-card"
import { Heading } from "@/components/typography/heading"

export const metadata: Metadata = {
  title: "Contact Us",
  description: "Get in touch with us. We'd love to hear from you!",
}

async function checkEnvironmentVariables() {
  // Define required environment variables
  const requiredEnvVars = {
    NEXT_PUBLIC_RECAPTCHA_SITE_KEY: process.env.NEXT_PUBLIC_RECAPTCHA_SITE_KEY,
    RECAPTCHA_SECRET_KEY: process.env.RECAPTCHA_SECRET_KEY,
    SENDGRID_API_KEY: process.env.SENDGRID_API_KEY,
    SENDGRID_SENDER: process.env.SENDGRID_SENDER,
    CONTACT_EMAIL: process.env.CONTACT_EMAIL,
  } as const

  // Check which variables are missing
  const missingEnvVars = Object.entries(requiredEnvVars)
    .filter(([, value]) => !value)
    .map(([key]) => key)

  // Log missing variables in development
  if (process.env.NODE_ENV === "development" && missingEnvVars.length > 0) {
    console.warn("⚠️ Missing environment variables for contact form:")
    missingEnvVars.forEach((key) => {
      console.warn(`  - ${key}`)
    })
  }

  return {
    isConfigured: missingEnvVars.length === 0,
    missingVars: missingEnvVars,
  }
}

export default async function ContactPage() {
  const { isConfigured, missingVars } = await checkEnvironmentVariables()

  if (!isConfigured) {
    return (
      <div className="container max-w-2xl py-8 md:py-12">
        <ConfigCard
          title="Contact Form Setup Required"
          description="The contact form needs configuration before it can be used."
          configItems={[
            {
              key: "NEXT_PUBLIC_RECAPTCHA_SITE_KEY",
              description: "From Google ReCAPTCHA",
              isMissing: missingVars.includes("NEXT_PUBLIC_RECAPTCHA_SITE_KEY"),
            },
            {
              key: "RECAPTCHA_SECRET_KEY",
              description: "From Google ReCAPTCHA",
              isMissing: missingVars.includes("RECAPTCHA_SECRET_KEY"),
            },
            {
              key: "SENDGRID_API_KEY",
              description: "Your SendGrid API key",
              isMissing: missingVars.includes("SENDGRID_API_KEY"),
            },
            {
              key: "SENDGRID_SENDER",
              description: "Verified sender email in SendGrid",
              isMissing: missingVars.includes("SENDGRID_SENDER"),
            },
            {
              key: "CONTACT_EMAIL",
              description: "Where to receive contact messages",
              isMissing: missingVars.includes("CONTACT_EMAIL"),
            },
          ]}
          filesToRemove={[{ path: "app/contact/page.tsx" }, { path: "components/contact/contact-form.tsx" }, { path: "app/_actions/contact.ts" }]}
        />
      </div>
    )
  }

  return <ContactPageContent />
}

function ContactPageContent() {
  return (
    <div className="container max-w-2xl py-8 md:py-12">
      <Card>
        <CardHeader>
          <CardTitle>
            <Heading variant="h4">Contact Us</Heading>
          </CardTitle>
          <CardDescription>Have a question or want to get in touch? Fill out the form and we&apos;ll get back to you.</CardDescription>
        </CardHeader>
        <CardContent>
          <ContactForm requireCaptcha={true} />
        </CardContent>
      </Card>
      {process.env.NODE_ENV === "development" && (
        <div className="mt-8 text-sm text-muted-foreground">
          <p>
            Get your API keys from{" "}
            <a className="underline" href="http://www.google.com/recaptcha/admin" target="_blank" rel="noopener noreferrer">
              http://www.google.com/recaptcha/admin
            </a>
          </p>
        </div>
      )}
    </div>
  )
}


/*
  File: app/demo/ai/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/demo/ai/page.tsx
  Directory: app/demo/ai
*/

--- File: app/demo/ai/page.tsx ---

import { Heading } from "@/components/typography/heading"
import { ConfigCard } from "@/components/admin/config-card"
import { AIDemoClient } from "@/components/demo/ai-demo-client"
import { checkAuth } from "@/lib/auth-utils"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { SignInButton } from "@clerk/nextjs"
import { Button } from "@/components/ui/button"

export default async function AIDemo() {
  // Check authentication
  const { isAuthenticated } = await checkAuth()
  const hasAllEnvVars = true

  const isMissingReplicateToken = !process.env.REPLICATE_API_TOKEN

  return (
    <div className="container py-8 md:py-12">
      <div className="mx-auto flex max-w-[58rem] flex-col items-center space-y-4 text-center">
        <span className="inline-block rounded-full bg-primary/10 px-3 py-1 text-sm text-primary">AI SDK Integration</span>
        <Heading variant="h2" className="font-heading text-3xl leading-[1.1] sm:text-3xl md:text-6xl font-bold">
          AI <span className="text-primary">Demo</span>
        </Heading>
        <p className="max-w-[85%] leading-normal text-muted-foreground sm:text-lg sm:leading-7">Try out generating text, images and structured data with AI.</p>
      </div>

      <div className="mx-auto max-w-2xl mt-12">
        {!isAuthenticated ? (
          <Card>
            <CardHeader>
              <CardTitle>Sign in Required</CardTitle>
              <CardDescription>Please sign in to access the AI demo features.</CardDescription>
            </CardHeader>
            <CardContent className="flex justify-center">
              <SignInButton mode="modal">
                <Button size="lg">Sign in to Continue</Button>
              </SignInButton>
            </CardContent>
          </Card>
        ) : !hasAllEnvVars ? (
          <ConfigCard
            title="OpenAI Configuration Required"
            description="To enable AI text or structured data generation, you need to configure OpenAI API key."
            configItems={[]}
            filesToRemove={[
              { path: "api/ai/*", description: "AI API routes" },
              { path: "_hooks/*", description: "AI hooks" },
            ]}
            alternativeTitle="Remove AI Feature"
            alternativeDescription="If you don't plan to use AI features, you can remove these files:"
          />
        ) : (
          <AIDemoClient isMissingReplicateToken={isMissingReplicateToken} />
        )}
      </div>
    </div>
  )
}


/*
  File: app/demo/upload/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/demo/upload/page.tsx
  Directory: app/demo/upload
*/

--- File: app/demo/upload/page.tsx ---

import { Heading } from "@/components/typography/heading"
import { UploadDemoClient } from "@/components/demo/upload-demo-client"
import { ConfigCard } from "@/components/admin/config-card"

const requiredEnvVars = {
  AWS_KEY: "Your AWS access key ID for S3 access",
  AWS_SECRET: "Your AWS secret access key for S3 access",
  AWS_REGION: "The AWS region where your S3 bucket is located (e.g., us-east-1)",
  AWS_BUCKET_PUBLIC: "The name of your public S3 bucket for file uploads",
}

export default async function UploadDemo() {
  // Check for missing environment variables
  const missingEnvVars = Object.entries(requiredEnvVars).map(([key, description]) => ({
    key,
    description,
    isMissing: !process.env[key],
  }))

  const hasAllEnvVars = missingEnvVars.every((item) => !item.isMissing)

  return (
    <div className="container py-8 md:py-12">
      <div className="mx-auto flex max-w-[58rem] flex-col items-center space-y-4 text-center">
        <span className="inline-block rounded-full bg-primary/10 px-3 py-1 text-sm text-primary">Upload Demo</span>
        <Heading variant="h2" className="font-heading text-3xl leading-[1.1] sm:text-3xl md:text-6xl font-bold">
          File Upload <span className="text-primary">System</span>
        </Heading>
        <p className="max-w-[85%] leading-normal text-muted-foreground sm:text-lg sm:leading-7">Try out our drag-and-drop file upload system with AWS S3 integration and image optimization.</p>
      </div>

      <div className="mx-auto max-w-2xl mt-12">
        {!hasAllEnvVars ? (
          <ConfigCard
            title="AWS S3 Configuration Required"
            description="To enable file uploads, you need to configure AWS S3 credentials and settings."
            configItems={missingEnvVars}
            filesToRemove={[
              { path: "components/ui/image-upload.tsx", description: "Image upload component" },
              { path: "lib/s3-utils.ts", description: "S3 utility functions" },
            ]}
            alternativeTitle="Remove File Upload Feature"
            alternativeDescription="If you don't plan to use AWS S3 for file uploads, you can remove these files:"
          />
        ) : (
          <UploadDemoClient />
        )}
      </div>
    </div>
  )
}


/*
  File: app/globals.css
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/globals.css
  Directory: app
*/

--- File: app/globals.css ---

@import 'tailwindcss';
@plugin "@tailwindcss/typography";

@custom-variant dark (&:is(.dark *));

@theme {
  --color-border: hsl(var(--border));
  --color-input: hsl(var(--input));
  --color-ring: hsl(var(--ring));
  --color-background: hsl(var(--background));
  --color-foreground: hsl(var(--foreground));

  --color-primary: hsl(var(--primary));
  --color-primary-foreground: hsl(var(--primary-foreground));

  --color-secondary: hsl(var(--secondary));
  --color-secondary-foreground: hsl(var(--secondary-foreground));

  --color-destructive: hsl(var(--destructive));
  --color-destructive-foreground: hsl(var(--destructive-foreground));

  --color-muted: hsl(var(--muted));
  --color-muted-foreground: hsl(var(--muted-foreground));

  --color-accent: hsl(var(--accent));
  --color-accent-foreground: hsl(var(--accent-foreground));

  --color-popover: hsl(var(--popover));
  --color-popover-foreground: hsl(var(--popover-foreground));

  --color-card: hsl(var(--card));
  --color-card-foreground: hsl(var(--card-foreground));

  --color-sidebar: hsl(var(--sidebar));
  --color-sidebar-foreground: hsl(var(--sidebar-foreground));
  --color-sidebar-border: hsl(var(--sidebar-border));
  --color-sidebar-primary: hsl(var(--sidebar-primary));
  --color-sidebar-primary-foreground: hsl(var(--sidebar-primary-foreground));

  --radius-lg: var(--radius);
  --radius-md: calc(var(--radius) - 2px);
  --radius-sm: calc(var(--radius) - 4px);

  --animate-accordion-down: accordion-down 0.2s ease-out;
  --animate-accordion-up: accordion-up 0.2s ease-out;
  --animate-float: float 15s ease-in-out infinite;

  --font-body: ['var(--font-rethink-sans)'];
  --font-sans: ['var(--font-rethink-sans)'];
  --font-display: ['var(--font-display)'];
  --font-mono: ['var(--font-mono)'];
  --font-serif: ['var(--font-serif)'];

  --text-xxxs: 0.5rem;
  --text-xxs: 0.625rem;

  --color-primary-50: #CBC8E5;
  --color-primary-100: #BEBADE;
  --color-primary-200: #A49ED1;
  --color-primary-300: #8A83C4;
  --color-primary-400: #7067B7;
  --color-primary-500: #594FA6;
  --color-primary-600: #453D80;
  --color-primary-700: #302B5A;
  --color-primary-800: #1C1934;
  --color-primary-900: #07070E;
  --color-primary-950: #000000;

  @keyframes accordion-down {
    from {
      height: 0;
    }
    to {
      height: var(--radix-accordion-content-height);
    }
  }
  @keyframes accordion-up {
    from {
      height: var(--radix-accordion-content-height);
    }
    to {
      height: 0;
    }
  }
  @keyframes float {
    0%,
    100% {
      transform: translateY(0);
    }
    50% {
      transform: translateY(-20px);
    }
  }
}

@utility container {
  margin-inline: auto;
  padding-inline: 1rem;
  @media (width >= --theme(--breakpoint-sm)) {
    max-width: none;
  }
  @media (width >= 1400px) {
    max-width: 1400px;
  }
}

/*
  The default border color has changed to `currentColor` in Tailwind CSS v4,
  so we've added these compatibility styles to make sure everything still
  looks the same as it did with Tailwind CSS v3.

  If we ever want to remove these styles, we need to add an explicit border
  color utility to any element that depends on these defaults.
*/
@layer base {
  *,
  ::after,
  ::before,
  ::backdrop,
  ::file-selector-button {
    border-color: var(--color-gray-200, currentColor);
  }
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 240 10% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 240 10% 3.9%;
    --primary: 246 80% 60%;
    --primary-foreground: 0 0% 98%;
    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;
    --muted: 240 4.8% 95.9%;
    --muted-foreground: 240 3.8% 46.1%;
    --accent: 240 4.8% 95.9%;
    --accent-foreground: 240 5.9% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 5.9% 90%;
    --input: 240 5.9% 90%;
    --ring: 246 80% 60%;
    --radius: 0.5rem;
    --sidebar: 0 0% 100%;
    --sidebar-foreground: 240 10% 3.9%;
    --sidebar-border: 240 5.9% 90%;
    --sidebar-primary: 246 80% 60%;
    --sidebar-primary-foreground: 0 0% 98%;
  }

  .dark {
    --background: 240 10% 3.9%;
    --foreground: 0 0% 98%;
    --card: 240 10% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 240 10% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 246 100% 70%;
    --primary-foreground: 0 0% 98%;
    --secondary: 240 3.7% 15.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 240 3.7% 15.9%;
    --muted-foreground: 240 5% 64.9%;
    --accent: 240 3.7% 15.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 3.7% 15.9%;
    --input: 240 3.7% 15.9%;
    --ring: 246 80% 60%;
    --sidebar: 240 10% 3.9%;
    --sidebar-foreground: 0 0% 98%;
    --sidebar-border: 240 3.7% 15.9%;
    --sidebar-primary: 246 80% 60%;
    --sidebar-primary-foreground: 0 0% 98%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

html {
  font-size: 18px;
}

html,
body {
  overscroll-behavior: none;
}

div,
p,
textarea {
  text-wrap: pretty;
}

button {
  cursor: pointer;
}

.fade-in {
  @apply opacity-100 transition-opacity duration-1000 ease-in-out;
  @starting-style {
    opacity: 0;
  }
}


/*
  File: app/layout.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/layout.tsx
  Directory: app
*/

--- File: app/layout.tsx ---

import Link from "next/link"
import type { Metadata } from "next"
import { Rethink_Sans, Cinzel_Decorative, Syne_Mono } from "next/font/google"
import { ThemeProvider } from "@/components/layout/theme-provider"
import { cn } from "@/lib/utils"
import { Toaster } from "sonner"
import { headers } from "next/headers"
import { trackVisit } from "@/app/_actions/track-visit"
import { siteConfig } from "@/lib/config"
import "./globals.css"
import { Providers } from "./providers"
import Header from "@/components/layout/header"

const rethinkSans = Rethink_Sans({
  subsets: ["latin"],
  variable: "--font-rethink-sans",
})

const cinzel = Cinzel_Decorative({
  subsets: ["latin"],
  variable: "--font-display",
  display: "swap",
  weight: "400",
})

const syne = Syne_Mono({
  subsets: ["latin"],
  variable: "--font-mono",
  display: "swap",
  weight: "400",
})

export const metadata: Metadata = {
  title: siteConfig.title,
  description: siteConfig.description,
  icons: {
    icon: "/images/favicon.svg",
  },
  openGraph: {
    title: siteConfig.title,
    description: siteConfig.description,
    images: [
      {
        url: siteConfig.shareImage,
        width: 1200,
        height: 630,
        alt: `${siteConfig.title} screenshot`,
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: siteConfig.title,
    description: siteConfig.description,
    images: [siteConfig.shareImage],
  },
}

export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode
}>) {
  // Track the visit
  const headersList = await headers()
  const path = headersList.get("x-pathname") || "/"
  await trackVisit(path)

  const currentYear = new Date().getFullYear()

  return (
    <html lang="en" suppressHydrationWarning className={`${rethinkSans.variable} ${cinzel.variable} ${syne.variable}`}>
      <body className={cn("min-h-screen bg-black text-white font-serif antialiased")}>
        <Providers>
          <ThemeProvider attribute="class" defaultTheme="system" enableSystem disableTransitionOnChange>
            <div className="relative flex min-h-screen flex-col">
              <Header path={path} />
              <main className="flex-1">{children}</main>
              <footer className="border-t border-white/20 py-6">
                <div className="container px-4 md:px-6">
                  <div className="flex flex-col md:flex-row justify-between items-center gap-4 text-center md:text-left text-sm">
                    <p>
                      © {currentYear} {siteConfig.title}. All rights reserved.
                    </p>
                    <nav className="flex gap-4">
                      <Link href="/terms" className="hover:underline underline-offset-4">
                        Terms
                      </Link>
                      <Link href="/privacy" className="hover:underline underline-offset-4">
                        Privacy
                      </Link>
                      <Link href="#" className="hover:underline underline-offset-4">
                        Contact
                      </Link>
                    </nav>
                  </div>
                </div>
              </footer>
            </div>
            <Toaster position="top-center" />
          </ThemeProvider>
        </Providers>
      </body>
    </html>
  )
}


/*
  File: app/mailing-list/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/mailing-list/page.tsx
  Directory: app/mailing-list
*/

--- File: app/mailing-list/page.tsx ---

import { MailingListForm } from "@/components/forms/mailing-list-form"
import { Heading } from "@/components/typography/heading"
import { getSubscription, unsubscribe } from "@/app/_actions/mailing-list"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { ConfigCard } from "@/components/admin/config-card"

async function handleLeaveWaitlist() {
  "use server"
  const result = await getSubscription()
  const subscription = result.success ? result.data : null
  if (!subscription?.email) return
  await unsubscribe(subscription.email) // Internally, unsubscribe still correctly removes them
}

export default async function WaitlistPage() {
  // Check if required environment variables are configured
  const missingEnvVars = [
    {
      key: "SENDGRID_API_KEY",
      description: "Your SendGrid API key (for waitlist notifications)",
      isMissing: !process.env.SENDGRID_API_KEY,
    },
  ].filter((item) => item.isMissing)

  if (missingEnvVars.length > 0) {
    return (
      <div className="container max-w-2xl py-8 md:py-12">
        <ConfigCard title="Waitlist Setup Required" description="The waitlist feature needs configuration before it can be used for notifications." configItems={missingEnvVars} />
      </div>
    )
  }

  const result = await getSubscription()
  const subscription = result.success ? result.data : null

  return (
    <div className="container relative">
      <div className="mx-auto flex max-w-[980px] flex-col items-center gap-8 py-8 md:py-12">
        <Heading variant="h2" className="text-center leading-tight">
          {subscription ? (
            <>
              {subscription.unsubscribedAt ? (
                <>
                  You&apos;ve left the <span className="text-primary">Waitlist.</span>
                </>
              ) : (
                <>
                  You&apos;re on the <span className="text-primary">Waitlist!</span>
                </>
              )}
            </>
          ) : (
            <>
              Join the <span className="text-primary">Waitlist</span>
            </>
          )}
        </Heading>

        {subscription ? (
          <Card className="w-full max-w-[500px] p-4 md:p-8 md:mt-4">
            <CardHeader className="md:pt-4">
              <CardTitle>Waitlist Status</CardTitle>
            </CardHeader>
            <CardContent className="md:pb-4">
              {subscription.unsubscribedAt ? (
                <div className="space-y-4">
                  <p>You previously joined the waitlist with {subscription.email}, but have since left. You can rejoin below.</p>
                  <MailingListForm initialEmail={subscription.email} />
                </div>
              ) : (
                <div className="space-y-4">
                  <p>You&apos;re on the waitlist with {subscription.email}. We&apos;ll notify you when access is available!</p>
                  <form action={handleLeaveWaitlist}>
                    <Button variant="destructive" type="submit">
                      Leave Waitlist
                    </Button>
                  </form>
                </div>
              )}
            </CardContent>
          </Card>
        ) : (
          <MailingListForm />
        )}
      </div>
    </div>
  )
}


/*
  File: app/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/page.tsx
  Directory: app
*/

--- File: app/page.tsx ---

import { textShadowSpread } from "@/components/typography/styles"
import Image from "next/image"
import { Button } from "@/components/ui/button"
import Link from "next/link"

export default async function HomePage() {
  const isProduction = process.env.NODE_ENV === "production"

  return (
    <div className="flex min-h-[max(100vh,100vw)] lg:min-h-screen flex-col relative">
      <h2 className="text-4xl sm:text-6xl font-display text-center w-full mt-20 sm:mt-36 fade-in delay-[2s] relative z-10" style={textShadowSpread}>
        <span className="block sm:inline">EXpeRienCe</span> <span className="inline-block scale-75 sm:scale-90 -mx-2 sm:mx-0">tHe</span> Thrill
      </h2>
      <div className="flex flex-col items-center justify-center absolute bottom-[6vh] sm:bottom-[10vh] w-full flex justify-center z-10">
        <h2 className="text-lg sm:text-2xl font-bold font-display text-center w-full fade-in delay-[2200ms] relative z-10" style={textShadowSpread}>
          Of tHe
        </h2>
        <h2 className="text-6xl sm:text-9xl font-display text-center w-full fade-in delay-[2400ms] relative z-10 -mt-1 sm:-mt-4 mb-2 sm:mb-0" style={textShadowSpread}>
          D20
        </h2>
        {isProduction ? (
          <div className="fade-in delay-[2600ms] flex flex-col sm:flex-row gap-2 sm:gap-8 items-center">
            <a href="https://discord.gg/5kEA9Tk4hG" target="_blank" rel="noopener noreferrer" className="fade-in delay-[2600ms]">
              <Button variant="epic" size="lg" className="mt-2 relative z-10">
                Go To Discord
              </Button>
            </a>
            <Link href="/mailing-list">
              <Button variant="epic" size="lg" className="mt-2 relative z-10">
                Join Waitlist
              </Button>
            </Link>
          </div>
        ) : (
          <Link className="fade-in delay-[2600ms]" href="/realm-of-myr/the-midnight-summons">
            <Button asChild variant="epic" size="lg" className="mt-2 relative z-10">
              Quick Start
            </Button>
          </Link>
        )}
      </div>
      <Image className="object-cover fade-in" fill={true} src="/images/app/backgrounds/d20-hero.png" alt="D20" />
    </div>
  )
}


/*
  File: app/pay/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/pay/page.tsx
  Directory: app/pay
*/

--- File: app/pay/page.tsx ---

"use client"

import { useState } from "react"
import { Card } from "@/components/ui/card"
import { Heading } from "@/components/typography/heading"
import { SignInButton, useUser } from "@clerk/nextjs"
import { Button } from "@/components/ui/button"
import { LogIn, Coffee } from "lucide-react"
import { StripePaymentForm } from "@/components/checkout/stripe-payment-form"

export default function DonatePage() {
  const { isSignedIn, isLoaded, user } = useUser()
  const [clientSecret, setClientSecret] = useState<string>("")
  const [isLoading, setIsLoading] = useState(false)
  const [showSuccess, setShowSuccess] = useState(false)

  const handleDonate = async () => {
    try {
      setIsLoading(true)
      const response = await fetch("/api/pay/intent", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          amount: 500, // $5.00
        }),
      })
      const data = await response.json()
      setClientSecret(data.clientSecret)
    } catch (error) {
      console.error("Error creating payment intent:", error)
    } finally {
      setIsLoading(false)
    }
  }

  const handleSuccess = () => {
    setShowSuccess(true)
    setClientSecret("")
  }

  if (!isLoaded) {
    return null
  }

  return (
    <div className="container py-8 md:py-12">
      <div className="mx-auto flex max-w-[58rem] flex-col items-center space-y-4 text-center">
        <span className="inline-block rounded-full bg-primary/10 px-3 py-1 text-sm text-primary">Support the Project</span>
        <Heading variant="h2" className="font-heading text-3xl leading-[1.1] sm:text-3xl md:text-6xl font-bold">
          Buy me a <span className="text-primary">Coffee</span>
        </Heading>
        <p className="max-w-[85%] leading-normal text-muted-foreground sm:text-lg sm:leading-7">If you find this project helpful, consider supporting its development with a small donation.</p>
      </div>

      <div className="mx-auto max-w-md mt-12">
        <Card className="p-6">
          {!isSignedIn ? (
            <div className="py-12 text-center space-y-4">
              <div className="flex justify-center mb-4">
                <div className="p-3 rounded-full bg-primary/10">
                  <LogIn className="w-6 h-6 text-primary" />
                </div>
              </div>
              <h3 className="text-lg font-medium">Sign in to Donate</h3>
              <p className="text-sm text-muted-foreground mb-6">You need to be signed in to make a donation.</p>
              <SignInButton mode="modal">
                <Button size="lg">Sign in to Continue</Button>
              </SignInButton>
            </div>
          ) : showSuccess ? (
            <div className="py-12 text-center space-y-4">
              <div className="flex justify-center mb-4">
                <div className="p-3 rounded-full bg-green-500/10">
                  <Coffee className="w-6 h-6 text-green-500" />
                </div>
              </div>
              <h3 className="text-lg font-medium">Thank You!</h3>
              <p className="text-sm text-muted-foreground text-balance">Your support is greatly appreciated. Thank you for your donation!</p>
            </div>
          ) : clientSecret ? (
            <div className="space-y-6">
              <StripePaymentForm clientSecret={clientSecret} quantity={1} userId={user.id} onSuccess={handleSuccess} discountCode="" />
            </div>
          ) : (
            <div className="space-y-6">
              <div className="flex justify-center mb-8">
                <div className="p-4 rounded-full bg-primary/10">
                  <Coffee className="w-8 h-8 text-primary" />
                </div>
              </div>
              <div className="text-center space-y-2 mb-6">
                <h3 className="text-lg font-medium">Buy me a coffee</h3>
                <p className="text-sm text-muted-foreground">Support this project with a $5 donation</p>
              </div>
              <Button onClick={handleDonate} disabled={isLoading} className="w-full" size="lg">
                {isLoading ? "Loading..." : "Donate $5"}
              </Button>
            </div>
          )}
        </Card>
      </div>
    </div>
  )
}


/*
  File: app/privacy/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/privacy/page.tsx
  Directory: app/privacy
*/

--- File: app/privacy/page.tsx ---

import { Heading } from "@/components/typography/heading"

export default function PrivacyPage() {
  return (
    <div className="container py-12">
      <div className="mx-auto max-w-4xl">
        <div className="mb-12 text-center">
          <Heading variant="h1" className="mb-8">
            Privacy Policy
          </Heading>
        </div>

        <p className="text-gray-700 mb-6">Put your privacy policy here.</p>
      </div>
    </div>
  )
}


/*
  File: app/providers.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/providers.tsx
  Directory: app
*/

--- File: app/providers.tsx ---

"use client"

import { ClerkProvider } from "@clerk/nextjs"
import { ConvexProvider, ConvexReactClient } from "convex/react"
import { PropsWithChildren } from "react"
import { dark } from "@clerk/themes"
import { TokenProvider } from "@/lib/context/TokenContext"

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!)

export function Providers({ children }: PropsWithChildren) {
  return (
    <ClerkProvider
      appearance={{
        baseTheme: dark,
        variables: {
          fontFamily: "var(--font-rethink-sans)",
          colorBackground: "#1C1934",
        },
      }}
      afterSignOutUrl="/"
    >
      <ConvexProvider client={convex}>
        <TokenProvider>{children}</TokenProvider>
      </ConvexProvider>
    </ClerkProvider>
  )
}


/*
  File: app/roadmap/data/featureRequests.json
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/roadmap/data/featureRequests.json
  Directory: app/roadmap/data
*/

--- File: app/roadmap/data/featureRequests.json ---

[]


/*
  File: app/roadmap/data/features.json
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/roadmap/data/features.json
  Directory: app/roadmap/data
*/

--- File: app/roadmap/data/features.json ---

[
  {
    "id": "1",
    "title": "Feature Roadmap",
    "votes": 42,
    "status": "completed",
    "description": "Add a feature roadmap page"
  },
  {
    "id": "3",
    "title": "API integration",
    "votes": 28,
    "status": "planned",
    "description": "Support for third-party API integrations"
  },
  {
    "id": "4",
    "title": "User authentication",
    "votes": 24,
    "status": "completed",
    "description": "Secure login and authentication system"
  },
  {
    "id": "5",
    "title": "Better analytics",
    "votes": 18,
    "status": "planned",
    "description": "Improve the analytics dashboard to provide more insights"
  },
  {
    "id": "6",
    "title": "Mailing List",
    "votes": 15,
    "status": "completed",
    "description": "Allow users to create and manage mailing lists"
  },
  {
    "id": "7",
    "title": "Switch to Convex",
    "votes": 32,
    "status": "completed",
    "description": "Switch to Convex for better DX and support for more projects on the free tier"
  },
  {
    "id": "8",
    "title": "Realtime updates",
    "votes": 19,
    "status": "backlog",
    "description": "Integrate with realtime service"
  },
  {
    "id": "9",
    "title": "Custom themes",
    "votes": 22,
    "status": "backlog",
    "description": "Allow users to more easily customize the application theme"
  },
  {
    "id": "10",
    "title": "Better documentation",
    "votes": 12,
    "status": "in-progress",
    "description": "Improve the documentation getting started quickly on new projects"
  }
]


/*
  File: app/roadmap/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/roadmap/page.tsx
  Directory: app/roadmap
*/

--- File: app/roadmap/page.tsx ---

import { RoadmapView, type Feature, type FeatureRequest } from "@/components/admin/roadmap-view"
import initialFeatures from "./data/features.json"
import initialRequests from "./data/featureRequests.json"

export default function RoadmapPage() {
  const features = initialFeatures as Feature[]
  const featureRequests = initialRequests as FeatureRequest[]

  return <RoadmapView features={features} featureRequests={featureRequests} />
}


/*
  File: app/terms/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/terms/page.tsx
  Directory: app/terms
*/

--- File: app/terms/page.tsx ---

import { Heading } from "@/components/typography/heading"

export default function TermsPage() {
  return (
    <div className="container py-12">
      <div className="mx-auto max-w-4xl">
        <div className="mb-12 text-center">
          <Heading variant="h1" className="mb-8">
            Terms of Service
          </Heading>
        </div>

        <p className="text-gray-700 mb-6">Put your terms of service here.</p>
      </div>
    </div>
  )
}


/*
  File: app/unsubscribe/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/unsubscribe/page.tsx
  Directory: app/unsubscribe
*/

--- File: app/unsubscribe/page.tsx ---

import { Heading } from "@/components/typography/heading"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import UnsubscribeForm from "./unsubscribe-form"

export default function UnsubscribePage() {
  return (
    <div className="container max-w-md py-12 flex flex-col items-center justify-center min-h-[60vh]">
      <Card className="w-full">
        <CardHeader>
          <CardTitle>
            <Heading variant="h2" className="text-center">
              Unsubscribe from Mailing List
            </Heading>
          </CardTitle>
        </CardHeader>
        <CardContent>
          <UnsubscribeForm />
        </CardContent>
      </Card>
    </div>
  )
}


/*
  File: app/unsubscribe/unsubscribe-form.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/unsubscribe/unsubscribe-form.tsx
  Directory: app/unsubscribe
*/

--- File: app/unsubscribe/unsubscribe-form.tsx ---

"use client"

import { useState } from "react"
import { unsubscribe } from "@/app/_actions/mailing-list"
import { Button } from "@/components/ui/button"

export default function UnsubscribeForm() {
  const [email, setEmail] = useState("")
  const [status, setStatus] = useState<"idle" | "success" | "error">("idle")
  const [error, setError] = useState<string | null>(null)

  async function handleUnsubscribe(e: React.FormEvent) {
    e.preventDefault()
    setStatus("idle")
    setError(null)
    try {
      const result = await unsubscribe(email)
      if (result.success) {
        setStatus("success")
      } else {
        setStatus("error")
        setError(result.error || "Could not unsubscribe. Please check your email.")
      }
    } catch (err: unknown) {
      setStatus("error")
      setError(err instanceof Error ? err.message : "Could not unsubscribe. Please try again.")
    }
  }

  return (
    <>
      {status === "success" ? (
        <div className="text-center text-green-600 font-semibold py-6">You have been unsubscribed from our mailing list.</div>
      ) : (
        <form onSubmit={handleUnsubscribe} className="space-y-6">
          <div>
            <label htmlFor="email" className="block mb-2 font-medium">
              Email address
            </label>
            <input id="email" type="email" className="w-full border rounded px-3 py-2" value={email} onChange={(e) => setEmail(e.target.value)} required autoFocus />
          </div>
          <Button type="submit" className="w-full" size="lg" variant="destructive">
            Unsubscribe
          </Button>
          {status === "error" && <div className="text-red-600 text-sm text-center mt-2">{error}</div>}
        </form>
      )}
    </>
  )
}


/*
  File: components/admin/admin-config-message.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/admin/admin-config-message.tsx
  Directory: components/admin
*/

--- File: components/admin/admin-config-message.tsx ---

"use client"

import { Card } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { useUser } from "@clerk/nextjs"
import { Copy, ShieldUser } from "lucide-react"
import { toast } from "sonner"

export function AdminConfigMessage() {
  const { user } = useUser()

  const handleCopyId = () => {
    if (user?.id) {
      navigator.clipboard.writeText(user.id)
      toast.success("User ID copied to clipboard!")
    }
  }

  return (
    <Card className="p-6">
      <div className="space-y-4">
        <div className="flex justify-center mb-4">
          <div className="p-2 rounded-full bg-amber-500/10">
            <ShieldUser className="w-8 h-8 text-amber-600" />
          </div>
        </div>
        <h3 className="text-lg font-medium text-center">Configure Admin Access</h3>
        <p className="text-sm text-muted-foreground text-center text-balance">
          To access admin features, you need to add your Clerk User ID to the <code className="px-1.5 py-0.5 rounded-md bg-muted">ADMIN_USER_IDS</code> environment variable.
        </p>
        <div className="p-4 rounded-lg bg-muted space-y-4">
          <div className="space-y-2">
            <p className="text-sm font-medium">Your Clerk User ID:</p>
            <div className="flex items-center gap-2">
              <code className="flex-1 px-3 py-2 rounded bg-background">{user?.id || "Not signed in"}</code>
              <Button size="icon" variant="outline" onClick={handleCopyId} disabled={!user?.id}>
                <Copy className="h-4 w-4" />
              </Button>
            </div>
          </div>
          <div className="space-y-2">
            <p className="text-sm font-medium">Add to your .env file:</p>
            <code className="block px-3 py-2 rounded bg-background text-sm">ADMIN_USER_IDS={user?.id || "your_user_id"}</code>
          </div>
        </div>
        <p className="text-xs text-muted-foreground text-center">After updating your .env file, restart your development server for changes to take effect.</p>
      </div>
    </Card>
  )
}


/*
  File: components/admin/config-card.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/admin/config-card.tsx
  Directory: components/admin
*/

--- File: components/admin/config-card.tsx ---

import { AlertCircle, CheckCircle, XCircle } from "lucide-react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"

interface ConfigItem {
  key: string
  description: string
  isMissing?: boolean
}

interface FileToRemove {
  path: string
  description?: string
}

interface ConfigCardProps {
  title: string
  description: string
  configItems: ConfigItem[]
  filesToRemove?: FileToRemove[]
  alternativeTitle?: string
  alternativeDescription?: string
}

export function ConfigCard({
  title,
  description,
  configItems,
  filesToRemove,
  alternativeTitle = "Alternative option",
  alternativeDescription = "If you don't plan to use this feature, you can remove the following files:",
}: ConfigCardProps) {
  return (
    <Card className="w-full max-w-3xl mx-auto">
      <CardHeader>
        <CardTitle className="text-xl text-primary">{title}</CardTitle>
        <CardDescription className="text-primary/80">{description}</CardDescription>
      </CardHeader>
      <CardContent className="space-y-6">
        <div className="space-y-2">
          <p className="text-sm text-muted-foreground">
            To enable this functionality, you need to configure the following environment variables in your <code className="bg-muted px-1 py-0.5 rounded text-sm font-mono">.env</code> file:
          </p>

          <div className="space-y-3 mt-4">
            {configItems.map((item) => (
              <div key={item.key} className="grid grid-cols-2 gap-2 items-start">
                <div className="flex items-center gap-2">
                  {item.isMissing ? <XCircle className="h-4 w-4 text-destructive" /> : <CheckCircle className="h-4 w-4 text-green-500" />}
                  <code className={`font-semibold py-1 rounded text-xs font-mono ${item.isMissing ? "text-destructive" : "text-green-500"}`}>{item.key}</code>
                </div>
                <p className="text-sm">{item.description}</p>
              </div>
            ))}
          </div>
        </div>

        {filesToRemove && filesToRemove.length > 0 && (
          <Alert className="border-primary/20 bg-primary/5">
            <AlertCircle className="h-4 w-4 text-primary" />
            <AlertTitle className="text-primary">{alternativeTitle}</AlertTitle>
            <AlertDescription className="text-primary/80">
              {alternativeDescription}
              <ul className="list-disc pl-5 mt-2 space-y-1">
                {filesToRemove.map((file) => (
                  <li key={file.path} className="text-sm">
                    <code className="bg-muted px-1 py-0.5 rounded text-xs font-mono">{file.path}</code>
                    {file.description && <span className="text-primary/70 ml-2">- {file.description}</span>}
                  </li>
                ))}
              </ul>
            </AlertDescription>
          </Alert>
        )}
      </CardContent>
    </Card>
  )
}


/*
  File: components/admin/dev-env-notice.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/admin/dev-env-notice.tsx
  Directory: components/admin
*/

--- File: components/admin/dev-env-notice.tsx ---

import { Card, CardContent } from "@/components/ui/card"
import { Heading } from "../typography/heading"

export function DevEnvNotice() {
  return (
    <Card className="mb-8 bg-blue-500/5 border-blue-500/20">
      <CardContent>
        <div className="flex items-start gap-4">
          <div className="space-y-4 text-balance">
            <Heading variant="h5" className="font-medium">
              Development Environment
            </Heading>
            <p className="text-sm text-muted-foreground">
              You are running this application in a local development environment. The <code className="px-1.5 py-0.5 rounded-md bg-muted">ADMIN_USER_IDS</code> environment variable is currently set
              to:
            </p>
            <div className="mt-2">
              <code className="block w-full px-3 py-2 text-sm bg-muted rounded-md">{process.env.ADMIN_USER_IDS || "Not configured"}</code>
            </div>
            <p className="text-sm text-muted-foreground mt-2">
              To add more admin users, update this variable in your <code className="px-1 py-0.5 rounded-md bg-muted">.env</code> file with a comma-separated list of Clerk user IDs.
            </p>
          </div>
        </div>
      </CardContent>
    </Card>
  )
}


/*
  File: components/admin/mailing-list/mailing-list-subscriber-table.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/admin/mailing-list/mailing-list-subscriber-table.tsx
  Directory: components/admin/mailing-list
*/

--- File: components/admin/mailing-list/mailing-list-subscriber-table.tsx ---

"use client"

import { Badge } from "@/components/ui/badge"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Id } from "@/convex/_generated/dataModel"
import { formatDate } from "@/lib/utils"

type Subscriber = {
  id: Id<"mailing_list_subscriptions">
  userId: string
  email: string
  name: string | null
  preferences: {
    marketing: boolean
    updates: boolean
  }
  subscribedAt: string
  unsubscribedAt: string | null
  createdAt: string
  updatedAt: string
}

interface MailingListSubscriberTableProps {
  subscribers: Subscriber[]
}

export function MailingListSubscriberTable({ subscribers }: MailingListSubscriberTableProps) {
  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>Email</TableHead>
          <TableHead>Name</TableHead>
          <TableHead>Subscribed</TableHead>
          <TableHead>Status</TableHead>
          <TableHead>Preferences</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {subscribers.map((subscriber) => {
          return (
            <TableRow key={subscriber.id}>
              <TableCell>{subscriber.email}</TableCell>
              <TableCell>{subscriber.name || "-"}</TableCell>
              <TableCell>{formatDate(subscriber.subscribedAt)}</TableCell>
              <TableCell>{subscriber.unsubscribedAt ? <Badge variant="destructive">Unsubscribed</Badge> : <Badge variant="default">Active</Badge>}</TableCell>
              <TableCell>
                <div className="flex gap-2">
                  {subscriber.preferences.marketing && <Badge variant="outline">Marketing</Badge>}
                  {subscriber.preferences.updates && <Badge variant="outline">Updates</Badge>}
                </div>
              </TableCell>
            </TableRow>
          )
        })}
      </TableBody>
    </Table>
  )
}


/*
  File: components/admin/roadmap-view.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/admin/roadmap-view.tsx
  Directory: components/admin
*/

--- File: components/admin/roadmap-view.tsx ---

"use client"

import { useState } from "react"
import { ChevronDown, ChevronUp, ArrowRight } from "lucide-react"
import Link from "next/link"

import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { Heading } from "@/components/typography/heading"

export type Feature = {
  id: string
  title: string
  votes: number // Keeping this in the type for data compatibility
  status: "backlog" | "planned" | "in-progress" | "completed"
  description?: string
}

export type FeatureRequest = {
  id: string
  title: string
  votes: number // Keeping this in the type for data compatibility
  description?: string
}

interface RoadmapViewProps {
  features: Feature[]
  featureRequests: FeatureRequest[]
}

export function RoadmapView({ features, featureRequests }: RoadmapViewProps) {
  const [expanded, setExpanded] = useState<Record<string, boolean>>({
    backlog: false,
    planned: false,
    "in-progress": false,
    completed: false,
  })

  // Group features by status
  const backlogFeatures = features.filter((f) => f.status === "backlog").sort((a, b) => b.votes - a.votes)
  const plannedFeatures = features.filter((f) => f.status === "planned").sort((a, b) => b.votes - a.votes)
  const inProgressFeatures = features.filter((f) => f.status === "in-progress").sort((a, b) => b.votes - a.votes)
  const completedFeatures = features.filter((f) => f.status === "completed").sort((a, b) => b.votes - a.votes)

  // Sort feature requests by votes
  const sortedRequests = [...featureRequests].sort((a, b) => b.votes - a.votes)

  const toggleExpand = (section: string) => {
    setExpanded((prev) => ({
      ...prev,
      [section]: !prev[section],
    }))
  }

  // Function to limit and display cards
  const renderFeatureCards = (featureList: Feature[], status: string) => {
    const isExpanded = expanded[status]
    const displayedFeatures = isExpanded ? featureList : featureList.slice(0, 4)
    const hasMore = featureList.length > 4

    return (
      <>
        <div className="space-y-3">
          {displayedFeatures.map((feature) => (
            <Card key={feature.id} className="gap-2">
              <CardHeader>
                <CardTitle className="font-bold">{feature.title}</CardTitle>
              </CardHeader>
              <CardContent>{feature.description && <p className="text-xs text-muted-foreground">{feature.description}</p>}</CardContent>
            </Card>
          ))}
        </div>
        {hasMore && (
          <Button variant="ghost" size="sm" className="w-full mt-2 text-xs" onClick={() => toggleExpand(status)}>
            {isExpanded ? (
              <>
                Show Less <ChevronUp className="ml-1 h-3 w-3" />
              </>
            ) : (
              <>
                Show More ({featureList.length - 4} more) <ChevronDown className="ml-1 h-3 w-3" />
              </>
            )}
          </Button>
        )}
      </>
    )
  }

  return (
    <div className="container mx-auto py-8 px-4">
      <div className="container max-w-7xl mx-auto">
        <div className="text-center mb-8 space-y-2">
          <Heading variant="h2">Product Roadmap</Heading>
          <p className="text-muted-foreground">See what features are coming next and share your ideas</p>
        </div>

        <div className="mb-8">
          <div className="grid md:grid-cols-2 lg:grid-cols-4 p-4 gap-6">
            <div>
              <div className="font-medium text-lg mb-2 flex items-center gap-2">
                Backlog{" "}
                <Badge variant="outline" className="bg-gray-100 text-gray-700 hover:bg-gray-100 border-gray-200">
                  {backlogFeatures.length}
                </Badge>
              </div>
              {renderFeatureCards(backlogFeatures, "backlog")}
            </div>

            <div>
              <div className="font-medium text-lg mb-2 flex items-center gap-2">
                Up Next{" "}
                <Badge variant="outline" className="bg-amber-100 text-amber-700 hover:bg-amber-100 border-amber-200">
                  {plannedFeatures.length}
                </Badge>
              </div>
              {renderFeatureCards(plannedFeatures, "planned")}
            </div>

            <div>
              <div className="font-medium text-lg mb-2 flex items-center gap-2">
                In Progress{" "}
                <Badge variant="secondary" className="bg-sky-100 text-sky-700 hover:bg-sky-100 border-sky-200">
                  {inProgressFeatures.length}
                </Badge>
              </div>
              {renderFeatureCards(inProgressFeatures, "in-progress")}
            </div>

            <div>
              <div className="font-medium text-lg mb-2 flex items-center gap-2">
                Completed <Badge className="bg-emerald-100 text-emerald-700 hover:bg-emerald-100 border-emerald-200">{completedFeatures.length}</Badge>
              </div>
              {renderFeatureCards(completedFeatures, "completed")}
            </div>
          </div>
        </div>

        <div className="grid gap-8 md:grid-cols-[2fr_1fr] container border-t-2 border-dashed border-primary/50 pt-12">
          <Card>
            <CardHeader>
              <CardTitle>Feature Ideas</CardTitle>
              <CardDescription>Community suggestions that may be added to the roadmap.</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {sortedRequests.map((request) => (
                  <div key={request.id} className="flex items-start gap-4 p-3 rounded-lg border">
                    <div className="flex-1 space-y-1">
                      <div className="flex items-center gap-2">
                        <span className="font-medium">{request.title}</span>
                        <Badge variant="outline" className="bg-foreground/10 text-foreground">
                          Idea
                        </Badge>
                      </div>
                      {request.description && <p className="text-sm text-muted-foreground">{request.description}</p>}
                    </div>
                  </div>
                ))}
                {featureRequests.length === 0 && (
                  <p className="text-sm text-muted-foreground border border-dashed border-foreground/10 rounded-md px-4 py-12 justify-center items-center flex">
                    No feature requests yet. Be the first to suggest a feature!
                  </p>
                )}
              </div>
            </CardContent>
          </Card>

          <div className="space-y-8">
            <Card>
              <CardHeader>
                <CardTitle>Suggest a Feature</CardTitle>
                <CardDescription>What would you like to see in our product?</CardDescription>
              </CardHeader>
              <CardContent>
                <Button asChild className="w-full">
                  <Link href="/contact/">
                    Suggest a Feature <ArrowRight className="ml-2 h-4 w-4" />
                  </Link>
                </Button>
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <CardTitle>Get Updates</CardTitle>
                <CardDescription>Subscribe to be notified when features are released</CardDescription>
              </CardHeader>
              <CardContent>
                <Button asChild className="w-full">
                  <Link href="/subscribe/">
                    Subscribe to Updates <ArrowRight className="ml-2 h-4 w-4" />
                  </Link>
                </Button>
              </CardContent>
            </Card>
          </div>
        </div>
      </div>
    </div>
  )
}


/*
  File: components/admin/user-list.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/admin/user-list.tsx
  Directory: components/admin
*/

--- File: components/admin/user-list.tsx ---

"use client"

import * as React from "react"
import { useState } from "react"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { banUser } from "@/app/_actions/ban-user"
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from "@/components/ui/alert-dialog"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { toast } from "sonner"

interface User {
  id: string
  email: string | undefined
  username: string | null
  firstName: string | null
  lastName: string | null
  imageUrl: string
  createdAt: string
  isAdmin: boolean
  banned: boolean
  publicMetadata?: {
    banReason?: string
  }
}

interface AdminUserListProps {
  initialUsers: User[]
}

export function AdminUserList({ initialUsers }: AdminUserListProps) {
  const [users, setUsers] = useState<User[]>(initialUsers)
  const [showBanDialog, setShowBanDialog] = useState(false)
  const [selectedUser, setSelectedUser] = useState<User | null>(null)
  const [banReason, setBanReason] = useState("")
  const [isLoading, setIsLoading] = useState(false)

  const handleBanClick = (user: User) => {
    setSelectedUser(user)
    setShowBanDialog(true)
  }

  const handleBanConfirm = async () => {
    if (!selectedUser) return

    setIsLoading(true)
    try {
      const result = await banUser(selectedUser.id, banReason)

      if (result.success) {
        // Update the local users state
        setUsers(
          users.map((user) => {
            if (user.id === selectedUser.id) {
              return {
                ...user,
                banned: !user.banned,
                publicMetadata: {
                  ...user.publicMetadata,
                  banReason: !user.banned ? banReason : undefined,
                },
              }
            }
            return user
          })
        )

        toast.success(selectedUser.banned ? "User unbanned successfully" : "User banned successfully")
        setShowBanDialog(false)
        setBanReason("")
        setSelectedUser(null)
      } else {
        toast.error("Failed to manage user ban status: " + result.error)
      }
    } catch {
      toast.error("An error occurred while managing user ban status")
    } finally {
      setIsLoading(false)
    }
  }

  const formatDate = (date: string | null) => {
    if (!date) return "Never"
    return new Date(date).toLocaleDateString()
  }

  return (
    <>
      <div className="rounded-md border">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead className="w-[30px]"></TableHead>
              <TableHead>User</TableHead>
              <TableHead>Email</TableHead>
              <TableHead>Username</TableHead>
              <TableHead>Joined</TableHead>
              <TableHead>Status</TableHead>
              <TableHead>Actions</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {users.map((user) => (
              <React.Fragment key={user.id}>
                <TableRow>
                  <TableCell>{/* Placeholder for user action button */}</TableCell>
                  <TableCell className="flex items-center gap-2">
                    <Avatar className="h-8 w-8">
                      <AvatarImage src={user.imageUrl} alt={user.username || ""} />
                      <AvatarFallback>
                        {user.firstName?.[0]}
                        {user.lastName?.[0]}
                      </AvatarFallback>
                    </Avatar>
                    <span>
                      {user.firstName} {user.lastName}
                    </span>
                  </TableCell>
                  <TableCell>{user.email}</TableCell>
                  <TableCell>{user.username}</TableCell>
                  <TableCell>{formatDate(user.createdAt)}</TableCell>
                  <TableCell>{user.isAdmin ? <Badge>Admin</Badge> : user.banned ? <Badge variant="destructive">Banned</Badge> : <Badge variant="secondary">User</Badge>}</TableCell>
                  <TableCell>
                    {!user.isAdmin && (
                      <Button variant={user.banned ? "outline" : "destructive"} size="sm" onClick={() => handleBanClick(user)} disabled={isLoading}>
                        {user.banned ? "Unban User" : "Ban User"}
                      </Button>
                    )}
                  </TableCell>
                </TableRow>
              </React.Fragment>
            ))}
          </TableBody>
        </Table>
      </div>

      <AlertDialog open={showBanDialog} onOpenChange={setShowBanDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>{selectedUser?.banned ? "Unban User" : "Ban User"}</AlertDialogTitle>
            <AlertDialogDescription>
              {selectedUser?.banned ? (
                <>
                  Are you sure you want to unban {selectedUser?.firstName} {selectedUser?.lastName}?
                </>
              ) : (
                <>
                  Are you sure you want to ban {selectedUser?.firstName} {selectedUser?.lastName}? This action can be undone later.
                </>
              )}
            </AlertDialogDescription>
          </AlertDialogHeader>
          {!selectedUser?.banned && (
            <div className="py-4">
              <Label htmlFor="reason">Reason for ban (optional)</Label>
              <Input id="reason" value={banReason} onChange={(e) => setBanReason(e.target.value)} placeholder="Enter reason for ban" />
            </div>
          )}
          <AlertDialogFooter>
            <AlertDialogCancel
              onClick={() => {
                setShowBanDialog(false)
                setBanReason("")
                setSelectedUser(null)
              }}
            >
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction onClick={handleBanConfirm} disabled={isLoading}>
              {selectedUser?.banned ? "Unban User" : "Ban User"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  )
}


/*
  File: components/adventure/adventure-complete.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/adventure-complete.tsx
  Directory: components/adventure
*/

--- File: components/adventure/adventure-complete.tsx ---

import { Card, CardContent } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { CheckCircle, Trophy, BookOpen } from "lucide-react"
import Link from "next/link"

export default function AdventureComplete() {
  return (
    <Card className="max-w-2xl mx-auto border-2 border-green-200 bg-gradient-to-b from-green-50 to-white">
      <CardContent className="flex flex-col items-center gap-6 py-16">
        <div className="flex items-center gap-3">
          <Trophy className="h-12 w-12 text-yellow-500 animate-bounce" />
          <CheckCircle className="h-12 w-12 text-green-500" />
        </div>

        <div className="text-center space-y-3">
          <h2 className="text-3xl font-bold text-green-800">Adventure Complete!</h2>
          <p className="text-xl text-muted-foreground">Congratulations! You have successfully completed this adventure.</p>
          <p className="text-sm text-muted-foreground max-w-md">
            The story has reached its conclusion. Your journey through the Valkarr forest and the mysteries it holds has come to an end. Well done, adventurer!
          </p>
        </div>

        <div className="flex gap-3 mt-4">
          <Button asChild variant="outline" className="flex items-center gap-2">
            <Link href="/">
              <BookOpen className="h-4 w-4" />
              Explore More Adventures
            </Link>
          </Button>
        </div>
      </CardContent>
    </Card>
  )
}


/*
  File: components/adventure/character-dice-roll-result-display.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/character-dice-roll-result-display.tsx
  Directory: components/adventure
*/

--- File: components/adventure/character-dice-roll-result-display.tsx ---

import Image from "next/image"
import { IMAGE_HOST } from "@/lib/config"
import DiceRollResult from "@/components/adventure/dice-roll-result"

export default function CharacterDiceRollResultDisplay({
  character,
  rollType,
  difficulty,
  result,
  image,
  modifier,
  baseRoll,
}: {
  character: string
  rollType: string
  difficulty: number
  result: number
  image?: string
  modifier?: number
  baseRoll?: number
}) {
  const imageUrl = image || "/images/app/characters/default.png"
  return (
    <div className="relative aspect-[4/5] sm:aspect-auto font-display font-bold border border-primary-700 rounded-xl overflow-hidden">
      <div className="absolute top-0 left-0 h-2/3 sm:h-full w-full sm:w-2/3 overflow-hidden">
        <Image className="object-cover" src={IMAGE_HOST + imageUrl} alt={character} fill={true} />
        <div className="absolute bottom-0 sm:bottom-auto sm:top-0 right-0 w-full sm:w-1/3 h-1/3 sm:h-full bg-gradient-to-t sm:bg-gradient-to-l from-black to-transparent"></div>
      </div>
      <div className="px-4 py-6 flex flex-col gap-2 text-center items-center justify-start w-full sm:w-1/2 absolute bottom-0 sm:relative sm:left-1/2">
        <h4 className="text-xs opacity-70">Dice Roll Result</h4>
        <h3 className="text-2xl">{rollType}</h3>
        <div className="font-mono text-xs text-primary-300 -mt-2 uppercase tracking-wider">
          <span className="scale-90">Target {difficulty}</span>
          {typeof baseRoll === "number" && modifier !== 0 && (
            <>
              <span className="font-bold text-white">
                {" "}
                <span className="text-white/50">|</span> {baseRoll}
              </span>
              {typeof modifier === "number" && modifier !== 0 && (
                <>
                  <span className={modifier > 0 ? "text-green-500" : "text-red-500"}>
                    {" "}
                    {modifier > 0 ? " + " : " - "}
                    {Math.abs(modifier)}
                  </span>
                </>
              )}
              {typeof modifier === "number" && modifier !== 0 ? <> </> : null}
            </>
          )}
        </div>
        <div className="flex flex-col items-center gap-1">
          <DiceRollResult result={result} />
        </div>
      </div>
    </div>
  )
}


/*
  File: components/adventure/character-dice-roll.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/character-dice-roll.tsx
  Directory: components/adventure
*/

--- File: components/adventure/character-dice-roll.tsx ---

import DiceRoll from "@/components/ui/dice-roll"
import { cn } from "@/lib/utils"
import Image from "next/image"
import { TurnCharacter } from "@/types/adventure"
import { IMAGE_HOST } from "@/lib/config"
import type { RollRequirement } from "@/lib/validations/roll-requirement-schema"

export default function CharacterDiceRoll({
  rollRequired,
  rollResult,
  onRoll,
  className,
  inputKey,
  character,
}: {
  rollRequired: NonNullable<RollRequirement>
  rollResult: number | null
  onRoll: (result: number) => void
  className?: string
  inputKey?: string | number
  character: TurnCharacter
}) {
  const { rollType, difficulty, modifier = 0 } = rollRequired

  console.log("[CharacterDiceRoll] rollRequired:", JSON.stringify(rollRequired, null, 2))

  return (
    <div className={cn("relative aspect-[4/5] sm:aspect-auto font-display font-bold border border-primary-700 rounded-xl overflow-hidden", className)}>
      <div className="absolute top-0 left-0 h-2/3 sm:h-full w-full sm:w-2/3 overflow-hidden">
        <Image className="object-cover" src={IMAGE_HOST + character.image} alt={character.name} fill={true} />
        <div className="absolute bottom-0 sm:bottom-auto sm:top-0 right-0 w-full sm:w-1/3 h-1/3 sm:h-full bg-gradient-to-t sm:bg-gradient-to-l from-black to-transparent"></div>
      </div>
      <div className="px-4 py-6 flex flex-col gap-4 text-center items-center justify-start w-full sm:w-1/2 absolute bottom-0 sm:relative sm:left-1/2">
        <h4 className="text-sm">Dice Roll {rollResult === null ? "Needed" : ""}</h4>
        <h3 className="text-2xl">{rollType}</h3>
        <div className="font-mono text-xs text-primary-300 -mt-4 uppercase tracking-wider">
          Target {difficulty}
          {modifier !== 0 && <span className={modifier > 0 ? "text-green-400" : "text-red-400"}>{modifier > 0 ? `  +${modifier} bonus` : `  ${modifier} penalty`}</span>}
        </div>
        <DiceRoll key={inputKey} className="my-2 scale-90 sm:scale-100" iconSize={48} id="d20-roll" {...(rollResult === null ? { onRoll } : {})} />
      </div>
    </div>
  )
}


/*
  File: components/adventure/character-roll-display.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/character-roll-display.tsx
  Directory: components/adventure
*/

--- File: components/adventure/character-roll-display.tsx ---

import Image from "next/image"

export default function CharacterRollDisplay({
  rollType,
  result,
  difficulty,
  character,
  success,
  modifier,
  baseRoll,
}: {
  rollType: string
  result: number
  difficulty: number
  character: string
  success: boolean
  modifier?: number
  baseRoll?: number
}) {
  return (
    <div
      className={`my-6 flex items-center gap-3 px-4 py-3 rounded-lg font-display text-base shadow-inner border-2 w-fit mx-auto
        ${success ? "bg-green-900/80 text-green-200 border-green-600" : "bg-red-900/80 text-red-200 border-red-600"}
      `}
    >
      <Image src="/images/app/dice/d20.svg" alt="Dice" width={32} height={32} className="inline-block" />
      <span className="font-bold">{character}</span>
      <span className="opacity-70">{rollType}</span>
      <span className="ml-2 font-mono text-lg">
        {typeof baseRoll === "number" ? (
          <>
            {baseRoll}
            {typeof modifier === "number" && modifier !== 0 && (
              <>
                {modifier > 0 ? " + " : " - "}
                <span className={modifier > 0 ? "text-green-400" : "text-red-400"}>{Math.abs(modifier)}</span>
                <> = </>
              </>
            )}
            {typeof modifier === "number" && modifier !== 0 ? result : null}
          </>
        ) : (
          result
        )}
      </span>
      <span className="opacity-60 text-sm">vs DC {difficulty}</span>
      {typeof modifier === "number" && modifier !== 0 && (
        <span className={modifier > 0 ? "text-green-400 ml-2" : "text-red-400 ml-2"}>{modifier > 0 ? `+${modifier} bonus` : `${modifier} penalty`}</span>
      )}
      <span className={`ml-3 px-2 py-1 rounded text-xs font-bold ${success ? "bg-green-700/80 text-green-100" : "bg-red-700/80 text-red-100"}`}>{success ? "Success" : "Failure"}</span>
    </div>
  )
}


/*
  File: components/adventure/dice-roll-result.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/dice-roll-result.tsx
  Directory: components/adventure
*/

--- File: components/adventure/dice-roll-result.tsx ---

"use client"
import React, { useState, useEffect } from "react"
import Image from "next/image"
import { textShadow } from "@/components/typography/styles"

export default function DiceRollResult({ result, animate }: { result: number; animate?: boolean }) {
  const [animatedResult, setAnimatedResult] = useState<number | undefined>(animate ? undefined : result)

  useEffect(() => {
    if (result && animate) {
      let timer: NodeJS.Timeout
      let currentStep = 0
      const steps = 8 // Number of steps for the animation
      const interval = 16 // Initial interval in milliseconds

      const animateResult = () => {
        if (currentStep < steps) {
          setAnimatedResult(Math.ceil(Math.random() * 20)) // Generate a random number between 1 and the die value
          currentStep++
          // Gradually increase the interval to slow down the animation
          timer = setTimeout(animateResult, interval + currentStep * 12)
        } else {
          setAnimatedResult(result) // Finally, set to the actual result
        }
      }

      animateResult()

      return () => {
        clearTimeout(timer) // Clear the timeout if the component unmounts
      }
    }
  }, [result, animate])

  const isNat20 = result === 20
  const isNat1 = result === 1

  const diceBorderColor = isNat20 ? "border-yellow-400/50" : isNat1 ? "border-red-500/50" : "border-blue-300/30"

  const diceTextColor = isNat20 ? "text-yellow-300" : isNat1 ? "text-red-400" : "text-white"

  const diceGlow = isNat20 ? "shadow-[0_0_12px_3px_rgba(250,204,21,0.4)]" : isNat1 ? "shadow-[0_0_12px_3px_rgba(220,38,38,0.4)]" : ""

  return (
    <div className="relative flex flex-col items-center justify-center">
      <div className={`w-20 h-20 flex items-center justify-center text-4xl bg-black/70 border-2 ring-8 ring-white/5 rounded-full ${diceBorderColor} ${diceGlow}`}>
        {animatedResult ? <span className={`font-mono ${diceTextColor}`}>{animatedResult}</span> : <span className="font-display">~</span>}
      </div>
      <div className="-mt-2 flex justify-center w-48">
        {result && (
          <div
            style={{ boxShadow: "inset 0 -4px 16px 0 rgba(0,0,0,.5), 0 0 1px 2px #000" }}
            className={`flex gap-1.5 items-center justify-center w-32 border border-white/30 font-display rounded-full pr-4 text-lg bg-[url('/images/app/backgrounds/buried.png')] brightness-110 contrast-150 saturate-150 shadow-inner bg-blue-500`}
          >
            <div className="w-32 flex gap-1.5 items-center fade-in">
              <div style={{ boxShadow: "inset 0 2px 2px 0 rgba(0,0,0,.85)" }} className="bg-black/20 border border-white/30 h-10 w-10 rounded-full flex items-center justify-center">
                <Image src={`/images/app/dice/d20.svg`} width={36} height={36} alt="Dice Roll" />
              </div>
              <span style={textShadow}>Result</span>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}


/*
  File: components/adventure/turn-advance-button.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/turn-advance-button.tsx
  Directory: components/adventure
*/

--- File: components/adventure/turn-advance-button.tsx ---

"use client"

import React, { useState, useEffect, useRef } from "react"
import { Button } from "@/components/ui/button"

interface TurnAdvanceButtonProps {
  advancing: boolean
  onAdvance: () => void | Promise<void>
}

const TurnAdvanceButton = React.forwardRef<HTMLButtonElement, TurnAdvanceButtonProps>(({ advancing, onAdvance }, ref) => {
  const buttonRef = useRef<HTMLButtonElement | null>(null)
  const [hasClicked, setHasClicked] = useState(false)

  // Allow parent to pass a ref, but default to our own
  const combinedRef = (node: HTMLButtonElement) => {
    if (typeof ref === "function") ref(node)
    else if (ref) (ref as React.MutableRefObject<HTMLButtonElement | null>).current = node
    buttonRef.current = node
  }

  useEffect(() => {
    if (buttonRef.current) {
      buttonRef.current.scrollIntoView({ behavior: "smooth", block: "center" })
    }
  }, [])

  return (
    <Button
      ref={combinedRef}
      size="lg"
      variant="epic"
      disabled={advancing}
      onClick={() => {
        if (!hasClicked) {
          setHasClicked(true)
          onAdvance()
        }
      }}
    >
      {hasClicked ? "Advancing..." : "Go to Next Turn"}
    </Button>
  )
})

TurnAdvanceButton.displayName = "TurnAdvanceButton"

export default TurnAdvanceButton


/*
  File: components/adventure/turn-character-list.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/turn-character-list.tsx
  Directory: components/adventure
*/

--- File: components/adventure/turn-character-list.tsx ---

import { IMAGE_HOST } from "@/lib/config"
import { useTurn } from "@/lib/context/TurnContext"
import { cn } from "@/lib/utils"
import { CircleCheckBig } from "lucide-react"
import { useState } from "react"
import Image from "next/image"

function CharacterImage({ src, alt }: { src: string; alt: string }) {
  const [loaded, setLoaded] = useState(false)
  return (
    <div className="w-8 sm:w-12 h-8 sm:h-12 rounded-xl bg-black border border-white/30 relative overflow-hidden z-10">
      <Image
        src={src}
        alt={alt}
        fill
        className={"absolute inset-0 w-full h-full object-cover rounded-xl transition-opacity duration-300" + (loaded ? " opacity-100" : " opacity-0")}
        onLoad={() => setLoaded(true)}
      />
    </div>
  )
}

export default function TurnCharacterList() {
  const currentTurn = useTurn()
  const characters = (currentTurn?.characters || []).slice().sort((a, b) => (b.initiative ?? 0) - (a.initiative ?? 0))
  // Find the current actor: highest initiative, not complete
  const currentActorId = characters.find((c) => !c.isComplete)?.id
  return (
    <div className="lg:w-[320px] rounded-xl p-1">
      <ul className="flex flex-col gap-2">
        {characters.map((character) => {
          const isDead = character.healthPercent === 0
          return (
            <li
              key={character.id}
              className={cn(
                "w-full max-w-[300px] sm:w-[320px] flex items-center gap-3 p-1.5 sm:p-2 relative rounded-xl transition-all duration-1000 ease-in-out bg-gradient-to-tl ring ring-primary-700",
                isDead ? "ring-gray-700 from-gray-800/50 via-gray-800/50 to-gray-700/50 opacity-60" : character.isComplete ? "ring-primary-600" : "from-primary-800 via-primary-800 to-primary-700",
                character.id === currentActorId && !isDead ? "scale-100 shadow-md ring-primary-600 ring-2 from-primary-900" : "scale-90 from-primary-800/70 via-primary-800/70 opacity-90",
                isDead && "opacity-50 scale-90" // Ensure dead characters are visually distinct
              )}
            >
              {character.image && <CharacterImage src={IMAGE_HOST + character.image} alt={character.name} />}
              <div className="z-10">
                <div className="text-xxs sm:text-sm font-bold font-display flex items-center gap-2">
                  {character.name}
                  {character.isComplete && !isDead && <CircleCheckBig className="absolute bottom-1.5 right-1.5 inline-block text-green-700 w-4 h-4 rounded-full bg-black ring-2 ring-black" />}
                </div>
                {character.archetype !== "Monster" && (
                  <div className="text-xxxs sm:text-xxs font-display">
                    {character.gender} {character.race} {character.archetype}
                  </div>
                )}

                {characters.length > 1 && !isDead && (
                  <div className="text-base flex items-center justify-center rounded-full bg-black ring ring-primary-600 w-8 h-8 font-mono absolute top-4 -left-5">{character.initiative}</div>
                )}
              </div>
              {character.status && !isDead && (
                <div className="text-xxxs sm:text-xxs font-mono px-2 py-0.5 bg-black rounded absolute -bottom-2 ring ring-primary-700 right-8 z-10">{character.status}</div>
              )}
              {isDead && <div className="text-xxs sm:text-xs text-red-400 font-bold font-mono px-2 py-0.5 bg-black rounded absolute -bottom-2 ring ring-red-700 right-8 z-10">DEAD</div>}
              {!isDead && (
                <div className="absolute top-0 left-0 w-full h-full rounded-xl overflow-hidden">
                  <div
                    className="absolute top-0 left-0 w-full h-full bg-red-800 transition-all duration-1000 ease-in-out"
                    style={{ width: `${100 - character.healthPercent}%`, opacity: (100 - character.healthPercent) / 100 }}
                  />
                </div>
              )}
            </li>
          )
        })}
      </ul>
    </div>
  )
}


/*
  File: components/adventure/turn-narrative-reply.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/turn-narrative-reply.tsx
  Directory: components/adventure
*/

--- File: components/adventure/turn-narrative-reply.tsx ---

"use client"
import React from "react"
import { useAdventure } from "@/lib/context/AdventureContext"
import { SignedIn, SignedOut, SignUpButton, useUser } from "@clerk/nextjs"
import { useTurn } from "@/lib/context/TurnContext"
import { useState } from "react"
import { useRouter } from "next/navigation"
import { Textarea } from "@/components/ui/textarea"
import { Button } from "@/components/ui/button"
import type { TurnCharacter } from "@/types/adventure"
import type { Id } from "@/convex/_generated/dataModel"
import CharacterDiceRoll from "@/components/adventure/character-dice-roll"
import LoadingAnimation from "../ui/loading-animation"
import { hasBooleanProp, hasNumberProp } from "@/lib/utils"
import { formatNarrativeAction } from "@/lib/services/narrative-service"
import { resolvePlayerRollResult } from "@/app/_actions/adventure"
import { createAdventureWithFirstTurn } from "@/app/_actions/adventure"

type TurnNarrativeReplyProps = {
  character: TurnCharacter
  submitReply?: (args: { turnId: string | Id<"turns">; characterId: string; narrativeAction: string }) => Promise<unknown>
}

export default function TurnNarrativeReply({ character, submitReply }: TurnNarrativeReplyProps) {
  const [input, setInput] = useState("")
  const [loading, setLoading] = useState(false)
  const [hasSubmitted, setHasSubmitted] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const router = useRouter()
  const { user } = useUser()
  const currentTurn = useTurn()
  const { settingId, adventurePlanId, adventure } = useAdventure()

  if (!currentTurn) {
    return null
  }

  const characterState = currentTurn.characters.find((c: { id: string }) => c.id === character.id) as TurnCharacter | undefined
  const isComplete = hasBooleanProp(characterState, "isComplete") ? characterState.isComplete : undefined
  const rollResult = hasNumberProp(characterState, "rollResult") ? characterState.rollResult : null
  if (isComplete) return null

  const handleDemoReply = async () => {
    if (!user || !user.id || !currentTurn) return
    const userId = user.id
    let narrativeAction = input.trim()
    setError(null)
    try {
      if (character) {
        const paragraphs = (currentTurn.narrative || "").split(/\\n\\n+/).filter(Boolean)
        const narrativeContext = paragraphs.slice(-2).join("\\n\\n")
        narrativeAction = await formatNarrativeAction({
          characterName: character.name,
          playerInput: input,
          narrativeContext,
        })
      }
      const prev = currentTurn.narrative || ""
      const newNarrative = prev ? `${prev}\\n\\n${narrativeAction}` : narrativeAction
      const payload = {
        planId: adventurePlanId,
        settingId,
        title: adventure.title,
        ownerId: userId,
        playerIds: [userId],
        startedAt: Date.now(),
        playerInput: input,
        turn: {
          encounterId: currentTurn.encounterId,
          narrative: newNarrative,
          characters: (currentTurn.characters as TurnCharacter[]).map((c) => ({
            ...c,
            hasReplied: c.id === character.id,
            isComplete: c.id === character.id,
            rollRequired: undefined,
            rollResult: undefined,
          })),
          order: 0,
        },
      }
      console.log("[handleDemoReply] Calling createAdventureWithFirstTurn with payload:", JSON.stringify(payload, null, 2))
      setHasSubmitted(true)
      const res = await createAdventureWithFirstTurn(payload)
      console.log("[handleDemoReply] createAdventureWithFirstTurn result:", JSON.stringify(res, null, 2))
      if (res && res.adventureId) {
        console.log("[handleDemoReply] Navigating to new adventure:", `/${settingId}/${adventurePlanId}/${res.adventureId}`)
        router.push(`/${settingId}/${adventurePlanId}/${res.adventureId}`, { scroll: false })
        return
      }
    } catch (err) {
      console.error("[handleDemoReply] Error calling createAdventureWithFirstTurn:", err)
      setError(err instanceof Error ? err.message : "Failed to create adventure. Please try again.")
      setLoading(false)
    }
  }

  const handleCharacterReply = async () => {
    if (!currentTurn || !currentTurn.id || !submitReply) return
    setError(null)
    try {
      const paragraphs = (currentTurn.narrative || "").split(/\\n\\n+/).filter(Boolean)
      const narrativeContext = paragraphs.slice(-2).join("\\n\\n")
      const aiResult = await formatNarrativeAction({
        characterName: character.name,
        playerInput: input,
        narrativeContext,
      })
      console.log("[handleCharacterReply] aiResult:", JSON.stringify(aiResult, null, 2))
      if (typeof aiResult !== "string") {
        console.error("[handleCharacterReply] aiResult is not a string:", aiResult)
        setError("Failed to format reply. Please try again.")
        setLoading(false)
        return
      }
      if (typeof currentTurn.id !== "string") {
        console.error("[handleCharacterReply] currentTurn.id is not a string:", currentTurn.id)
        setError("Invalid turn ID. Please try again.")
        setLoading(false)
        return
      }
      setHasSubmitted(true)
      await submitReply({
        turnId: currentTurn.id,
        characterId: character.id,
        narrativeAction: aiResult,
      })
    } catch (err) {
      console.error("[handleCharacterReply] Error:", err)
      setError(err instanceof Error ? err.message : "Failed to submit reply. Please try again.")
      setLoading(false)
    }
  }

  const handleReply = async (e?: React.FormEvent) => {
    console.log("[handleReply] FUNCTION CALLED with input:", input)
    if (e) e.preventDefault()
    if (!input.trim()) return
    setLoading(true)
    setError(null)
    const isDemoTurn = currentTurn && currentTurn.id.includes("demo")
    try {
      if (isDemoTurn) {
        await handleDemoReply()
      } else {
        await handleCharacterReply()
      }
    } catch (err) {
      console.error("[handleReply] Error:", err)
      if (!error) {
        setError(err instanceof Error ? err.message : "An unexpected error occurred. Please try again.")
      }
    } finally {
      setLoading(false)
    }
  }

  const handleInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setInput(e.target.value)
    setError(null)
  }

  const handleRollResult = async (result: number) => {
    console.log("[handleRollResult] FUNCTION CALLED with result:", result)
    let turnId: Id<"turns"> | undefined = undefined
    if (currentTurn && typeof currentTurn.id === "string") {
      turnId = currentTurn.id as Id<"turns">
    }
    console.log("[handleRollResult] Computed turnId:", turnId)
    if (!turnId) {
      console.log("[handleRollResult] No turnId found, aborting.")
      setError("Cannot process roll: current turn ID is missing.")
      return
    }
    setLoading(true)
    setError(null)
    try {
      await resolvePlayerRollResult({
        turnId,
        characterId: character.id,
        result,
      })
    } catch (err) {
      console.error("[handleRollResult] Error in resolvePlayerRollResult:", err)
      if (err instanceof Error && err.message.includes("Insufficient tokens")) {
        setError("You do not have enough tokens to perform this action. Please add more tokens to your account.")
      } else if (err instanceof Error) {
        setError(err.message)
      } else {
        setError("Failed to process roll result. Please try again.")
      }
    } finally {
      setInput("")
      setLoading(false)
    }
  }

  return (
    <form onSubmit={handleReply} className="flex flex-col gap-4 min-h-[100px]">
      {!loading && !hasSubmitted && (
        <>
          <Textarea className="text-lg border-white/30" value={input} onChange={handleInputChange} placeholder="Write your character's actions and dialogue here, in the third person..." />
          {error && <p className="text-sm text-red-500 mt-2">{error}</p>}
          <div className="flex justify-end mt-2">
            <SignedIn>
              <Button type="submit" disabled={!input.trim()} variant="epic" size="lg">
                Send Reply
              </Button>
            </SignedIn>
            <SignedOut>
              <SignUpButton mode="modal">
                <Button className="tracking-normal" variant="epic" size="lg">
                  Sign Up to Reply
                </Button>
              </SignUpButton>
            </SignedOut>
          </div>
        </>
      )}
      {characterState?.rollRequired && rollResult == null && (
        <CharacterDiceRoll character={characterState as TurnCharacter} rollRequired={characterState.rollRequired} rollResult={rollResult ?? null} onRoll={handleRollResult} inputKey={input} />
      )}
      {loading && <LoadingAnimation />}
    </form>
  )
}


/*
  File: components/adventure/turn-narrative.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/turn-narrative.tsx
  Directory: components/adventure
*/

--- File: components/adventure/turn-narrative.tsx ---

"use client"

import { useEffect } from "react"
import { useTurn } from "@/lib/context/TurnContext"
import TurnNarrativeReply from "./turn-narrative-reply"
import { parseNarrative } from "@/lib/utils/parse-narrative"
import CharacterDiceRollResultDisplay from "@/components/adventure/character-dice-roll-result-display"
import type { TurnCharacter } from "@/types/adventure"
import type { Id } from "@/convex/_generated/dataModel"
import { advanceTurn } from "@/app/_actions/advance-turn"
import React from "react"
import TurnAdvanceButton from "@/components/adventure/turn-advance-button"
import { processTurnReply } from "@/app/_actions/adventure"
import { useAdventure } from "@/lib/context/AdventureContext"
import LoadingAnimation from "../ui/loading-animation"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { AlertTriangle } from "lucide-react"

export default function TurnNarrative() {
  const currentTurn = useTurn()
  const { settingId, adventurePlanId } = useAdventure()
  const bottomRef = React.useRef<HTMLDivElement>(null)
  const [advancing, setAdvancing] = React.useState(false)
  const [initialNarrative, setInitialNarrative] = React.useState("")
  const [tokenError, setTokenError] = React.useState<string | null>(null)

  useEffect(() => {
    // scroll to bottom of page when currentTurn.narrative changes after the first render
    if (currentTurn?.narrative) {
      if (!initialNarrative) {
        setInitialNarrative(currentTurn.narrative)
      } else if (initialNarrative !== currentTurn.narrative) {
        // scrollToBottom()
      }
    }
  }, [currentTurn?.narrative])

  if (!currentTurn) {
    console.log("[TurnNarrative] currentTurn is null, returning null")
    return null
  }

  const isTurnComplete = currentTurn.characters.every((c: TurnCharacter) => c.isComplete)

  // Sort characters by initiative (highest first) and find the current actor
  const charactersByInitiative = (currentTurn?.characters || []).slice().sort((a, b) => (b.initiative ?? 0) - (a.initiative ?? 0))

  // Find the current actor: highest initiative, not complete
  const currentCharacter = charactersByInitiative.find((c: TurnCharacter) => !c.isComplete)

  // Check if we're waiting for an NPC to process their turn
  const isNpcProcessing = currentCharacter && currentCharacter.type === "npc" && !currentCharacter.hasReplied

  const parsed = parseNarrative(currentTurn?.narrative || "")

  const shouldShowReplyCondition = currentTurn && !currentTurn.isFinalEncounter && currentCharacter && currentCharacter.type === "pc" && !isNpcProcessing

  return (
    <div className="grow max-w-2xl fade-in">
      {tokenError && (
        <Alert variant="destructive" className="my-4">
          <AlertTriangle className="h-4 w-4" />
          <AlertTitle>Action Failed</AlertTitle>
          <AlertDescription>{tokenError}</AlertDescription>
        </Alert>
      )}
      {parsed.map((part, idx) => {
        if (part.type === "paragraph") {
          return (
            <p key={idx} className="text-sm sm:text-base md:text-lg whitespace-pre-line mb-4">
              {part.value}
            </p>
          )
        } else {
          // Use a more unique key if available, otherwise fallback to idx
          const key = part.character ? `${part.character}-${part.rollType}-${part.result}-${part.difficulty}` : idx
          return (
            <div className="pb-6" key={key}>
              <CharacterDiceRollResultDisplay
                character={part.character}
                rollType={part.rollType}
                difficulty={part.difficulty}
                result={part.result}
                image={part.image}
                modifier={part.modifier}
                baseRoll={part.baseRoll}
              />
            </div>
          )
        }
      })}

      {/* Show loading animation if an NPC is processing their turn */}
      {isNpcProcessing && !currentTurn?.isFinalEncounter && (
        <div className="flex flex-col items-center gap-4 py-8">
          <LoadingAnimation />
          <p className="text-indigo-300 font-display">{currentCharacter.name} is rolling…</p>
        </div>
      )}

      {/* Show reply form only if current character is a PC */}
      {shouldShowReplyCondition && (
        <TurnNarrativeReply
          character={currentCharacter!}
          submitReply={async ({ turnId, characterId, narrativeAction }) => {
            setTokenError(null) // Clear previous errors
            try {
              // Cast turnId to Id<'turns'>
              console.log("[TurnNarrative] processTurnReply called with:", JSON.stringify({ turnId, characterId, narrativeAction }, null, 2))
              const result = await processTurnReply({ turnId: turnId as Id<"turns">, characterId, narrativeAction })
              console.log("[TurnNarrative] processTurnReply result:", JSON.stringify(result, null, 2))
              // If the action was implausible, set the feedback as a tokenError to display it.
              if (result?.actionImplausible && result.feedback) {
                setTokenError(result.feedback)
                // Potentially return a different structure or throw an error to prevent further processing in TurnNarrativeReply
                return result // Or throw new Error(result.feedback) if TurnNarrativeReply should stop hard.
              }
              return result
            } catch (error) {
              console.error("[TurnNarrative] Error processing turn reply:", error)
              if (error instanceof Error && error.message.includes("Insufficient tokens")) {
                setTokenError("You do not have enough tokens to perform this action. Please add more tokens to your account.")
              } else if (error instanceof Error) {
                // Handle other specific errors from processTurnReply if needed
                setTokenError(error.message) // Display the error message from the caught error
              } else {
                setTokenError("An unexpected error occurred while processing your action. Please try again.")
              }
              // When an error occurs, you might want to throw it or return a specific structure
              // to let TurnNarrativeReply know that the submission failed.
              // For now, it will fall through and TurnNarrativeReply might proceed as if successful depending on its logic.
              // Consider throwing the error to be caught by TurnNarrativeReply's own error handling if it has one.
              throw error // Re-throw the error so TurnNarrativeReply can also handle it if needed
            }
          }}
        />
      )}

      {isTurnComplete && currentTurn?.isFinalEncounter && (
        <div className="flex flex-col items-center justify-center mt-8 text-center p-6 bg-green-100 border border-green-300 rounded-lg shadow-md">
          <h2 className="text-2xl font-semibold text-green-700 mb-2">Adventure Complete!</h2>
          <p className="text-green-600">Congratulations on reaching the end of your journey.</p>
          {/* You could add a button here to navigate away or view a summary */}
        </div>
      )}
      {isTurnComplete && !currentTurn?.isFinalEncounter && (
        <div className="flex justify-center mt-8">
          <TurnAdvanceButton
            advancing={advancing}
            onAdvance={async () => {
              console.log("[advanceTurn] currentTurn before:", JSON.stringify(currentTurn, null, 2))
              console.log("[advanceTurn] turnId:", currentTurn?.id)
              setAdvancing(true)
              setTokenError(null) // Clear previous errors
              try {
                console.log("[advanceTurn] calling advanceTurn with:", JSON.stringify({ currentTurn }, null, 2))
                const result = await advanceTurn({ turnId: currentTurn?.id as Id<"turns">, settingId, adventurePlanId })
                console.log("[advanceTurn] result:", JSON.stringify(result, null, 2))
                // If successful, scroll to top
                if (!tokenError) {
                  // Check if an error was NOT set from this operation
                  // scrollToTop(); // Re-enable if desired, or use a more specific scroll target
                }
              } catch (error) {
                console.error("[TurnNarrative] Error advancing turn:", error)
                if (error instanceof Error && error.message.includes("Insufficient tokens")) {
                  setTokenError("You do not have enough tokens to perform this action. Please add more tokens to your account.")
                } else {
                  // Handle other types of errors or re-throw if necessary
                  setTokenError("An unexpected error occurred while advancing the turn. Please try again.")
                }
              } finally {
                setAdvancing(false)
                // scrollToTop() // Removed from here
              }
            }}
          />
        </div>
      )}
      <div ref={bottomRef} />
    </div>
  )
}


/*
  File: components/adventure/turn.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/turn.tsx
  Directory: components/adventure
*/

--- File: components/adventure/turn.tsx ---

import TurnCharacterList from "./turn-character-list"
import TurnNarrative from "./turn-narrative"

export default function Turn() {
  return (
    <div className="flex flex-col lg:flex-row gap-4 lg:gap-8 relative pb-24 px-8">
      <TurnCharacterList />
      <TurnNarrative />
    </div>
  )
}


/*
  File: components/checkout/stripe-payment-form.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/checkout/stripe-payment-form.tsx
  Directory: components/checkout
*/

--- File: components/checkout/stripe-payment-form.tsx ---

"use client"

import { useState } from "react"
import { loadStripe } from "@stripe/stripe-js"
import { PaymentElement, Elements, useStripe, useElements } from "@stripe/react-stripe-js"
import { Button } from "@/components/ui/button"

const stripePromise = loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!)

interface PaymentFormProps {
  quantity: number
  userId: string
  onSuccess?: () => void
  discountCode: string
}

function PaymentForm({ quantity, userId, onSuccess, discountCode }: PaymentFormProps) {
  const stripe = useStripe()
  const elements = useElements()
  const [loading, setLoading] = useState(false)

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    if (!stripe || !elements || loading) return

    setLoading(true)

    try {
      const { error, paymentIntent } = await stripe.confirmPayment({
        elements,
        redirect: "if_required",
      })

      if (error) {
        console.error("Payment error:", error)
        return
      }

      if (paymentIntent.status === "succeeded") {
        await fetch("/api/credits/add", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            paymentIntentId: paymentIntent.id,
            userId,
            quantity,
            discountCode,
          }),
        })

        onSuccess?.()
      }
    } catch (error) {
      console.error("Payment processing error:", error)
    } finally {
      setLoading(false)
    }
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div className="max-h-[400px] overflow-y-auto pr-2">
        <PaymentElement />
      </div>
      <Button type="submit" disabled={!stripe || loading} className="w-full mt-4">
        {loading ? "Processing..." : "Pay Now"}
      </Button>
    </form>
  )
}

interface StripePaymentFormProps extends PaymentFormProps {
  clientSecret: string
}

export function StripePaymentForm({ clientSecret, quantity, userId, onSuccess, discountCode }: StripePaymentFormProps) {
  return (
    <Elements stripe={stripePromise} options={{ clientSecret }}>
      <PaymentForm quantity={quantity} userId={userId} onSuccess={onSuccess} discountCode={discountCode} />
    </Elements>
  )
}


/*
  File: components/contact/contact-dialog.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/contact/contact-dialog.tsx
  Directory: components/contact
*/

--- File: components/contact/contact-dialog.tsx ---

"use client"

import { useState } from "react"
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog"
import { ContactForm } from "./contact-form"

interface ContactDialogProps {
  trigger: React.ReactNode
  subject?: string
}

export function ContactDialog({ trigger, subject }: ContactDialogProps) {
  const [open, setOpen] = useState(false)

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>{trigger}</DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Contact Us</DialogTitle>
          <DialogDescription>Send us a message and we&apos;ll get back to you as soon as possible.</DialogDescription>
        </DialogHeader>
        <ContactForm subject={subject} onSuccess={() => setOpen(false)} />
      </DialogContent>
    </Dialog>
  )
}


/*
  File: components/contact/contact-form.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/contact/contact-form.tsx
  Directory: components/contact
*/

--- File: components/contact/contact-form.tsx ---

"use client"

import { useState } from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Textarea } from "@/components/ui/textarea"
import { toast } from "sonner"
import { sendContactEmail } from "@/app/_actions/contact"
import { useTheme } from "next-themes"
import ReCAPTCHA from "react-google-recaptcha"

interface ContactFormProps {
  subject?: string
  onSuccess?: () => void
  requireCaptcha?: boolean
}

export function ContactForm({ subject = "Contact Message", onSuccess, requireCaptcha = false }: ContactFormProps) {
  const [isLoading, setIsLoading] = useState(false)
  const [captchaToken, setCaptchaToken] = useState<string | null>(null)
  const { theme } = useTheme()

  async function onSubmit(event: React.FormEvent<HTMLFormElement>) {
    event.preventDefault()
    setIsLoading(true)

    const formData = new FormData(event.currentTarget)
    const data = {
      name: formData.get("name") as string,
      email: formData.get("email") as string,
      message: formData.get("message") as string,
      subject,
      ...(requireCaptcha && captchaToken && { captchaToken }),
    }

    try {
      if (requireCaptcha && !captchaToken) {
        throw new Error("Please complete the reCAPTCHA verification")
      }

      const result = await sendContactEmail(data)

      if (result.success) {
        toast.success("Message sent", {
          description: "We'll get back to you as soon as possible.",
        })
        onSuccess?.()
        // Reset form
        event.currentTarget.reset()
        setCaptchaToken(null)
      } else {
        throw new Error(result.error)
      }
    } catch (err) {
      const error = err as Error
      toast.error("Error", {
        description: error.message || "There was a problem sending your message. Please try again.",
      })
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <form onSubmit={onSubmit}>
      <div className="grid gap-4">
        <div className="grid gap-2">
          <Label htmlFor="name">Name</Label>
          <Input id="name" name="name" placeholder="Your name" required />
        </div>
        <div className="grid gap-2">
          <Label htmlFor="email">Email</Label>
          <Input id="email" name="email" type="email" placeholder="your@email.com" required />
        </div>
        <div className="grid gap-2">
          <Label htmlFor="message">Message</Label>
          <Textarea id="message" name="message" placeholder="Your message" required />
        </div>
        {requireCaptcha && (
          <div className="w-full">
            <ReCAPTCHA sitekey={process.env.NEXT_PUBLIC_RECAPTCHA_SITE_KEY || ""} theme={theme === "dark" ? "dark" : "light"} onChange={(value) => setCaptchaToken(value)} />
          </div>
        )}
      </div>
      <div className="mt-4 flex justify-end">
        <Button type="submit" disabled={isLoading || (requireCaptcha && !captchaToken)}>
          {isLoading ? "Sending..." : "Send Message"}
        </Button>
      </div>
    </form>
  )
}


/*
  File: components/demo/ai-demo-client.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/demo/ai-demo-client.tsx
  Directory: components/demo
*/

--- File: components/demo/ai-demo-client.tsx ---

"use client"
import { useState } from "react"
import { Button } from "@/components/ui/button"
import { Textarea } from "@/components/ui/textarea"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { useGenerateText } from "@/app/_hooks/useGenerateText"
import { useGenerateStrings } from "@/app/_hooks/useGenerateStrings"
import { useGenerateObject } from "@/app/_hooks/useGenerateObject"
import { useGenerateImage } from "@/app/_hooks/useGenerateImage"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Input } from "@/components/ui/input"
import Image from "next/image"
import { z } from "zod"

const personSchema = z.object({
  name: z.string().describe("The person's full name"),
  age: z.number().describe("The person's age"),
  occupation: z.string().describe("The person's job or profession"),
  interests: z.array(z.string()).describe("List of the person's hobbies and interests"),
  contact: z
    .object({
      email: z.string().email().describe("The person's email address"),
      phone: z.string().describe("The person's phone number"),
    })
    .describe("Contact information"),
})

export function AIDemoClient({ isMissingReplicateToken }: { isMissingReplicateToken: boolean }) {
  const [generatedText, setGeneratedText] = useState("")
  const [generatedStrings, setGeneratedStrings] = useState<string[]>([])
  const [isGenerating, setIsGenerating] = useState(false)
  const { streamText } = useGenerateText()
  const { generate: generateStrings } = useGenerateStrings()
  const { generate: generateObject, object: generatedObject, isLoading: isGeneratingObject } = useGenerateObject(personSchema)
  const { generate: generateImage, imageUrl, isLoading: isGeneratingImage, error: imageError } = useGenerateImage()

  const handleGenerateText = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    const formData = new FormData(e.currentTarget)
    const prompt = formData.get("prompt") as string

    if (!prompt) return

    setIsGenerating(true)
    try {
      await streamText(prompt, (output: string) => {
        setGeneratedText(output)
      })
    } catch (error) {
      console.error("Error generating text:", error)
    } finally {
      setIsGenerating(false)
    }
  }

  const handleGenerateStrings = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    const formData = new FormData(e.currentTarget)
    const prompt = formData.get("prompt") as string
    const count = Number(formData.get("count")) || 6

    if (!prompt) return

    setIsGenerating(true)
    try {
      const strings = await generateStrings(prompt, count)
      setGeneratedStrings(strings)
    } catch (error) {
      console.error("Error generating strings:", error)
    } finally {
      setIsGenerating(false)
    }
  }

  const handleGenerateObject = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    const formData = new FormData(e.currentTarget)
    const prompt = formData.get("prompt") as string

    if (!prompt) return

    await generateObject(prompt)
  }

  const handleGenerateImage = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    const formData = new FormData(e.currentTarget)
    const prompt = formData.get("prompt") as string

    if (!prompt) return

    await generateImage(prompt)
  }

  return (
    <Tabs defaultValue="text" className="space-y-8">
      <TabsList className="grid w-full grid-cols-4">
        <TabsTrigger value="text">Text</TabsTrigger>
        <TabsTrigger value="strings">String Array</TabsTrigger>
        <TabsTrigger value="object">Structured Data</TabsTrigger>
        <TabsTrigger value="image">Image</TabsTrigger>
      </TabsList>

      <TabsContent value="text" className="space-y-8">
        <Card>
          <CardHeader>
            <CardTitle className="flex justify-between items-center">
              <div>Text Generation</div>
              <div className="font-mono text-sm font-normal text-primary">useGenerateText()</div>
            </CardTitle>
            <CardDescription>Enter a prompt and the AI will generate text based on your input.</CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={handleGenerateText} className="space-y-4">
              <Textarea name="prompt" placeholder="Enter your prompt here..." className="min-h-[100px]" />
              <Button type="submit" className="w-full" disabled={isGenerating}>
                {isGenerating ? "Generating..." : "Generate Text"}
              </Button>
            </form>
          </CardContent>
        </Card>

        {generatedText && (
          <Card>
            <CardHeader>
              <CardTitle>Generated Text</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="whitespace-pre-wrap">{generatedText}</div>
            </CardContent>
          </Card>
        )}
      </TabsContent>

      <TabsContent value="strings" className="space-y-8">
        <Card>
          <CardHeader>
            <CardTitle className="flex justify-between items-center">
              <div>String Array Generation</div>
              <div className="font-mono text-sm font-normal text-primary">useGenerateStrings()</div>
            </CardTitle>
            <CardDescription>Generate multiple strings based on your prompt. Useful for brainstorming names, titles, or ideas.</CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={handleGenerateStrings} className="space-y-4">
              <Textarea name="prompt" placeholder="Enter your prompt here..." className="min-h-[100px]" />
              <div className="flex items-center gap-4">
                <Input type="number" name="count" defaultValue="6" min="1" max="20" className="w-24" />
                <span className="text-sm text-muted-foreground">Number of strings to generate</span>
              </div>
              <Button type="submit" className="w-full" disabled={isGenerating}>
                {isGenerating ? "Generating..." : "Generate Strings"}
              </Button>
            </form>
          </CardContent>
        </Card>

        {generatedStrings.length > 0 && (
          <Card>
            <CardHeader>
              <CardTitle>Generated Strings</CardTitle>
            </CardHeader>
            <CardContent>
              <ul className="list-disc pl-6 space-y-2">
                {generatedStrings.map((string, index) => (
                  <li key={index}>{string}</li>
                ))}
              </ul>
            </CardContent>
          </Card>
        )}
      </TabsContent>

      <TabsContent value="object" className="space-y-8">
        <Card>
          <CardHeader>
            <CardTitle className="flex justify-between items-center">
              <div>Structured Data Generation</div>
              <div className="font-mono text-sm font-normal text-primary">useGenerateObject()</div>
            </CardTitle>
            <CardDescription>Generate structured data about a person. The AI will create a profile with name, age, occupation, interests, and contact information.</CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={handleGenerateObject} className="space-y-4">
              <Textarea name="prompt" placeholder="Describe the person you want to generate data for..." className="min-h-[100px]" />
              <Button type="submit" className="w-full" disabled={isGeneratingObject}>
                {isGeneratingObject ? "Generating..." : "Generate Profile"}
              </Button>
            </form>
          </CardContent>
        </Card>

        {generatedObject && (
          <Card>
            <CardHeader>
              <CardTitle>Generated Profile</CardTitle>
            </CardHeader>
            <CardContent>
              <dl className="space-y-4">
                <div>
                  <dt className="font-semibold">Name</dt>
                  <dd>{generatedObject.name}</dd>
                </div>
                <div>
                  <dt className="font-semibold">Age</dt>
                  <dd>{generatedObject.age}</dd>
                </div>
                <div>
                  <dt className="font-semibold">Occupation</dt>
                  <dd>{generatedObject.occupation}</dd>
                </div>
                {generatedObject.interests && (
                  <div>
                    <dt className="font-semibold">Interests</dt>
                    <dd>
                      <ul className="list-disc pl-6">
                        {generatedObject.interests.map((interest, index) => (
                          <li key={index}>{interest}</li>
                        ))}
                      </ul>
                    </dd>
                  </div>
                )}
                {generatedObject.contact && (
                  <div>
                    <dt className="font-semibold">Contact</dt>
                    <dd className="space-y-1">
                      <div>Email: {generatedObject.contact.email}</div>
                      <div>Phone: {generatedObject.contact.phone}</div>
                    </dd>
                  </div>
                )}
              </dl>
            </CardContent>
          </Card>
        )}
      </TabsContent>

      <TabsContent value="image" className="space-y-8">
        <Card>
          <CardHeader>
            <CardTitle className="flex justify-between items-center">
              <div>Image Generation</div>
              <div className="font-mono text-sm font-normal text-primary">useGenerateImage()</div>
            </CardTitle>
            <CardDescription>Generate an image based on your description.</CardDescription>
          </CardHeader>
          <CardContent>
            {isMissingReplicateToken ? (
              <div className="flex flex-col items-center justify-center h-32 p-4 bg-muted rounded-lg text-red-600">
                <p>Please configure your Replicate API token to enable image generation.</p>
              </div>
            ) : (
              <>
                <div className="font-mono text-xs -mt-4 mb-1 w-full text-right text-muted-foreground">black-forest-labs/flux-schnell</div>
                <form onSubmit={handleGenerateImage} className="space-y-4">
                  <Textarea name="prompt" placeholder="Describe the image you want to generate..." className="min-h-[100px]" />
                  <Button type="submit" className="w-full" disabled={isGeneratingImage}>
                    {isGeneratingImage ? "Generating..." : "Generate Image"}
                  </Button>
                </form>
              </>
            )}
          </CardContent>
        </Card>

        {imageError && (
          <Card className="border-destructive">
            <CardHeader>
              <CardTitle className="text-destructive">Error</CardTitle>
            </CardHeader>
            <CardContent>
              <p>{imageError}</p>
            </CardContent>
          </Card>
        )}

        {imageUrl && !imageError && (
          <Card>
            <CardHeader>
              <CardTitle>Generated Image</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="relative aspect-[2/3] w-full overflow-hidden rounded-lg">
                <Image src={imageUrl} alt="AI generated image" fill className="object-cover" sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw" priority />
              </div>
            </CardContent>
          </Card>
        )}
      </TabsContent>
    </Tabs>
  )
}


/*
  File: components/demo/upload-demo-client.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/demo/upload-demo-client.tsx
  Directory: components/demo
*/

--- File: components/demo/upload-demo-client.tsx ---

"use client"

import { useState } from "react"
import { ImageUpload } from "@/components/ui/image-upload"
import { Card } from "@/components/ui/card"
import { SignInButton, useUser } from "@clerk/nextjs"
import { Button } from "@/components/ui/button"
import { LogIn } from "lucide-react"

export function UploadDemoClient() {
  const [imageUrl, setImageUrl] = useState("")
  const { isSignedIn, isLoaded } = useUser()

  if (!isLoaded) {
    return null // or a loading spinner
  }

  return (
    <Card className="p-6">
      {isSignedIn ? (
        <div className="space-y-8">
          <div>
            <h3 className="text-lg font-medium mb-2">Upload an Image</h3>
            <p className="text-sm text-muted-foreground mb-4">Drag and drop an image file or click to select one from your computer.</p>
            <ImageUpload value={imageUrl} onChange={setImageUrl} onRemove={() => setImageUrl("")} />
          </div>
          {imageUrl && (
            <div>
              <h3 className="text-lg font-medium mb-2">Uploaded Image URL</h3>
              <code className="block w-full p-4 bg-muted rounded-lg text-sm break-all">{imageUrl}</code>
            </div>
          )}
        </div>
      ) : (
        <div className="py-12 text-center space-y-4">
          <div className="flex justify-center mb-4">
            <div className="p-3 rounded-full bg-primary/10">
              <LogIn className="w-6 h-6 text-primary" />
            </div>
          </div>
          <h3 className="text-lg font-medium">Sign in to Upload Files</h3>
          <p className="text-sm text-muted-foreground mb-6">You need to be signed in to use the file upload system.</p>
          <SignInButton mode="modal">
            <Button size="lg">Sign in to Continue</Button>
          </SignInButton>
        </div>
      )}
    </Card>
  )
}


/*
  File: components/edit-profile/index.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/edit-profile/index.tsx
  Directory: components/edit-profile
*/

--- File: components/edit-profile/index.tsx ---

"use client"

import { useState } from "react"
import { toast } from "sonner"
import { useUser } from "@clerk/nextjs"
import { Edit2, Plus, X } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Textarea } from "@/components/ui/textarea"
import { Label } from "@/components/ui/label"
import { updateProfile } from "@/app/_actions/profile"

interface UserData {
  id: string
  username: string | null
  firstName: string | null
  lastName: string | null
  imageUrl: string
  unsafeMetadata?: Record<string, unknown>
}

interface Link {
  label: string
  url: string
}

interface EditProfileProps {
  user: UserData
  bio: string
  onUpdate: () => void
  isEditing: boolean
  onCancel: () => void
  onStartEdit: () => void
}

export function EditProfile({ user, bio, onUpdate, isEditing, onCancel, onStartEdit }: EditProfileProps) {
  const { user: currentUser } = useUser()
  const [loading, setLoading] = useState(false)
  const [profileData, setProfileData] = useState({
    firstName: user.firstName || "",
    lastName: user.lastName || "",
    bio: bio || "",
    website: {
      label: "Website",
      url: (user.unsafeMetadata?.website as string) || "",
    },
    twitter: {
      label: "Twitter",
      url: (user.unsafeMetadata?.twitter as string) || "",
    },
    github: {
      label: "GitHub",
      url: (user.unsafeMetadata?.github as string) || "",
    },
    customLinks: ((user.unsafeMetadata?.customLinks as Link[]) || []).map((link) => ({
      label: link.label || "",
      url: link.url || "",
    })),
  })

  const addCustomLink = () => {
    setProfileData((prev) => ({
      ...prev,
      customLinks: [...prev.customLinks, { label: "", url: "" }],
    }))
  }

  const removeCustomLink = (index: number) => {
    setProfileData((prev) => ({
      ...prev,
      customLinks: prev.customLinks.filter((_, i) => i !== index),
    }))
  }

  const updateCustomLink = (index: number, field: "label" | "url", value: string) => {
    setProfileData((prev) => ({
      ...prev,
      customLinks: prev.customLinks.map((link, i) => (i === index ? { ...link, [field]: value } : link)),
    }))
  }

  const isOwnProfile = currentUser?.username?.toLowerCase() === user.username?.toLowerCase()

  const handleSave = async () => {
    if (!currentUser || !isOwnProfile) return

    setLoading(true)
    try {
      const result = await updateProfile(currentUser.id, {
        firstName: profileData.firstName,
        lastName: profileData.lastName,
        bio: profileData.bio,
        website: profileData.website.url,
        twitter: profileData.twitter.url,
        github: profileData.github.url,
        customLinks: profileData.customLinks,
      })

      if (!result.success) {
        throw new Error(result.error)
      }

      toast.success("Profile updated", {
        description: "Your profile has been successfully updated.",
      })

      onUpdate()
    } catch (error) {
      console.error("Error updating profile:", error)
      toast.error("Error", {
        description: "Failed to update profile. Please try again.",
      })
    }
    setLoading(false)
  }

  if (!isOwnProfile) {
    return null
  }

  if (!isEditing) {
    return (
      <Button variant="outline" size="sm" onClick={onStartEdit}>
        <Edit2 className="mr-2 h-4 w-4" />
        Edit Profile
      </Button>
    )
  }

  return (
    <div className="space-y-4 w-full -mt-6">
      <h3 className="text-lg font-medium">Edit Profile</h3>
      <div>
        <Input placeholder="First Name" value={profileData.firstName} onChange={(e) => setProfileData({ ...profileData, firstName: e.target.value })} className="mb-2" />
        <Input placeholder="Last Name" value={profileData.lastName} onChange={(e) => setProfileData({ ...profileData, lastName: e.target.value })} />
      </div>
      <div>
        <h2 className="font-medium mb-2">About</h2>
        <Textarea placeholder="Tell us about yourself..." value={profileData.bio} onChange={(e) => setProfileData({ ...profileData, bio: e.target.value })} rows={4} />
      </div>
      <div>
        <div className="space-y-4">
          <div className="space-y-2 pt-2">
            <Label>Website</Label>
            <Input
              data-testid="website-url"
              value={profileData.website.url}
              onChange={(e) => setProfileData({ ...profileData, website: { ...profileData.website, url: e.target.value } })}
              placeholder="URL (e.g. https://example.com)"
            />
          </div>

          <div className="space-y-2">
            <Label>Twitter/X</Label>
            <Input
              data-testid="twitter-username"
              value={profileData.twitter.url}
              onChange={(e) => setProfileData({ ...profileData, twitter: { ...profileData.twitter, url: e.target.value } })}
              placeholder="Username (without @)"
            />
          </div>

          <div className="space-y-2">
            <Label>GitHub</Label>
            <Input
              data-testid="github-username"
              value={profileData.github.url}
              onChange={(e) => setProfileData({ ...profileData, github: { ...profileData.github, url: e.target.value } })}
              placeholder="Username"
            />
          </div>

          {profileData.customLinks.map((link, index) => (
            <div key={index} className="space-y-2">
              <div className="flex items-center justify-between">
                <div className="h-4" />
                <Button type="button" variant="ghost" size="sm" onClick={() => removeCustomLink(index)} className="h-8 w-8 p-0">
                  <X className="h-4 w-4" />
                </Button>
              </div>
              <div className="flex gap-2">
                <Input data-testid={`custom-link-${index}-label`} value={link.label} onChange={(e) => updateCustomLink(index, "label", e.target.value)} placeholder="Label" className="w-1/3" />
                <Input data-testid={`custom-link-${index}-url`} value={link.url} onChange={(e) => updateCustomLink(index, "url", e.target.value)} placeholder="URL" className="flex-1" />
              </div>
            </div>
          ))}

          <Button type="button" variant="outline" size="sm" onClick={addCustomLink} className="w-full">
            <Plus className="mr-2 h-4 w-4" />
            Add Custom Link
          </Button>
        </div>
      </div>
      <div className="flex justify-end gap-6 pt-4">
        <Button variant="ghost" onClick={onCancel} disabled={loading}>
          Cancel
        </Button>
        <Button id="saveProfileChanges" onClick={handleSave} disabled={loading} className="w-1/2">
          {loading ? "Saving..." : "Save Changes"}
        </Button>
      </div>
    </div>
  )
}


/*
  File: components/forms/mailing-list-form.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/forms/mailing-list-form.tsx
  Directory: components/forms
*/

--- File: components/forms/mailing-list-form.tsx ---

"use client"

import { useState } from "react"
import { useUser } from "@clerk/nextjs"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { subscribe } from "@/app/_actions/mailing-list"
import { toast } from "sonner"
import { useRouter } from "next/navigation"
import Link from "next/link"

export function MailingListForm({ initialEmail }: { initialEmail?: string }) {
  const router = useRouter()
  const { user, isSignedIn, isLoaded } = useUser()
  const [isLoading, setIsLoading] = useState(false)

  if (!isLoaded) {
    return null
  }

  const handleSubscribe = async () => {
    if (!isSignedIn || !user?.emailAddresses?.[0]?.emailAddress) {
      toast.error("Please sign in to join the waitlist")
      return
    }

    try {
      setIsLoading(true)
      await subscribe({
        userId: user.id,
        email: initialEmail || user.emailAddresses[0].emailAddress,
        name: user.fullName || user.firstName || null,
        // preferences: {} // Assuming subscribe action will be updated
      })
      toast.success("Successfully joined the waitlist!")
      router.refresh()
    } catch (error) {
      console.error("Error joining waitlist:", error)
      toast.error("Failed to join the waitlist. Please try again.")
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <Card className="w-full max-w-[500px] p-4 md:mt-4">
      <CardHeader className="md:pt-4">
        <CardTitle className="text-lg">Join the Waitlist</CardTitle>
        <CardDescription>Be the first to know when we launch and get exclusive early access.</CardDescription>
      </CardHeader>
      <CardContent className="md:pb-4">
        <div className="space-y-4">
          {isSignedIn ? (
            <div className="flex gap-4">
              <Button onClick={handleSubscribe} disabled={isLoading || !isSignedIn}>
                Join Waitlist
              </Button>
            </div>
          ) : (
            <p className="border p-4 rounded-lg mt-6">
              Please{" "}
              <Link href="/sign-in/" className="text-primary hover:underline">
                sign in
              </Link>{" "}
              to join the waitlist.
            </p>
          )}
          <p className="text-sm text-muted-foreground pt-4">We&apos;ll notify you as soon as we&apos;re ready. You can unsubscribe at any time.</p>
        </div>
      </CardContent>
    </Card>
  )
}


/*
  File: components/graphics/animation/LoadingAnimation.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/graphics/animation/LoadingAnimation.tsx
  Directory: components/graphics/animation
*/

--- File: components/graphics/animation/LoadingAnimation.tsx ---

"use client"
import React, { useEffect, useRef } from "react"
import Image from "next/image"
import AnimateIn from "@/components/ui/animate-in"
import { cn } from "@/lib/utils"

const spin = `@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  80% {
    transform: rotate(360deg);
  }
  99.99% {
    transform: rotate(360deg);
  }
}`

const LoadingAnimation = ({
  className,
  children,
  containerClassName,
  scrollIntoView = false,
}: {
  className?: string
  containerClassName?: string
  children?: React.ReactNode
  scrollIntoView?: boolean
}) => {
  const containerRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    if (scrollIntoView) {
      containerRef.current?.scrollIntoView({ behavior: "smooth", block: "center" })
    }
  }, [scrollIntoView])

  return (
    <div ref={containerRef} className={cn("flex flex-col items-center justify-center gap-2", containerClassName)}>
      <AnimateIn from="opacity-0 scale-0" to="opacity-100 scale-100" duration={1000} className={cn("w-full flex justify-center", className)}>
        <style>{spin}</style>
        <Image
          className="inline-block p-3 border-2 bg-black/90 border-blue-300 rounded-full overflow-hidden transition-all ease-in-out scale-75 animate-spin"
          src="/images/d20-white.svg"
          width={72}
          height={72}
          alt="Loading"
          style={{ animation: "spin 2s infinite ease-in-out", boxShadow: "0 0 2px #000, 0 0 4px #000, 0 0 8px #000, 0 0 16px #000" }}
        />
      </AnimateIn>
      {children && (
        <AnimateIn className="font-mono" style={{ textShadow: "0 2px 4px #000, 0 2px 16px #000" }} from="opacity-0" to="opacity-80" delay={1000}>
          {children}
        </AnimateIn>
      )}
    </div>
  )
}

export default LoadingAnimation


/*
  File: components/graphics/background/Parchment.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/graphics/background/Parchment.tsx
  Directory: components/graphics/background
*/

--- File: components/graphics/background/Parchment.tsx ---

import Image from "next/image"
import { cn } from "@/lib/utils"

export default function Parchment({ containerClass, imageClass }: { containerClass?: string; imageClass?: string }) {
  return (
    <div className={cn("absolute inset-0 z-0 overflow-hidden bg-gradient-to-t from-[rgba(11,0,0,.1)] to-40%", containerClass)}>
      <Image className={cn("object-cover opacity-[.133]", imageClass)} src="/images/app/backgrounds/parchment-texture.png" fill={true} alt="" priority />
    </div>
  )
}


/*
  File: components/graphics/icon.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/graphics/icon.tsx
  Directory: components/graphics
*/

--- File: components/graphics/icon.tsx ---

import { SparklesIcon } from "@heroicons/react/24/solid"

export function Icon() {
  return (
    <span className="inline-flex flex-col items-center text-fuchsia-600 dark:text-fuchsia-500 select-none">
      <SparklesIcon className="w-3.5 h-3.5 -mb-2.5 relative" />
      <span className="scale-x-200 text-lg font-medium">V</span>
    </span>
  )
}


/*
  File: components/graphics/logo-lockup.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/graphics/logo-lockup.tsx
  Directory: components/graphics
*/

--- File: components/graphics/logo-lockup.tsx ---

import { Icon } from "./icon"

export function LogoLockup() {
  return (
    <div className="flex items-center gap-3">
      <Icon />
      <span className="text-xl font-bold bg-clip-text text-transparent bg-linear-to-br dark:bg-linear-to-br from-blue-500 via-purple-700 to-indigo-500 dark:from-blue-300 dark:via-purple-500 dark:to-indigo-500">
        party starter
      </span>
    </div>
  )
}


/*
  File: components/graphics/styles.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/graphics/styles.ts
  Directory: components/graphics
*/

--- File: components/graphics/styles.ts ---

import { CSSProperties } from "react"

// Extend CSSProperties and include textWrap
interface CustomCSSProperties extends CSSProperties {
  textWrap?: "wrap" | "nowrap" | "balance" | "pretty" | "stable" | "inherit" | "initial" | "revert" | "revert-layer" | "unset"
}

export const emboss = {
  style: {
    textWrap: "balance",
    borderRadius: "255px 15px 225px 15px/15px 225px 15px 255px",
    boxShadow: "-1px 1px 8px 3px rgba(0,0,0,.25) inset",
  } as CustomCSSProperties,
  className:
    "bg-primary-700 text-base font-bold opacity-90 cursor-pointer border-2 sm:border-4 hover:border-primary-400 transition-all ease-in-out duration-500 hover:scale-105 border-primary-500 text-blue-50 hover:text-white disabled:bg-gray-600 disabled:opacity-50 uppercase tracking-widest px-6 rounded-md py-1",
}

export const paper = {
  className: "bg-amber-50 bg-contain bg-repeat brightness-150 contrast-150",
  style: { backgroundImage: `url('/images/app/backgrounds/paper-texture.png')`, backgroundSize: "33%", filter: "saturate(2) hue-rotate(330deg) contrast(1.1)" },
}


/*
  File: components/layout/header.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/layout/header.tsx
  Directory: components/layout
*/

--- File: components/layout/header.tsx ---

import Link from "next/link"
import Image from "next/image"
import AuthButtons from "../nav/auth-buttons"
import { cn } from "@/lib/utils"
import { paper } from "../graphics/styles"
import Parchment from "../graphics/background/Parchment"

export default async function Header({ path }: { path: string }) {
  const isBig = path === "" || path === "/" || path === "/start" || path === "/join"

  return (
    <header
      className={cn(
        paper.className,
        "fixed top-0 select-none z-30 flex sm:gap-1 items-center pr-2 sm:px-8 md:px-12 pt-1 sm:py-4 w-full border-b-8 border-[rgba(0,0,0,.25)]",
        !isBig && "md:px-8 sm:py-0"
      )}
      style={paper.style}
    >
      <Parchment />
      <Link className="cursor-pointer flex items-center font-display scale-90 sm:scale-100 gap-2 mix-blend-multiply" href="/">
        <Image
          className={cn("inline -mt-1 scale-90 sm:scale-100 w-12 h-12", isBig ? "sm:w-[72px] sm:h-[72px]" : "sm:w-8 sm:h-8")}
          width={isBig ? 72 : 36}
          height={isBig ? 72 : 36}
          alt=""
          src="/images/d20.jpg"
        />
        <div className="flex flex-col">
          <h1 className={cn(!isBig && "scale-[.6] -ml-12 font-semibold")} aria-label="D20 Adventures">
            <span className="sr-only">D20 Adventures</span>
            <span aria-hidden="true">
              <span className={cn("text-2xl sm:text-4xl text-primary-600 mr-1", !isBig && "text-2xl")}>D20</span>
              <span className={cn("text-xl sm:text-3xl text-primary-500 relative -top-px", !isBig && "text-xl")}>A</span>
              <span className={cn("text-lg sm:text-2xl text-primary-500 relative -top-[3px]", !isBig && "text-sm")}>dventures</span>
            </span>
          </h1>
        </div>
      </Link>
      <div className="flex flex-1 justify-end items-center scale-90 sm:scale-100 -mt-1 sm:-mt-0 gap-2 pl-4">
        <AuthButtons />
      </div>
    </header>
  )
}


/*
  File: components/layout/theme-provider.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/layout/theme-provider.tsx
  Directory: components/layout
*/

--- File: components/layout/theme-provider.tsx ---

"use client"
import { ThemeProvider as NextThemesProvider } from "next-themes"
import type { ThemeProviderProps } from "next-themes"

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}



/*
  File: components/nav/admin-breadcrumb.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/nav/admin-breadcrumb.tsx
  Directory: components/nav
*/

--- File: components/nav/admin-breadcrumb.tsx ---

import { Breadcrumb, type BreadcrumbItem } from "./breadcrumb"

interface AdminBreadcrumbProps {
  items: BreadcrumbItem[]
}

export function AdminBreadcrumb({ items }: AdminBreadcrumbProps) {
  return (
    <div className="mb-6">
      <Breadcrumb items={items} homeHref="/admin" homeLabel="Admin" />
    </div>
  )
}


/*
  File: components/nav/admin-nav-item.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/nav/admin-nav-item.tsx
  Directory: components/nav
*/

--- File: components/nav/admin-nav-item.tsx ---

"use client"

import { useEffect, useState } from "react"
import Link from "next/link"
import { usePathname } from "next/navigation"
import { useUser } from "@clerk/nextjs"
import { cn } from "@/lib/utils"
import { ShieldCheckIcon } from "lucide-react"

export function AdminNavItem() {
  const pathname = usePathname()
  const { user, isSignedIn, isLoaded } = useUser()
  const [isAdmin, setIsAdmin] = useState(false)

  useEffect(() => {
    // Check if the user is an admin when the component mounts or user changes
    const checkAdminStatus = async () => {
      if (!isLoaded || !isSignedIn || !user?.id) {
        setIsAdmin(false)
        return
      }

      try {
        // Fetch admin status from the server
        const response = await fetch("/api/check-admin")
        if (response.ok) {
          const data = await response.json()
          setIsAdmin(data.isAdmin)
        } else {
          setIsAdmin(false)
        }
      } catch (error) {
        console.error("Error checking admin status:", error)
        setIsAdmin(false)
      }
    }

    checkAdminStatus()
  }, [isLoaded, isSignedIn, user?.id])

  // Only render the admin link if the user is an admin
  if (!isAdmin) {
    return null
  }

  return (
    <Link href="/admin" className={cn("text-sm font-medium transition-colors hover:text-primary flex items-center gap-1", pathname.startsWith("/admin") ? "text-primary" : "text-muted-foreground")}>
      <ShieldCheckIcon className="h-4 w-4" />
      Admin
    </Link>
  )
}


/*
  File: components/nav/auth-buttons.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/nav/auth-buttons.tsx
  Directory: components/nav
*/

--- File: components/nav/auth-buttons.tsx ---

"use client"

import { SignedIn, SignedOut, SignInButton, SignUpButton, UserButton } from "@clerk/nextjs"
import { Button } from "@/components/ui/button"
import { useTokens } from "@/lib/context/TokenContext"
import { formatNumberToK } from "@/lib/utils"
import { Sparkle } from "lucide-react"

export default function AuthButtons() {
  const { tokensRemaining, isLoading: isLoadingTokens } = useTokens()

  return (
    <div className={`flex items-center overflow-hidden transition-[width] duration-300 ease-in-out`}>
      <SignedOut>
        <div className="flex gap-2 sm:gap-4 whitespace-nowrap sm:px-2">
          <SignInButton mode="modal">
            <Button id="signinButton" className="text-[11px] sm:text-sm py-1 px-2 sm:px-4 my-2 tracking-tight sm:tracking-normal font-display normal-case" variant="emboss">
              Sign In
            </Button>
          </SignInButton>
          <SignUpButton mode="modal">
            <Button id="signupButton" className="text-[11px] sm:text-sm py-1 px-2 sm:px-4 my-2 tracking-tight sm:tracking-normal font-display normal-case" variant="emboss">
              Sign Up
            </Button>
          </SignUpButton>
        </div>
      </SignedOut>
      <SignedIn>
        <div className="flex items-center gap-1.5 saturate-50">
          <div className="flex items-center gap-0.5 text-xs sm:text-sm text-muted-foreground">
            {!isLoadingTokens && typeof tokensRemaining === "number" && (
              <div className="flex items-center gap-0.5 text-xxs font-mono font-bold bg-blue-900 text-white py-0.5 px-1.5 rounded">
                <Sparkle className="w-3 h-3 scale-75" />
                <span>{formatNumberToK(tokensRemaining)}</span>
              </div>
            )}
          </div>
          <UserButton userProfileUrl="/account" />
        </div>
      </SignedIn>
    </div>
  )
}


/*
  File: components/nav/breadcrumb.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/nav/breadcrumb.tsx
  Directory: components/nav
*/

--- File: components/nav/breadcrumb.tsx ---

import Link from "next/link"
import { ChevronRight } from "lucide-react"

export interface BreadcrumbItem {
  label: string
  href?: string
}

interface BreadcrumbProps {
  items: BreadcrumbItem[]
  homeHref?: string
  homeLabel?: string
}

export function Breadcrumb({ items, homeHref = "/", homeLabel = "Home" }: BreadcrumbProps) {
  return (
    <nav className="flex items-center text-sm text-muted-foreground">
      <Link href={homeHref} className="hover:text-foreground transition-colors">
        {homeLabel}
      </Link>
      {items.map((item, index) => (
        <div key={item.label} className="flex items-center">
          <ChevronRight className="h-4 w-4 mx-1" />
          {index === items.length - 1 ? (
            <span className="text-foreground font-medium">{item.label}</span>
          ) : (
            <Link href={item.href!} className="hover:text-foreground transition-colors">
              {item.label}
            </Link>
          )}
        </div>
      ))}
    </nav>
  )
}


/*
  File: components/nav/main-nav.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/nav/main-nav.tsx
  Directory: components/nav
*/

--- File: components/nav/main-nav.tsx ---

"use client"

import Link from "next/link"
import { usePathname } from "next/navigation"
import { LogoLockup } from "@/components/graphics/logo-lockup"
import { cn } from "@/lib/utils"
import { navItems } from "@/lib/config/navigation"
import { siteConfig } from "@/lib/config"
import Image from "next/image"
import { Icon } from "@radix-ui/react-select"
interface MainNavProps {
  isAdmin: boolean
}

export function MainNav({ isAdmin }: MainNavProps) {
  const pathname = usePathname()

  return (
    <nav className="flex gap-6 items-center">
      <Link href="/" className="mr-4">
        {siteConfig.title === ("Vibecode Party Starter" as string) ? (
          <LogoLockup />
        ) : (
          <div className="flex items-center gap-3">
            {siteConfig.logo ? <Image src={siteConfig.logo} alt={siteConfig.title + " logo"} width={32} height={32} /> : <Icon />}
            <span className="text-xl font-bold bg-clip-text text-transparent bg-linear-to-br dark:bg-linear-to-br from-blue-500 via-purple-700 to-indigo-500 dark:from-blue-300 dark:via-purple-500 dark:to-indigo-500">
              {siteConfig.title}
            </span>
          </div>
        )}
      </Link>

      {navItems.map((item) => (
        <Link key={item.href} href={item.href} className={cn("text-sm mt-1 font-medium transition-colors hover:text-primary", pathname === item.href ? "text-primary" : "text-muted-foreground")}>
          {item.title}
        </Link>
      ))}

      {isAdmin && (
        <Link href="/admin" className={cn("text-sm mt-1 font-medium transition-colors hover:text-primary", pathname?.startsWith("/admin") ? "text-primary" : "text-muted-foreground")}>
          Admin
        </Link>
      )}
    </nav>
  )
}


/*
  File: components/nav/mobile-nav.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/nav/mobile-nav.tsx
  Directory: components/nav
*/

--- File: components/nav/mobile-nav.tsx ---

"use client"

import { useState } from "react"
import Link from "next/link"
import { usePathname } from "next/navigation"
import { Menu, ShieldCheck } from "lucide-react"
import { LogoLockup } from "@/components/graphics/logo-lockup"
import { Button } from "@/components/ui/button"
import { Sheet, SheetContent, SheetTitle, SheetTrigger } from "@/components/ui/sheet"
import { cn } from "@/lib/utils"
import { useUser } from "@clerk/nextjs"
import { useEffect } from "react"
import { SignedIn, SignedOut, SignInButton, SignUpButton, UserButton } from "@clerk/nextjs"
import { navItems } from "@/lib/config/navigation"
import { siteConfig } from "@/lib/config"
import Image from "next/image"

export function MobileNav() {
  const [open, setOpen] = useState(false)
  const [isAdmin, setIsAdmin] = useState(false)
  const pathname = usePathname()
  const { user, isSignedIn, isLoaded } = useUser()

  useEffect(() => {
    // Check if the user is an admin when the component mounts or user changes
    const checkAdminStatus = async () => {
      if (!isLoaded || !isSignedIn || !user?.id) {
        setIsAdmin(false)
        return
      }

      try {
        // Fetch admin status from the server
        const response = await fetch("/api/check-admin")
        if (response.ok) {
          const data = await response.json()
          setIsAdmin(data.isAdmin)
        } else {
          setIsAdmin(false)
        }
      } catch (error) {
        console.error("Error checking admin status:", error)
        setIsAdmin(false)
      }
    }

    checkAdminStatus()
  }, [isLoaded, isSignedIn, user?.id])

  return (
    <Sheet open={open} onOpenChange={setOpen}>
      <SheetTrigger asChild>
        <Button variant="ghost" size="icon" className="md:hidden">
          <Menu className="h-5 w-5" />
          <span className="sr-only">Toggle menu</span>
        </Button>
      </SheetTrigger>
      <SheetContent side="left" className="flex flex-col">
        <SheetTitle className="sr-only">Menu</SheetTitle>
        <div className="flex items-center justify-between border-b pb-4">
          <Link href="/" className="flex items-center space-x-2 pl-4 pt-4" onClick={() => setOpen(false)}>
            {siteConfig.title === ("Vibecode Party Starter" as string) ? (
              <LogoLockup />
            ) : (
              <div className="flex items-center gap-3">
                {siteConfig.logo && <Image src={siteConfig.logo} alt={siteConfig.title + " logo"} width={32} height={32} />}
                <span className="text-xl font-bold bg-clip-text text-transparent bg-linear-to-br dark:bg-linear-to-br from-blue-500 via-purple-700 to-indigo-500 dark:from-blue-300 dark:via-purple-500 dark:to-indigo-500">
                  {siteConfig.title}
                </span>
              </div>
            )}
          </Link>
        </div>
        <nav className="mt-6 flex flex-col gap-4 pl-10">
          {navItems.map((item) => (
            <Link
              key={item.href}
              href={item.href}
              className={cn("text-lg font-medium transition-colors hover:text-primary", pathname === item.href ? "text-primary" : "text-muted-foreground")}
              onClick={() => setOpen(false)}
            >
              {item.title}
            </Link>
          ))}

          {/* Admin link - only visible to admin users */}
          {isAdmin && (
            <Link
              href="/admin"
              className={cn("text-lg font-medium transition-colors hover:text-primary flex items-center gap-2", pathname.startsWith("/admin") ? "text-primary" : "text-muted-foreground")}
              onClick={() => setOpen(false)}
            >
              <ShieldCheck className="h-5 w-5" />
              Admin
            </Link>
          )}
        </nav>
        <div className="mt-auto flex flex-col gap-4 p-8">
          <SignedOut>
            <SignUpButton mode="modal">
              <Button className="w-full" onClick={() => setOpen(false)}>
                Sign Up
              </Button>
            </SignUpButton>
            <SignInButton mode="modal">
              <Button variant="outline" className="w-full" onClick={() => setOpen(false)}>
                Sign In
              </Button>
            </SignInButton>
          </SignedOut>
          <SignedIn>
            <div className="flex items-center justify-center">
              <UserButton afterSignOutUrl="/" userProfileUrl="/settings/profile" />
            </div>
          </SignedIn>
        </div>
      </SheetContent>
    </Sheet>
  )
}


/*
  File: components/nav/theme-toggle.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/nav/theme-toggle.tsx
  Directory: components/nav
*/

--- File: components/nav/theme-toggle.tsx ---

"use client"

import { useTheme } from "next-themes"
import { Moon, Sun } from "lucide-react"

import { Button } from "@/components/ui/button"
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu"

export function ThemeToggle() {
  const { setTheme } = useTheme()

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" size="icon">
          <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>Light</DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>Dark</DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>System</DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}



/*
  File: components/profile/profile-card.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/profile/profile-card.tsx
  Directory: components/profile
*/

--- File: components/profile/profile-card.tsx ---

"use client"

import { useState } from "react"
import Link from "next/link"
import { cn } from "@/lib/utils"
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar"
import { Card, CardContent } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Separator } from "@/components/ui/separator"
import { Calendar, CheckCircle, Globe, Twitter, Github, Link as LinkIcon } from "lucide-react"
import { EditProfile } from "@/components/edit-profile"
import { refreshProfile } from "@/app/_actions/profile"
import { Heading } from "@/components/typography/heading"

interface Link {
  label: string
  url: string
}

interface ProfileCardProps {
  user: {
    id: string
    username: string | null
    firstName: string | null
    lastName: string | null
    imageUrl: string
    unsafeMetadata?: Record<string, unknown>
  }
  bio: string
  status: string
  joinedDate: string
  path: string
}

export function ProfileCard({ user, bio, status, joinedDate, path }: ProfileCardProps) {
  const [isEditing, setIsEditing] = useState(false)
  const name = user.firstName && user.lastName ? `${user.firstName} ${user.lastName}` : user.firstName || user.username || "Anonymous"
  const website = user.unsafeMetadata?.website as string
  const twitter = user.unsafeMetadata?.twitter as string
  const github = user.unsafeMetadata?.github as string
  const customLinks = (user.unsafeMetadata?.customLinks as Link[]) || []

  const handleUpdate = async () => {
    setIsEditing(false)
    await refreshProfile(path)
  }

  if (isEditing) {
    return (
      <Card>
        <CardContent className="pt-6">
          <EditProfile user={user} bio={bio} onUpdate={handleUpdate} isEditing={true} onCancel={() => setIsEditing(false)} onStartEdit={() => setIsEditing(true)} />
        </CardContent>
      </Card>
    )
  }

  const hasLinks = website || twitter || github || customLinks.length > 0

  return (
    <Card>
      <CardContent className="pt-6">
        <div className="flex flex-col items-center text-center">
          <Link href={`/participants/${user.username}`} className="block hover:opacity-80 transition-opacity">
            <Avatar className="h-24 w-24 mb-4">
              {user.imageUrl && <AvatarImage src={user.imageUrl} alt={name} />}
              <AvatarFallback>{name.substring(0, 2).toUpperCase()}</AvatarFallback>
            </Avatar>
          </Link>
          <div className="space-y-2">
            <Link href={`/participants/${user.username}`} className="block hover:text-primary transition-colors">
              <Heading variant="h1" className="text-2xl font-bold">
                {name}
              </Heading>
            </Link>
            <div className="inline-flex items-center rounded-full bg-green-100 px-3 py-1 text-sm font-medium text-green-800 dark:bg-green-900 dark:text-green-100">
              <CheckCircle className="mr-1 h-3 w-3" />
              {status.charAt(0).toUpperCase() + status.slice(1)}
            </div>
          </div>

          {hasLinks && (
            <div className="flex flex-wrap gap-2 mt-4 justify-center">
              {website && (
                <Button size="sm" variant="outline" asChild>
                  <a href={website.startsWith("http") ? website : `https://${website}`} target="_blank" rel="noopener noreferrer">
                    <Globe className="mr-2 h-4 w-4" />
                    Website
                  </a>
                </Button>
              )}
              {twitter && (
                <Button size="sm" variant="outline" asChild>
                  <a href={`https://x.com/${twitter}`} target="_blank" rel="noopener noreferrer">
                    <Twitter className="mr-2 h-4 w-4" />
                    Twitter/X
                  </a>
                </Button>
              )}
              {github && (
                <Button size="sm" variant="outline" asChild>
                  <a href={`https://github.com/${github}`} target="_blank" rel="noopener noreferrer">
                    <Github className="mr-2 h-4 w-4" />
                    GitHub
                  </a>
                </Button>
              )}
              {customLinks.map((link, index) => (
                <Button key={index} size="sm" variant="outline" asChild>
                  <a href={link.url.startsWith("http") ? link.url : `https://${link.url}`} target="_blank" rel="noopener noreferrer">
                    <LinkIcon className="mr-2 h-4 w-4" />
                    {link.label}
                  </a>
                </Button>
              ))}
            </div>
          )}
        </div>

        <Separator className="my-6" />

        <div className="space-y-4">
          <div>
            <div className="flex items-center justify-between mb-2">
              <Heading variant="h2" className="font-medium">
                About
              </Heading>
              <EditProfile user={user} bio={bio} onUpdate={handleUpdate} isEditing={false} onCancel={() => setIsEditing(false)} onStartEdit={() => setIsEditing(true)} />
            </div>
            <p className={cn("text-sm", bio ? "text-foreground" : "text-muted-foreground italic")}>{bio || "No bio created yet"}</p>
          </div>

          <div className="flex items-center gap-2">
            <Calendar className="h-4 w-4 text-muted-foreground" />
            <span className="text-sm">Joined on {joinedDate}</span>
          </div>
        </div>
      </CardContent>
    </Card>
  )
}


/*
  File: components/typography/heading.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/typography/heading.tsx
  Directory: components/typography
*/

--- File: components/typography/heading.tsx ---

import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const headingVariants = cva("text-balance font-extrabold", {
  variants: {
    variant: {
      h1: "text-4xl sm:text-5xl md:text-7xl scale-x-110 tracking-wide",
      h2: "text-3xl sm:text-5xl font-extrabold",
      h3: "text-2xl sm:text-4xl font-extrabold text-primary",
      h4: "text-xl sm:text-2xl font-bold",
      h5: "text-lg sm:text-xl font-bold",
      h6: "text-base sm:text-lg font-bold",
    },
  },
  defaultVariants: {
    variant: "h1",
  },
})

type HeadingVariant = "h1" | "h2" | "h3" | "h4" | "h5" | "h6"

interface HeadingProps extends Omit<React.HTMLAttributes<HTMLHeadingElement>, "className">, Omit<VariantProps<typeof headingVariants>, "as"> {
  variant: HeadingVariant
  as?: HeadingVariant
  className?: string
}

export function Heading({ className, variant, as, ...props }: HeadingProps) {
  const Tag = as || variant

  return (
    <Tag
      className={cn(
        headingVariants({
          variant,
          className,
        })
      )}
      {...props}
    />
  )
}


/*
  File: components/typography/markdown.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/typography/markdown.tsx
  Directory: components/typography
*/

--- File: components/typography/markdown.tsx ---

import ReactMarkdown from "react-markdown"

const Markdown = ReactMarkdown as unknown as React.FC<{ children: string }>

export { Markdown }


/*
  File: components/typography/styles.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/typography/styles.ts
  Directory: components/typography
*/

--- File: components/typography/styles.ts ---

export const textShadow = {
  textShadow: "0 0 2px #000, 0 0 2px #000, 0 0 2px #000, 0 0 2px #000, 0 0 2px #000, 0 0 2px #000",
}

export const textShadowSpread = {
  textShadow: "0 0 2px #000, 0 0 2px #000, 0 0 4px #000, 0 0 8px #000, 0 0 16px #000, 0 0 32px #000, 0 0 64px #000, 0 0 128px #000",
}

export const textShadowSpreadLight = {
  textShadow:
    "0 0 2px #000, 0 0 2px rgba(0,0,0,0.5), 0 0 4px rgba(0,0,0,0.5), 0 0 8px rgba(0,0,0,0.5), 0 0 16px rgba(0,0,0,0.5), 0 0 32px rgba(0,0,0,0.5), 0 0 64px rgba(0,0,0,0.5), 0 0 128px rgba(0,0,0,0.5)",
}


/*
  File: components/ui/accordion.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/accordion.tsx
  Directory: components/ui
*/

--- File: components/ui/accordion.tsx ---

"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDownIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Accordion({ ...props }: React.ComponentProps<typeof AccordionPrimitive.Root>) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />
}

function AccordionItem({ className, ...props }: React.ComponentProps<typeof AccordionPrimitive.Item>) {
  return <AccordionPrimitive.Item data-slot="accordion-item" className={cn("border-b last:border-b-0", className)} {...props} />
}

function AccordionTrigger({ className, children, ...props }: React.ComponentProps<typeof AccordionPrimitive.Trigger>) {
  return (
    <AccordionPrimitive.Header className="flex">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn(
          "focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 items-start justify-between gap-4 rounded-md py-4 text-left text-sm font-medium transition-all outline-none hover:underline focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180 cursor-pointer",
          className
        )}
        {...props}
      >
        {children}
        <ChevronDownIcon className="text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0.5 transition-transform duration-200" />
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  )
}

function AccordionContent({ className, children, ...props }: React.ComponentProps<typeof AccordionPrimitive.Content>) {
  return (
    <AccordionPrimitive.Content data-slot="accordion-content" className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm" {...props}>
      <div className={cn("pt-0 pb-4", className)}>{children}</div>
    </AccordionPrimitive.Content>
  )
}

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }


/*
  File: components/ui/alert-dialog.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/alert-dialog.tsx
  Directory: components/ui
*/

--- File: components/ui/alert-dialog.tsx ---

"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"
import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<React.ElementRef<typeof AlertDialogPrimitive.Overlay>, React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>>(
  ({ className, ...props }, ref) => (
    <AlertDialogPrimitive.Overlay
      className={cn("fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0", className)}
      {...props}
      ref={ref}
    />
  )
)
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<React.ElementRef<typeof AlertDialogPrimitive.Content>, React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>>(
  ({ className, ...props }, ref) => (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        ref={ref}
        className={cn(
          "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
)
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => <div className={cn("flex flex-col space-y-2 text-center sm:text-left", className)} {...props} />
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)} {...props} />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<React.ElementRef<typeof AlertDialogPrimitive.Title>, React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title ref={ref} className={cn("text-lg font-semibold", className)} {...props} />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<React.ElementRef<typeof AlertDialogPrimitive.Description>, React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>>(
  ({ className, ...props }, ref) => <AlertDialogPrimitive.Description ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
)
AlertDialogDescription.displayName = AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<React.ElementRef<typeof AlertDialogPrimitive.Action>, React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action ref={ref} className={cn(buttonVariants(), className)} {...props} />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<React.ElementRef<typeof AlertDialogPrimitive.Cancel>, React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel ref={ref} className={cn(buttonVariants({ variant: "outline" }), "mt-2 sm:mt-0", className)} {...props} />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}


/*
  File: components/ui/alert.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/alert.tsx
  Directory: components/ui
*/

--- File: components/ui/alert.tsx ---

import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive:
          "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return (
    <div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
}

function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-title"
      className={cn(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        className
      )}
      {...props}
    />
  )
}

function AlertDescription({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      )}
      {...props}
    />
  )
}

export { Alert, AlertTitle, AlertDescription }


/*
  File: components/ui/animate-in.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/animate-in.tsx
  Directory: components/ui
*/

--- File: components/ui/animate-in.tsx ---

import React, { useEffect, useState } from "react"
import type { JSX } from "react"
import { cn } from "@/lib/utils"

const AnimateIn = ({
  children,
  delay = 0,
  duration = 500,
  className = "",
  from,
  to,
  style,
  as = "div",
}: {
  from: string
  to: string
  children?: React.ReactNode
  delay?: number
  duration?: number
  className?: string
  style?: React.CSSProperties
  as?: keyof JSX.IntrinsicElements
}) => {
  const [animate, setAnimate] = useState(from)
  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false)

  useEffect(() => {
    const mediaQuery = window.matchMedia("(prefers-reduced-motion: reduce)")

    const mediaQueryChangeHandler = (e: MediaQueryListEvent) => {
      setPrefersReducedMotion(e.matches)
    }

    setPrefersReducedMotion(mediaQuery.matches)
    mediaQuery.addEventListener("change", mediaQueryChangeHandler)

    return () => {
      mediaQuery.removeEventListener("change", mediaQueryChangeHandler)
    }
  }, [])

  useEffect(() => {
    if (prefersReducedMotion) {
      // If the user prefers reduced motion, skip the animation
      setAnimate(to)
      return
    }

    const timer = setTimeout(() => {
      setAnimate(to)
    }, delay)

    return () => clearTimeout(timer)
  }, [delay, to, prefersReducedMotion])

  return React.createElement(
    as,
    {
      className: cn("transition-all ease-in-out", className, animate),
      style: { transitionDuration: prefersReducedMotion ? "0ms" : `${duration}ms`, ...style },
    },
    children
  )
}

export default AnimateIn


/*
  File: components/ui/avatar.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/avatar.tsx
  Directory: components/ui
*/

--- File: components/ui/avatar.tsx ---

"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const AvatarContext = React.createContext<{ hasError: boolean; setHasError: (error: boolean) => void }>({
  hasError: false,
  setHasError: () => {},
})

function Avatar({ className, ...props }: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  const [hasError, setHasError] = React.useState(false)

  return (
    <AvatarContext.Provider value={{ hasError, setHasError }}>
      <AvatarPrimitive.Root data-slot="avatar" className={cn("relative flex size-8 shrink-0 overflow-hidden rounded-full", className)} {...props} />
    </AvatarContext.Provider>
  )
}

function AvatarImage({ className, ...props }: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  const { setHasError } = React.useContext(AvatarContext)
  const [isLoaded, setIsLoaded] = React.useState(false)

  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full transition-opacity duration-300", isLoaded ? "opacity-100" : "opacity-0", className)}
      onLoad={() => setIsLoaded(true)}
      onError={() => {
        setHasError(true)
        setIsLoaded(false)
      }}
      {...props}
    />
  )
}

function AvatarFallback({ className, ...props }: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  const { hasError } = React.useContext(AvatarContext)

  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn("bg-muted flex size-full items-center justify-center rounded-full transition-opacity duration-200", !hasError && "hidden", className)}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }


/*
  File: components/ui/badge.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/badge.tsx
  Directory: components/ui
*/

--- File: components/ui/badge.tsx ---

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }


/*
  File: components/ui/button.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/button.tsx
  Directory: components/ui
*/

--- File: components/ui/button.tsx ---

import React, { ReactElement, forwardRef } from "react"
import { cn } from "@/lib/utils"
import { emboss } from "../graphics/styles"
import { textShadow } from "../typography/styles"
import { cva } from "class-variance-authority"
import { SparklesIcon } from "@heroicons/react/24/outline"

export interface ButtonProps {
  id?: string
  children: React.ReactNode
  onClick?: (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void
  type?: "button" | "submit" | "reset"
  className?: string
  size?: "default" | "lg" | "sm" | "icon"
  variant?: "epic" | "brick" | "emboss" | "outline" | "ghost" | "ai" | "sparkle" | "destructive"
  disabled?: boolean
  ariaLabel?: string
  asChild?: boolean
  style?: React.CSSProperties
  formAction?: (formData: FormData) => Promise<void>
  role?: string
}

const outline =
  "bg-transparent border-2 bg-blue-950/70 hover:bg-blue-950/80 border-blue-600/90 text-base px-3 py-1 bg-transparent bg-blue-950/70 hover:bg-blue-950/80 border-2 border-blue-600/90 text-base px-3 py-1 disabled:opacity-100 disabled:saturate-0 disabled:brightness-50"

export const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 disabled:border-transparent select-none",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline,
        secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
        sparkle: cn(outline, "scale-90 sm:scale-100 -left-1 sm:left-0"),
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export const baseButtonClass =
  "inline-flex gap-1 items-center justify-center transition-all ease-in-out duration-500 text-blue-50 hover:text-white hover:scale-105 active:scale-100 disabled:bg-gray-600 disabled:opacity-50 disabled:pointer-events-none px-3 rounded-md py-1 disabled:border-transparent select-none"
export const epicButtonClass = cn(
  baseButtonClass,
  "px-8 py-3 bg-blue-600 font-bold brightness-110 saturate-[1.2] scale-105 active:scale-100 hover:scale-110 border-[rgba(0,0,0,.66)] disabled:opacity-90 border-4 rounded-full font-display tracking-widest bg-[url('/images/app/backgrounds/buried.png')]"
)
export const aiButtonClass = cn(
  baseButtonClass,
  "bg-black/10 hover:bg-black/20 hover:scale-100 mix-blend-hard-light text-lg sm:text-2xl border-double border-8 px-6 rounded-full border-white/20 hover:border-white/30 font-mono"
)

export const epicButtonStyle = {
  ...textShadow,
  boxShadow: "-4px -8px 0px 0px #0006 inset, 4px 4px 0px 0px #FFF7 inset, -4px -8px 36px 0px rgba(0,0,0,.5) inset, -3px -3px 6px 1px rgba(255,255,255,0.5) inset",
}
export const brickButtonClass =
  "font-serif bg-blue-600 saturate-[1.2] brightness-110 rounded-2xl border-4 border-blue-900 text-white ml-[2px] px-2 py-[2px] rounded text-sm transition-all ease-in-out hover:scale-105 active:scale-95 bg-[url('/images/app/backgrounds/buried.png')]"

const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ id, ariaLabel, role, children, formAction, onClick, type = "button", className = "transition-all ease-in-out", size = "base", variant = "", disabled, asChild, style }, ref) => {
    let sizeClass = ""
    if (size === "large") {
      sizeClass = "text-3xl py-6"
    } else if (size === "small") {
      sizeClass = "text-lg py-2"
    } else if (size === "icon") {
      sizeClass = "h-9 w-9"
    }

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let buttonStyle: any

    let variantClass = ""
    if (variant === "epic") {
      variantClass = epicButtonClass
      buttonStyle = epicButtonStyle
    }
    if (variant === "brick") {
      variantClass = brickButtonClass
    }
    if (variant === "emboss") {
      variantClass = emboss.className
      buttonStyle = emboss.style
    }
    if (variant === "ai") {
      variantClass = aiButtonClass
      buttonStyle = { boxShadow: "0px 0px 10px 2px rgba(0,0,0,.5) inset" }
    }

    if (variant === "outline" || variant === "sparkle") {
      variantClass = "bg-transparent bg-blue-950/70 hover:bg-blue-950/80 border-2 border-blue-200/20 text-base px-3 py-1.5 select-none"
    }

    if (variant === "sparkle") {
      variantClass = cn(variantClass, "text-[11px] sm:text-xs")
    }

    if (variant === "ghost") {
      variantClass = "bg-transparent border-2 border-transparent px-2 py-1"
    }

    if (variant === "destructive") {
      variantClass = "bg-red-600 text-white shadow-sm hover:bg-red-700"
    }

    if (asChild && React.isValidElement(children)) {
      // Type assertion to HTMLButtonElement
      return React.cloneElement(children as ReactElement<ButtonProps>, {
        ariaLabel,
        onClick,
        className: cn(baseButtonClass, sizeClass, variantClass, className),
        style: style || buttonStyle,
        disabled,
        type,
      })
    }

    return (
      <button
        ref={ref}
        id={id}
        role={role}
        formAction={formAction}
        aria-label={ariaLabel}
        disabled={disabled}
        type={type}
        onClick={onClick}
        className={cn(baseButtonClass, variantClass, sizeClass, className)}
        style={style || buttonStyle}
      >
        {variant === "sparkle" && <SparklesIcon className="w-4 h-4 text-amber-200" />}
        {children}
      </button>
    )
  }
)

Button.displayName = "Button"

export { Button }


/*
  File: components/ui/calendar.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/calendar.tsx
  Directory: components/ui
*/

--- File: components/ui/calendar.tsx ---

"use client"

import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({ className, classNames, showOutsideDays = true, ...props }: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(buttonVariants({ variant: "outline" }), "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell: "text-muted-foreground rounded-md w-8 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: cn(
          "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([aria-selected])]:bg-accent [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected].day-range-end)]:rounded-r-md",
          props.mode === "range"
            ? "[&:has(>.day-range-end)]:rounded-r-md [&:has(>.day-range-start)]:rounded-l-md first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md"
            : "[&:has([aria-selected])]:rounded-md"
        ),
        day: cn(buttonVariants({ variant: "ghost" }), "h-8 w-8 p-0 font-normal aria-selected:opacity-100"),
        day_range_start: "day-range-start",
        day_range_end: "day-range-end",
        day_selected: "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside: "day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle: "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => <ChevronLeft className={cn("h-4 w-4", className)} {...props} />,
        IconRight: ({ className, ...props }) => <ChevronRight className={cn("h-4 w-4", className)} {...props} />,
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }


/*
  File: components/ui/card.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/card.tsx
  Directory: components/ui
*/

--- File: components/ui/card.tsx ---

import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="card" className={cn("bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-xs", className)} {...props} />
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="card-header" className={cn("flex flex-col gap-1.5 px-6", className)} {...props} />
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="card-title" className={cn("leading-none font-semibold", className)} {...props} />
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="card-description" className={cn("text-muted-foreground text-sm", className)} {...props} />
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="card-content" className={cn("px-6 grow", className)} {...props} />
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="card-footer" className={cn("flex items-center px-6", className)} {...props} />
}

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }


/*
  File: components/ui/checkbox.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/checkbox.tsx
  Directory: components/ui
*/

--- File: components/ui/checkbox.tsx ---

"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-2xs transition-shadow outline-hidden focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }


/*
  File: components/ui/collapsible.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/collapsible.tsx
  Directory: components/ui
*/

--- File: components/ui/collapsible.tsx ---

"use client"

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

function Collapsible({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.Root>) {
  return <CollapsiblePrimitive.Root data-slot="collapsible" {...props} />
}

function CollapsibleTrigger({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleTrigger>) {
  return (
    <CollapsiblePrimitive.CollapsibleTrigger
      data-slot="collapsible-trigger"
      {...props}
    />
  )
}

function CollapsibleContent({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleContent>) {
  return (
    <CollapsiblePrimitive.CollapsibleContent
      data-slot="collapsible-content"
      {...props}
    />
  )
}

export { Collapsible, CollapsibleTrigger, CollapsibleContent }


/*
  File: components/ui/container.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/container.tsx
  Directory: components/ui
*/

--- File: components/ui/container.tsx ---

import { cn } from "@/lib/utils"

export function Container({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
  return <div className={cn("mx-auto w-full max-w-7xl px-6 lg:px-8", className)} {...props} />
}


/*
  File: components/ui/copy-oneliner.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/copy-oneliner.tsx
  Directory: components/ui
*/

--- File: components/ui/copy-oneliner.tsx ---

"use client"
import { Copy, Terminal } from "lucide-react"
import { cn } from "@/lib/utils"
import { useState } from "react"
import { Check } from "lucide-react"

interface CopyOnelinerProps {
  children: string
  className?: string
  iconClassName?: string
}

export function CopyOneliner({ children, className, iconClassName }: CopyOnelinerProps) {
  const [copied, setCopied] = useState(false)

  const copyToClipboard = async () => {
    try {
      await navigator.clipboard.writeText(children)
      setCopied(true)
      setTimeout(() => setCopied(false), 2000)
    } catch (err) {
      console.error("Failed to copy text: ", err)
    }
  }

  return (
    <div onClick={copyToClipboard} className={cn("relative text-sm py-3 px-3 flex items-center gap-2 rounded-md border text-left mx-auto -mt-4 font-mono", "cursor-pointer", className)}>
      <Terminal className={cn("w-4 h-4 opacity-50", iconClassName)} />
      <div className="flex-1">{children}</div>
      {copied ? <Check className="w-5 h-5 mr-1 scale-125 text-green-600" /> : <Copy className="w-5 h-5 mr-1 opacity-50" />}
    </div>
  )
}


/*
  File: components/ui/copy-to-clipboard.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/copy-to-clipboard.tsx
  Directory: components/ui
*/

--- File: components/ui/copy-to-clipboard.tsx ---

"use client"

import { useState } from "react"
import { cn } from "@/lib/utils"
import { Check, Copy } from "lucide-react"

interface CopyToClipboardProps {
  children: string
  className?: string
  iconClassName?: string
  timeout?: number
  position?: "top-right" | "top-left" | "bottom-right" | "bottom-left"
  hideContent?: boolean
}

const positionClasses = {
  "top-right": "right-5 top-5",
  "top-left": "left-5 top-5",
  "bottom-right": "right-5 bottom-5",
  "bottom-left": "left-5 bottom-5",
}

export function CopyToClipboard({ children, className, iconClassName, timeout = 1000, position = "top-right", hideContent = false }: CopyToClipboardProps) {
  const [copied, setCopiedState] = useState(false)

  const handleCopy = () => {
    if (copied) return
    navigator.clipboard.writeText(children)
    setCopiedState(true)
    setTimeout(() => {
      setCopiedState(false)
    }, timeout)
  }

  return (
    <>
      <button
        className={cn("absolute p-1.5 border dark:border-neutral-800 rounded-md z-[2] backdrop-blur-2xl cursor-pointer", positionClasses[position], copied && "text-green-500", className)}
        onClick={handleCopy}
      >
        {copied ? <Check className={cn("w-4.5 h-4.5 scale-110", iconClassName)} /> : <Copy className={cn("w-4.5 h-4.5", iconClassName)} />}
      </button>
      {!hideContent && children}
    </>
  )
}


/*
  File: components/ui/date-picker.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/date-picker.tsx
  Directory: components/ui
*/

--- File: components/ui/date-picker.tsx ---

"use client"

import * as React from "react"
import { format } from "date-fns"
import { Calendar as CalendarIcon } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Calendar } from "@/components/ui/calendar"
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover"

interface DatePickerProps {
  date: Date | undefined
  setDate: (date: Date | undefined) => void
  label?: string
  className?: string
}

export function DatePicker({ date, setDate, label = "Pick a date", className }: DatePickerProps) {
  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button variant={"outline"} className={cn("w-full justify-start text-left font-normal", !date && "text-muted-foreground", className)}>
          <CalendarIcon className="mr-2 h-4 w-4" />
          {date ? format(date, "PPP") : <span>{label}</span>}
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-auto p-0" align="start">
        <Calendar mode="single" selected={date} onSelect={setDate} initialFocus />
      </PopoverContent>
    </Popover>
  )
}

export function DateRangePicker({
  startDate,
  endDate,
  setStartDate,
  setEndDate,
  startLabel = "Start date",
  endLabel = "End date",
  className,
}: {
  startDate: Date | undefined
  endDate: Date | undefined
  setStartDate: (date: Date | undefined) => void
  setEndDate: (date: Date | undefined) => void
  startLabel?: string
  endLabel?: string
  className?: string
}) {
  return (
    <div className={cn("flex flex-col space-y-2 sm:flex-row sm:space-x-2 sm:space-y-0", className)}>
      <DatePicker date={startDate} setDate={setStartDate} label={startLabel} className="flex-1" />
      <DatePicker date={endDate} setDate={setEndDate} label={endLabel} className="flex-1" />
    </div>
  )
}


/*
  File: components/ui/dialog.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/dialog.tsx
  Directory: components/ui
*/

--- File: components/ui/dialog.tsx ---

"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/80",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}


/*
  File: components/ui/dice-roll.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/dice-roll.tsx
  Directory: components/ui
*/

--- File: components/ui/dice-roll.tsx ---

"use client"
import React, { useState, useRef } from "react"
import { Button } from "./button"
import Image from "next/image"
import { cn, rollD20 } from "@/lib/utils"
import { textShadow } from "../typography/styles"
import DiceRollResult from "@/components/adventure/dice-roll-result"

const ROLL_ANIMATION_DURATION = 1200 // ms
const ROLL_ANIMATION_INTERVAL = 60 // ms

export default function DiceRoll({
  className,
  icon = "/images/app/dice/d20.svg",
  iconSize = 42,
  id,
  onRoll,
}: {
  className?: string
  icon?: string
  iconSize?: number
  id?: string
  onRoll?: (result: number) => void
}) {
  const [rolling, setRolling] = useState(false)
  const [result, setResult] = useState<number | null>(null)
  const [display, setDisplay] = useState<number | null>(null)
  const intervalRef = useRef<NodeJS.Timeout | null>(null)

  const handleRoll = () => {
    setRolling(true)
    setResult(null)
    let elapsed = 0
    intervalRef.current = setInterval(() => {
      const animRoll = rollD20()
      setDisplay(animRoll)
      elapsed += ROLL_ANIMATION_INTERVAL
      if (elapsed >= ROLL_ANIMATION_DURATION) {
        if (intervalRef.current) clearInterval(intervalRef.current)
        const final = rollD20()
        setDisplay(final)
        setResult(final)
        setRolling(false)
        if (onRoll) {
          onRoll(final)
        }
      }
    }, ROLL_ANIMATION_INTERVAL)
  }

  // Clean up interval on unmount
  React.useEffect(() => {
    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current)
    }
  }, [])

  if (result !== null) {
    return <DiceRollResult result={result} />
  }

  return (
    <Button
      ariaLabel="Roll D20"
      className={cn(
        "group text-2xl brightness-125 contrast-150 font-display flex gap-[7px] justify-center items-center pt-[2px] pb-0 px-3 bg-blue-600 rounded-full ring-4 ring-blue-800 border border-blue-400/50 transition-all ease-in-out duration-500 bg-[url('/images/app/backgrounds/buried.png')]",
        className,
        rolling && "pointer-events-none"
      )}
      id={id}
      onClick={handleRoll}
    >
      <span style={textShadow} className="pt-[2px]">
        Roll
      </span>
      <Image
        style={{ transform: rolling ? "rotate(720deg)" : undefined, transition: "transform 1.2s cubic-bezier(.22,1,.36,1)" }}
        className="inline-block border border-[rgba(255,255,255,.33)] ring-4 ring-blue-600 group-disabled:ring-gray-600 shadow-inner shadow-black rounded-full overflow-hidden p-[2px] transition-all ease-in-out delay-100 duration-[2s]"
        src={icon}
        width={iconSize}
        height={iconSize}
        alt=""
      />
      <span style={textShadow} className="pt-[2px] w-16 text-center">
        {rolling ? (display ?? "") : "D20"}
      </span>
    </Button>
  )
}


/*
  File: components/ui/dropdown-menu.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/dropdown-menu.tsx
  Directory: components/ui
*/

--- File: components/ui/dropdown-menu.tsx ---

"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive-foreground data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/40 data-[variant=destructive]:focus:text-destructive-foreground [svg]:*:data-[variant=destructive]:text-destructive-foreground! [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-disabled:pointer-events-none data-disabled:opacity-50 data-inset:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-disabled:pointer-events-none data-disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-disabled:pointer-events-none data-disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-inset:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-inset:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}


/*
  File: components/ui/image-header.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/image-header.tsx
  Directory: components/ui
*/

--- File: components/ui/image-header.tsx ---

import React, { useState } from "react"
import Image from "next/image"
import Parchment from "@/components/graphics/background/Parchment"
import { textShadow, textShadowSpread } from "../typography/styles"

interface ImageHeaderProps {
  imageUrl: string
  title?: string
  subtitle?: string
  overlayContent?: React.ReactNode
  imageAlt?: string
}

export default function ImageHeader({ imageUrl, title, subtitle, imageAlt }: ImageHeaderProps) {
  const [imageLoaded, setImageLoaded] = useState(false)

  return (
    <>
      <div className="absolute top-12 sm:top-12 left-0 right-0 w-full aspect-video min-h-[480px]">
        <Image
          className={`object-cover rounded-lg shadow-lg transition-opacity duration-1000 ease-in-out ${imageLoaded ? "opacity-100" : "opacity-0"}`}
          fill
          src={imageUrl}
          alt={imageAlt || title || ""}
          onLoad={() => setImageLoaded(true)}
        />
        {title && (
          <h2 className="text-2xl sm:text-4xl md:text-5xl font-display text-center w-full absolute bottom-44 sm:bottom-54 px-4" style={textShadowSpread}>
            {title}
          </h2>
        )}
        <div className="absolute bottom-32 sm:bottom-36 left-0 right-0 flex justify-center">
          {subtitle && (
            <h3 className="relative border border-white/20 rounded-sm bg-gradient-to-t from-amber-950 via-amber-950 to-amber-800 font-display sm:text-lg md:text-xl font-bold px-6 sm:px-8 py-1 sm:py-2 ring-4 sm:ring-8 ring-black z-[11] contrast-[1.2] saturate-[.4]">
              <Parchment />
              <span style={textShadow}>{subtitle}</span>
            </h3>
          )}
        </div>
        <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black to-transparent h-1/3 rounded-b-lg" />
        <div className="absolute bottom-6 sm:bottom-12 left-0 right-0 w-full h-32 bg-gradient-to-b from-black/50 to-transparent"></div>
        <div className="absolute bottom-36 sm:bottom-42 left-0 right-0 w-full h-[1px] bg-blend-lighten -mb-px overflow-hidden opacity-50 bg-[url('/images/app/art/texture-line.png')]" />
      </div>
      <div className="w-full aspect-video -mb-16 -mb-12 min-h-[480px]" />
    </>
  )
}


/*
  File: components/ui/image-upload.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/image-upload.tsx
  Directory: components/ui
*/

--- File: components/ui/image-upload.tsx ---

"use client"

import { useCallback, useState } from "react"
import { Button } from "@/components/ui/button"
import { ImagePlus, X } from "lucide-react"
import Image from "next/image"
import { toast } from "sonner"
import { useFileUpload } from "@/lib/upload-utils"

interface ImageUploadProps {
  value: string
  onChange: (url: string) => void
  onRemove: () => void
  folder?: string
  id?: string
}

export function ImageUpload({ id, value, onChange, onRemove, folder = "uploads" }: ImageUploadProps) {
  const [isUploading, setIsUploading] = useState(false)
  const { upload } = useFileUpload({
    folder,
    allowedTypes: ["image/jpeg", "image/png", "image/webp", "image/gif"],
  })

  const handleUpload = useCallback(
    async (e: React.ChangeEvent<HTMLInputElement>) => {
      try {
        const file = e.target.files?.[0]
        if (!file) return

        setIsUploading(true)
        const imageUrl = await upload(file)
        onChange(imageUrl)
        toast.success("Image uploaded successfully!")
      } catch (error) {
        console.error("Error uploading image:", error)
        toast.error(error instanceof Error ? error.message : "Failed to upload image")
      } finally {
        setIsUploading(false)
      }
    },
    [onChange, upload]
  )

  return (
    <div className="flex flex-col items-center gap-4">
      <div className="relative aspect-video w-full overflow-hidden rounded-lg border border-border">
        {value ? (
          <>
            <Image src={value} alt="Project Cover" fill className="object-cover" />
            <Button variant="destructive" size="icon" className="absolute right-2 top-2" onClick={onRemove}>
              <X className="h-4 w-4" />
            </Button>
          </>
        ) : (
          <label className="flex h-full w-full cursor-pointer items-center justify-center bg-muted">
            <div className="flex flex-col items-center gap-2">
              <ImagePlus className="h-8 w-8 text-muted-foreground" />
              <span className="text-sm text-muted-foreground">Upload Cover Image</span>
            </div>
            <input id={id} type="file" accept="image/*" className="hidden" onChange={handleUpload} disabled={isUploading} />
          </label>
        )}
      </div>
    </div>
  )
}


/*
  File: components/ui/input.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/input.tsx
  Directory: components/ui
*/

--- File: components/ui/input.tsx ---

import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "border-input file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-2xs transition-[color,box-shadow] outline-hidden file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }


/*
  File: components/ui/label.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/label.tsx
  Directory: components/ui
*/

--- File: components/ui/label.tsx ---

"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }


/*
  File: components/ui/loading-animation.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/loading-animation.tsx
  Directory: components/ui
*/

--- File: components/ui/loading-animation.tsx ---

"use client"
import React, { useEffect, useRef } from "react"
import Image from "next/image"
import AnimateIn from "./animate-in"
import { cn } from "@/lib/utils"

const spin = `@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  80% {
    transform: rotate(360deg);
  }
  99.99% {
    transform: rotate(360deg);
  }
}`

const LoadingAnimation = ({ className, children, containerClassName }: { className?: string; containerClassName?: string; children?: React.ReactNode }) => {
  const containerRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    containerRef.current?.scrollIntoView({ behavior: "smooth", block: "center" })
  }, [])

  return (
    <div ref={containerRef} className={cn("flex flex-col items-center justify-center gap-2", containerClassName)}>
      <AnimateIn from="opacity-0 scale-0" to="opacity-50 scale-50" duration={1000} className={cn("w-full flex justify-center", className)}>
        <style>{spin}</style>
        <Image
          className="inline-block p-4 border-2 bg-black/90 border-indigo-400 rounded-full overflow-hidden transition-all ease-in-out animate-spin"
          src="/images/d20-white.svg"
          width={96}
          height={96}
          alt="Loading"
          style={{ animation: "spin 2s infinite ease-in-out" }}
        />
      </AnimateIn>
      {children && (
        <AnimateIn className="font-mono" style={{ textShadow: "0 2px 4px #000, 0 2px 16px #000" }} from="opacity-0" to="opacity-80" delay={1000}>
          {children}
        </AnimateIn>
      )}
    </div>
  )
}

export default LoadingAnimation


/*
  File: components/ui/popover.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/popover.tsx
  Directory: components/ui
*/

--- File: components/ui/popover.tsx ---

"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  )
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }


/*
  File: components/ui/progress.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/progress.tsx
  Directory: components/ui
*/

--- File: components/ui/progress.tsx ---

"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

function Progress({
  className,
  value,
  ...props
}: React.ComponentProps<typeof ProgressPrimitive.Root>) {
  return (
    <ProgressPrimitive.Root
      data-slot="progress"
      className={cn(
        "bg-primary/20 relative h-2 w-full overflow-hidden rounded-full",
        className
      )}
      {...props}
    >
      <ProgressPrimitive.Indicator
        data-slot="progress-indicator"
        className="bg-primary h-full w-full flex-1 transition-all"
        style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
      />
    </ProgressPrimitive.Root>
  )
}

export { Progress }


/*
  File: components/ui/radio-group.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/radio-group.tsx
  Directory: components/ui
*/

--- File: components/ui/radio-group.tsx ---

"use client"

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function RadioGroup({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Root>) {
  return (
    <RadioGroupPrimitive.Root
      data-slot="radio-group"
      className={cn("grid gap-3", className)}
      {...props}
    />
  )
}

function RadioGroupItem({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Item>) {
  return (
    <RadioGroupPrimitive.Item
      data-slot="radio-group-item"
      className={cn(
        "border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive aspect-square size-4 shrink-0 rounded-full border shadow-2xs transition-[color,box-shadow] outline-hidden focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator
        data-slot="radio-group-indicator"
        className="relative flex items-center justify-center"
      >
        <CircleIcon className="fill-primary absolute top-1/2 left-1/2 size-2 -translate-x-1/2 -translate-y-1/2" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
}

export { RadioGroup, RadioGroupItem }


/*
  File: components/ui/roll-button.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/roll-button.tsx
  Directory: components/ui
*/

--- File: components/ui/roll-button.tsx ---

"use client"
import React, { useState } from "react"
import { Button } from "./button"
import Image from "next/image"
import { cn } from "@/lib/utils"

const RollButton = ({
  className,
  onClick,
  isReroll,
  text1,
  text2,
  disabled,
  icon = "/images/app/dice/d20.svg",
  iconSize = 42,
  id,
}: {
  className?: string
  onClick: () => void
  isReroll?: boolean
  text1?: string
  text2?: string
  disabled?: boolean
  icon?: string
  iconSize?: number
  id?: string
}) => {
  const [count, setCount] = useState(0)

  const clickHandler = () => {
    setCount(count + 1)
    onClick()
  }

  return (
    <Button
      ariaLabel="Roll"
      className={cn(
        "group text-2xl brightness-125 contrast-150 font-display flex gap-[7px] justify-center items-center pt-[2px] pb-0 px-3 bg-blue-600 rounded-full ring-4 ring-blue-800 disabled:ring-gray-800 border border-blue-400/50 disabled:border-gray-400/50 transition-all ease-in-out duration-500 bg-[url('/images/app/backgrounds/buried.png')]",
        className
      )}
      id={id}
      onClick={clickHandler}
      disabled={disabled}
    >
      <span className="pt-[2px]">{text1 ? text1 : isReroll ? "re" : "Roll"}</span>
      <Image
        style={{ transform: `rotate(${count * 360}deg)` }}
        className="inline-block border border-[rgba(255,255,255,.33)] ring-4 ring-blue-600 group-disabled:ring-gray-600 shadow-inner shadow-black rounded-full overflow-hidden p-[2px] transition-all ease-in-out delay-100 duration-[2s]"
        src={icon}
        width={iconSize}
        height={iconSize}
        alt=""
      />
      <span className="pt-[2px]">{text2 ? text2 : isReroll ? "roll" : "D20"}</span>
    </Button>
  )
}

export default RollButton


/*
  File: components/ui/scroll-area.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/scroll-area.tsx
  Directory: components/ui
*/

--- File: components/ui/scroll-area.tsx ---

"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }


/*
  File: components/ui/select.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/select.tsx
  Directory: components/ui
*/

--- File: components/ui/select.tsx ---

"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger>) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive flex h-9 w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("px-2 py-1.5 text-sm font-medium", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}


/*
  File: components/ui/separator.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/separator.tsx
  Directory: components/ui
*/

--- File: components/ui/separator.tsx ---

"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }


/*
  File: components/ui/sheet.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/sheet.tsx
  Directory: components/ui
*/

--- File: components/ui/sheet.tsx ---

"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/80",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}


/*
  File: components/ui/sonner.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/sonner.tsx
  Directory: components/ui
*/

--- File: components/ui/sonner.tsx ---

"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground font-medium",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground font-medium",
        },
      }}
      {...props}
    />
  )
}

export { Toaster }


/*
  File: components/ui/switch.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/switch.tsx
  Directory: components/ui
*/

--- File: components/ui/switch.tsx ---

"use client"

import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }


/*
  File: components/ui/table.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/table.tsx
  Directory: components/ui
*/

--- File: components/ui/table.tsx ---

"use client"

import * as React from "react"

import { cn } from "@/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-muted-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}


/*
  File: components/ui/tabs.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/tabs.tsx
  Directory: components/ui
*/

--- File: components/ui/tabs.tsx ---

"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return <TabsPrimitive.Root data-slot="tabs" className={cn("flex flex-col gap-2", className)} {...props} />
}

function TabsList({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.List>) {
  return <TabsPrimitive.List data-slot="tabs-list" className={cn("bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-1", className)} {...props} />
}

function TabsTrigger({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring inline-flex flex-1 items-center justify-center gap-1.5 rounded-md px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-xs [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 cursor-pointer",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return <TabsPrimitive.Content data-slot="tabs-content" className={cn("flex-1 outline-hidden", className)} {...props} />
}

export { Tabs, TabsList, TabsTrigger, TabsContent }


/*
  File: components/ui/textarea.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/textarea.tsx
  Directory: components/ui
*/

--- File: components/ui/textarea.tsx ---

import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-white/70 placeholder:italic focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }


/*
  File: components/ui/utils.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/utils.ts
  Directory: components/ui
*/

--- File: components/ui/utils.ts ---

export function scrollToTop() {
  window.scrollTo({ top: 0, behavior: "smooth" })
}

export function scrollToBottom() {
  window.scrollTo({ top: document.body.scrollHeight, behavior: "smooth" })
}

/*
  File: components/views/adventure-home-content.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/views/adventure-home-content.tsx
  Directory: components/views
*/

--- File: components/views/adventure-home-content.tsx ---

"use client"

import React, { useEffect, useState } from "react"
import { IMAGE_HOST } from "@/lib/config"
import ImageHeader from "@/components/ui/image-header"
import { Adventure } from "@/types/adventure"
import Turn from "@/components/adventure/turn"
import { useTurn } from "@/lib/context/TurnContext"
import { useParams } from "next/navigation"

export const dynamic = "force-dynamic"

function AdventureHomeContent({ initialImage, adventure, teaser }: { initialImage: string; initialSubtitle: string; adventure: Adventure; teaser?: string }) {
  const { adventurePlanId, settingId } = useParams()
  const [image, setImage] = useState(initialImage)

  const turn = useTurn()

  useEffect(() => {
    console.log("[AdventureHomeContent] turn encounterId", turn?.encounterId)
    if (turn) {
      if (turn.encounterId) {
        setImage(`images/settings/${settingId}/${adventurePlanId}/${turn.encounterId}.png`)
      }
    }
  }, [turn?.encounterId])

  console.log("[AdventureHomeContent] turn title", turn?.title)

  return (
    <>
      <div className="flex flex-col items-center min-h-screen relative">
        <ImageHeader imageUrl={`${IMAGE_HOST}/${image}`} title={adventure.title} subtitle={turn?.title} imageAlt={turn?.title || adventure.title} />
        {turn ? (
          <Turn />
        ) : (
          <div className="grow max-w-2xl fade-in">
            <p className="text-sm sm:text-base md:text-lg whitespace-pre-line">{teaser}</p>
          </div>
        )}
      </div>
    </>
  )
}

export default AdventureHomeContent


/*
  File: components/views/adventure-home.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/views/adventure-home.tsx
  Directory: components/views
*/

--- File: components/views/adventure-home.tsx ---

"use client"

import React, { useEffect } from "react"
import { Adventure } from "@/types/adventure"
import type { Turn as TurnType } from "@/types/adventure"
import { TurnProvider } from "@/lib/context/TurnContext"
import { AdventureProvider } from "@/lib/context/AdventureContext"
import AdventureHomeContent from "@/components/views/adventure-home-content"

export const dynamic = "force-dynamic"

function AdventureHome({
  adventurePlanId,
  settingId,
  adventure,
  encounterImage,
  teaser,
  currentTurn,
}: {
  adventurePlanId: string
  settingId: string
  adventure: Adventure
  teaser?: string
  encounterImage: string
  currentTurn: TurnType | null
}) {
  useEffect(() => {
    console.log("[AdventureHome]", JSON.stringify({ currentTurn, encounterImage }, null, 2))
    console.log("[AdventureHome]", JSON.stringify({ currentTurn, encounterImage }, null, 2))
  }, [currentTurn?.id])

  return (
    <AdventureProvider settingId={settingId} adventurePlanId={adventurePlanId} adventure={adventure}>
      <TurnProvider adventureId={adventure?.id ?? ""} initialTurn={currentTurn}>
        <AdventureHomeContent initialImage={encounterImage} initialSubtitle={currentTurn?.title || ""} adventure={adventure} teaser={teaser} />
      </TurnProvider>
    </AdventureProvider>
  )
}

export default AdventureHome


/*
  File: components.json
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components.json
  Directory: .
*/

--- File: components.json ---

{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

/*
  File: convex/README.md
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/convex/README.md
  Directory: convex
*/

--- File: convex/README.md ---

# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// functions.js
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.functions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// functions.js
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get(id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.functions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.


/*
  File: convex/adventure.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/convex/adventure.ts
  Directory: convex
*/

--- File: convex/adventure.ts ---

import { query, mutation, action, internalMutation } from "./_generated/server";
import { v } from "convex/values";
import type { Doc, Id } from "./_generated/dataModel";

// Create a new adventure
export const createAdventure = mutation({
  args: {
    planId: v.string(),
    settingId: v.string(),
    ownerId: v.string(),
    playerIds: v.array(v.string()),
    title: v.string(),
    startedAt: v.number(),
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    const adventureId = await ctx.db.insert("adventures", {
      planId: args.planId,
      settingId: args.settingId,
      ownerId: args.ownerId,
      playerIds: args.playerIds,
      startedAt: args.startedAt,
      endedAt: undefined,
      currentTurnId: undefined,
      title: args.title,
      createdAt: now,
      updatedAt: now,
    });
    return adventureId;
  },
});

// Create a new turn for an adventure
export const createTurn = mutation({
  args: {
    adventureId: v.id("adventures"),
    encounterId: v.string(),
    title: v.string(),
    narrative: v.string(),
    characters: v.array(v.any()), // Should match character object
    order: v.number(),
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    const turnId = await ctx.db.insert("turns", {
      adventureId: args.adventureId,
      encounterId: args.encounterId,
      title: args.title,
      narrative: args.narrative,
      characters: args.characters,
      order: args.order,
      createdAt: now,
      updatedAt: now,
    });
    // Update adventure's currentTurnId
    await ctx.db.patch(args.adventureId, { currentTurnId: turnId, updatedAt: now });
    return turnId;
  },
});

// Update a turn (narrative or characters)
export const updateTurn = mutation({
  args: {
    turnId: v.id("turns"),
    narrative: v.optional(v.string()),
    characters: v.optional(v.array(v.any())),
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    const patch: Partial<Doc<"turns">> = { updatedAt: now };
    if (args.narrative !== undefined) patch.narrative = args.narrative;
    if (args.characters !== undefined) patch.characters = args.characters as Doc<"turns">["characters"];
    await ctx.db.patch(args.turnId, patch);
    return true;
  },
});

// Query: Get current adventure and its current turn
export const getCurrentAdventure = query({
  args: { adventureId: v.id("adventures"), refreshKey: v.optional(v.number()) },
  handler: async (ctx, args) => {
    const adventure = await ctx.db.get(args.adventureId);
    if (!adventure) return null;
    let currentTurn = null;
    if (adventure.currentTurnId) {
      currentTurn = await ctx.db.get(adventure.currentTurnId as Id<"turns">);
      console.log("[getCurrentAdventure] loaded currentTurn:", JSON.stringify(currentTurn, null, 2));
    } else {
      console.log("[getCurrentAdventure] No currentTurnId on adventure");
    }
    return { adventure, currentTurn };
  },
});

// Mutation: Get current adventure and process NPC turn if needed
export const getCurrentAdventureWithNpcProcessing = mutation({
  args: { adventureId: v.id("adventures"), refreshKey: v.optional(v.number()) },
  handler: async (ctx, args) => {
    const adventure = await ctx.db.get(args.adventureId);
    if (!adventure) return null;
    let currentTurn = null;
    if (adventure.currentTurnId) {
      currentTurn = await ctx.db.get(adventure.currentTurnId as Id<"turns">);
    } else {
      console.log("[getCurrentAdventureWithNpcProcessing] No currentTurnId on adventure");
    }
    return { adventure, currentTurn };
  },
});

export const createAdventureWithFirstTurn = mutation({
  args: {
    planId: v.string(),
    settingId: v.string(),
    ownerId: v.string(),
    playerIds: v.array(v.string()),
    title: v.string(),
    startedAt: v.number(),
    playerInput: v.string(),
    turn: v.object({
      encounterId: v.string(),
      title: v.string(),
      narrative: v.string(),
      characters: v.array(v.any()),
      order: v.number(),
    }),
    rollRequirement: v.optional(v.any()),
  },
  handler: async (ctx, args) => {
    console.log("[createAdventureWithFirstTurn] CALLED");
    const now = Date.now();
    const adventureId = await ctx.db.insert("adventures", {
      planId: args.planId,
      settingId: args.settingId,
      ownerId: args.ownerId,
      playerIds: args.playerIds,
      startedAt: args.startedAt,
      title: args.title,
      createdAt: now,
      updatedAt: now,
    });

    // --- Use rollRequirement from args, no AI calls here ---
    const turn = { ...args.turn };
    if (args.rollRequirement && turn.characters.length > 0) {
      const actor = turn.characters[0];
      turn.characters = turn.characters.map((c) =>
        c.id === actor.id
          ? {
              ...c,
              hasReplied: true,
              isComplete: !args.rollRequirement,
              rollRequired: args.rollRequirement || undefined,
              rollResult: undefined,
            }
          : c
      );
    }
    // Log just before insert
    console.log("[createAdventureWithFirstTurn] INSERT turn:", JSON.stringify(turn, null, 2));

    const turnId = await ctx.db.insert("turns", {
      adventureId,
      ...turn,
      createdAt: now,
      updatedAt: now,
    });
    await ctx.db.patch(adventureId, { currentTurnId: turnId, updatedAt: now });
    return { adventureId, turnId };
  },
});

// Action: AI rewrite of reply (no DB access)
export const aiRewriteReply = action({
  args: {
    characterName: v.string(),
    playerInput: v.string(),
    narrativeContext: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    // TODO: Call your AI service here (Google Gemini, etc.)
    // For now, just return the playerInput as a placeholder
    return args.playerInput;
  },
});

// Mutation: Submit reply (updates turn with AI result)
export const submitReply = mutation({
  args: {
    turnId: v.id("turns"),
    characterId: v.string(),
    narrativeAction: v.string(),
    rollRequirement: v.optional(v.any()),
  },
  handler: async (ctx, args) => {
    const turn = await ctx.db.get(args.turnId);
    if (!turn) throw new Error("Turn not found");
    const character = turn.characters.find((c) => c.id === args.characterId);
    if (!character) throw new Error("Character not found");
    const prev = turn.narrative || "";
    const narrative = prev ? `${prev}\n\n${args.narrativeAction}` : args.narrativeAction;

    // Use rollRequirement from args, do not call AI here!
    const updatedCharacters = turn.characters.map((c) =>
      c.id === args.characterId
        ? {
            ...c,
            hasReplied: true,
            isComplete: !args.rollRequirement,
            rollRequired: args.rollRequirement || undefined,
            rollResult: undefined,
          }
        : c
    );

    await ctx.db.patch(args.turnId, {
      narrative,
      characters: updatedCharacters,
    });
    return await ctx.db.get(args.turnId);
  },
});

// Internal query: Get a turn by ID
export const getTurnById = query({
  args: { turnId: v.id("turns") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.turnId);
  },
});

// Internal mutation: Patch a turn by ID
export const patchTurn = internalMutation({
  args: {
    turnId: v.id("turns"),
    patch: v.object({
      narrative: v.optional(v.string()),
      characters: v.optional(v.array(v.any())),
      updatedAt: v.optional(v.number()),
    }),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.turnId, args.patch);
    return true;
  },
});

// Action: Get encounter context (intro/instructions)
export const getEncounterContext = action({
  args: { encounterId: v.string() },
  handler: async () => {
    // TODO: Implement real logic to fetch encounter context
    // Placeholder
    return {
      intro: "Encounter intro goes here.",
      instructions: "Encounter instructions go here.",
    };
  },
});

// Public query: Get an adventure by ID
export const getAdventureById = query({
  args: { adventureId: v.id("adventures") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.adventureId);
  },
});

// Internal mutation: Patch an adventure by ID
export const patchAdventure = internalMutation({
  args: {
    adventureId: v.id("adventures"),
    patch: v.object({
      currentTurnId: v.optional(v.id("turns")),
      updatedAt: v.optional(v.number()),
      endedAt: v.optional(v.number()),
      // Add other fields as needed
    }),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.adventureId, args.patch);
    return true;
  },
});

/*
  File: convex/mailingList.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/convex/mailingList.ts
  Directory: convex
*/

--- File: convex/mailingList.ts ---

import { v } from "convex/values";
import { mutation, query } from "./_generated/server";
import { Doc } from "./_generated/dataModel";

// Types
export type MailingListSubscription = Doc<"mailing_list_subscriptions">;

// Queries
export const getSubscriptions = query({
  handler: async (ctx) => {
    try {
      return await ctx.db
        .query("mailing_list_subscriptions")
        .order("desc")
        .collect();
    } catch (error) {
      console.error("Error getting subscriptions:", error);
      throw error;
    }
  },
});

export const getSubscriptionByEmail = query({
  args: { email: v.string() },
  handler: async (ctx, args) => {
    try {
      return await ctx.db
        .query("mailing_list_subscriptions")
        .withIndex("by_email", (q) => q.eq("email", args.email))
        .first();
    } catch (error) {
      console.error("Error getting subscription by email:", error);
      throw error;
    }
  },
});

// Mutations
export const subscribe = mutation({
  args: {
    userId: v.string(),
    email: v.string(),
    name: v.optional(v.string()),
    preferences: v.optional(v.object({
      marketing: v.boolean(),
      updates: v.boolean(),
    })),
  },
  handler: async (ctx, args) => {
    try {
      // Check if email already exists
      const existing = await ctx.db
        .query("mailing_list_subscriptions")
        .withIndex("by_email", (q) => q.eq("email", args.email))
        .first();

      if (existing) {
        // If already subscribed, perhaps update their info or just return existing?
        // For a waitlist, re-subscribing might just confirm their interest.
        // Or, if they were unsubscribed, re-subscribe them.
        // For now, throwing error if active. If unsubscribed, allow re-subscribe.
        if (!existing.unsubscribedAt) {
          throw new Error("Email already subscribed");
        }
        // If they are re-subscribing after being unsubscribed:
        const now = Date.now();
        return await ctx.db.patch(existing._id, {
            name: args.name,
            preferences: args.preferences ?? { marketing: false, updates: false },
            unsubscribedAt: null, // Re-subscribe
            updatedAt: now,
            // Note: subscribedAt and createdAt remain from original subscription
        });
      }

      const now = Date.now();
      const subscription = {
        userId: args.userId,
        email: args.email,
        name: args.name,
        preferences: args.preferences ?? { marketing: false, updates: false }, // Default if not provided
        subscribedAt: now,
        unsubscribedAt: null,
        createdAt: now,
        updatedAt: now,
      };

      const id = await ctx.db.insert("mailing_list_subscriptions", subscription);
      return await ctx.db.get(id);
    } catch (error) {
      console.error("Error subscribing:", error);
      throw error;
    }
  },
});

export const unsubscribe = mutation({
  args: { 
    email: v.string(),
  },
  handler: async (ctx, args) => {
    try {
      console.log('[unsubscribe] Attempting to unsubscribe email:', args.email);
      const subscription = await ctx.db
        .query("mailing_list_subscriptions")
        .withIndex("by_email", (q) => q.eq("email", args.email))
        .first();
      console.log('[unsubscribe] Subscription found:', subscription);
      if (!subscription) {
        throw new Error("Subscription not found");
      }
      const now = Date.now();
      await ctx.db.patch(subscription._id, {
        unsubscribedAt: now,
        updatedAt: now,
      });
      return true;
    } catch (error) {
      console.error("Error unsubscribing:", error);
      throw error;
    }
  },
});

export const deleteSubscription = mutation({
  args: { id: v.id("mailing_list_subscriptions") },
  handler: async (ctx, args) => {
    await ctx.db.delete(args.id);
  },
}); 

/*
  File: convex/schema.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/convex/schema.ts
  Directory: convex
*/

--- File: convex/schema.ts ---

import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

// Define your schema
export default defineSchema({
  visits: defineTable({
    path: v.string(),
    userId: v.union(v.string(), v.null()),
    metadata: v.any(),
    createdAt: v.number(),
    updatedAt: v.number(),
  }).index("by_user", ["userId"])
    .index("by_path", ["path"])
    .index("by_created", ["createdAt"]),

  mailing_list_subscriptions: defineTable({
    userId: v.string(),
    email: v.string(),
    name: v.optional(v.string()),
    preferences: v.object({
      marketing: v.boolean(),
      updates: v.boolean(),
    }),
    subscribedAt: v.number(),
    unsubscribedAt: v.union(v.number(), v.null()),
    createdAt: v.number(),
    updatedAt: v.number(),
  }).index("by_email", ["email"])
    .index("by_user", ["userId"])
    .index("by_subscribed", ["subscribedAt"]),

  // Multiplayer Adventure Tables
  adventures: defineTable({
    planId: v.string(),
    settingId: v.string(),
    ownerId: v.string(),
    playerIds: v.array(v.string()),
    startedAt: v.number(),
    endedAt: v.optional(v.number()),
    currentTurnId: v.optional(v.id("turns")),
    title: v.string(),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_owner", ["ownerId"])
    .index("by_player", ["playerIds"])
    .index("by_started", ["startedAt"]),

  turns: defineTable({
    adventureId: v.id("adventures"),
    encounterId: v.string(),
    title: v.string(),
    narrative: v.string(),
    characters: v.array(
      v.object({
        id: v.string(),
        name: v.string(),
        type: v.string(), // "pc" | "npc"
        userId: v.optional(v.string()),
        initiative: v.number(),
        isComplete: v.boolean(),
        hasReplied: v.boolean(),
        rollRequired: v.optional(v.any()),
        rollResult: v.optional(v.number()),
        healthPercent: v.optional(v.number()),
        image: v.optional(v.string()),
        gender: v.optional(v.string()),
        race: v.optional(v.string()),
        archetype: v.optional(v.string()),
        // Added fields for AI/gameplay context
        appearance: v.optional(v.string()),
        background: v.optional(v.string()),
        behavior: v.optional(v.string()),
        motivation: v.optional(v.string()),
        personality: v.optional(v.string()),
        skills: v.optional(v.array(v.string())),
        equipment: v.optional(v.array(v.object({
          name: v.string(),
          description: v.optional(v.string()),
        }))),
        attributes: v.optional(
          v.object({
            strength: v.optional(v.number()),
            dexterity: v.optional(v.number()),
            constitution: v.optional(v.number()),
            intelligence: v.optional(v.number()),
            wisdom: v.optional(v.number()),
            charisma: v.optional(v.number()),
          })
        ),
        status: v.optional(v.string()),
      })
    ),
    order: v.number(),
    isFinalEncounter: v.optional(v.boolean()),
    createdAt: v.number(),
    updatedAt: v.optional(v.number()),
  })
    .index("by_adventure", ["adventureId"])
    .index("by_encounter", ["encounterId"]),

  userTokenLedger: defineTable({
    userId: v.string(), // Clerk User ID
    alltimeTokens: v.number(), // Total tokens ever granted or purchased by the user
    tokensRemaining: v.number(), // Current spendable balance
    lastTokenUpdate: v.optional(v.number()), // Timestamp of the last update to token fields
  }).index("by_userId", ["userId"]),

  tokenTransactionHistory: defineTable({
    userId: v.string(), // Clerk User ID, to link to userTokenLedger
    type: v.union( // Type of transaction
      v.literal("initial_grant"),
      v.literal("purchase"),
      v.literal("usage_generate_text"),
      v.literal("usage_generate_object"),
      v.literal("adjustment_manual") // For admin corrections or other types
    ),
    amount: v.number(), // Positive for additions (grants, purchases), negative for deductions (usage)
    timestamp: v.number(), // Timestamp of the transaction
    description: v.optional(v.string()), // Optional details about the transaction
    tokensRemainingAfterTransaction: v.optional(v.number()) // User's token balance after this transaction
  }).index("by_userId", ["userId"])
    .index("by_timestamp", ["timestamp"]),
}); 

/*
  File: convex/testing.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/convex/testing.ts
  Directory: convex
*/

--- File: convex/testing.ts ---

import { v } from "convex/values"
import { mutation, query } from "./_generated/server"

function isTestOrDevEnv() {
  return process.env.NODE_ENV === "test" || process.env.NODE_ENV === "development";
}

/**
 * Delete all documents from a table
 * This mutation should only be available in test environments
 */
export const deleteAll = mutation({
  args: { tableName: v.union(
    v.literal("visits"),
    v.literal("mailing_list_subscriptions"),
    v.literal("adventures"),
    v.literal("turns")
  ) },
  handler: async (ctx, args) => {
    if (!isTestOrDevEnv()) {
      throw new Error("This operation is only allowed in test or development environments");
    }
    const documents = await ctx.db.query(args.tableName).collect()
    for (const doc of documents) {
      await ctx.db.delete(doc._id)
    }
    return { success: true }
  },
})

/**
 * Count documents in a table
 * This query should only be available in test environments
 */
export const countDocuments = query({
  args: { tableName: v.union(v.literal("visits"), v.literal("mailing_list_subscriptions")) },
  handler: async (ctx, args) => {
    if (!isTestOrDevEnv()) {
      throw new Error("This operation is only allowed in test or development environments");
    }
    const documents = await ctx.db.query(args.tableName).collect()
    return documents.length
  },
})

/**
 * Seed test data for visits and mailing_list_subscriptions
 * This mutation should only be available in test environments
 */
export const seedTestData = mutation({
  args: {},
  handler: async (ctx) => {
    if (!isTestOrDevEnv()) {
      throw new Error("This operation is only allowed in test or development environments");
    }
    // Seed visits
    await ctx.db.insert("visits", {
      path: "/test-path",
      userId: "test-user",
      metadata: { test: true },
      createdAt: Date.now(),
      updatedAt: Date.now(),
    });
    // Seed mailing list subscriptions
    await ctx.db.insert("mailing_list_subscriptions", {
      userId: "test-user",
      email: "test@example.com",
      name: "Test User",
      preferences: { marketing: true, updates: true },
      subscribedAt: Date.now(),
      unsubscribedAt: null,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    });
    return { success: true };
  },
}); 

/*
  File: convex/testinternal.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/convex/testinternal.ts
  Directory: convex
*/

--- File: convex/testinternal.ts ---

import { internalAction } from "./_generated/server";
import { v } from "convex/values";

export const testInternal = internalAction({
  args: { foo: v.string() },
  handler: async (ctx, args) => {
    console.log("[testInternal] called with foo:", args.foo);
    return args.foo;
  },
}); 

/*
  File: convex/tsconfig.json
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/convex/tsconfig.json
  Directory: convex
*/

--- File: convex/tsconfig.json ---

{
  /* This TypeScript project config describes the environment that
   * Convex functions run in and is used to typecheck them.
   * You can modify it, but some settings required to use Convex.
   */
  "compilerOptions": {
    /* These settings are not required by Convex and can be modified. */
    "allowJs": true,
    "strict": true,
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "skipLibCheck": true,
    "allowSyntheticDefaultImports": true,

    /* These compiler options are required by Convex */
    "target": "ESNext",
    "lib": ["ES2021", "dom"],
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "isolatedModules": true,
    "noEmit": true
  },
  "include": ["./**/*"],
  "exclude": ["./_generated"]
}


/*
  File: convex/turns.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/convex/turns.ts
  Directory: convex
*/

--- File: convex/turns.ts ---

import { mutation } from "./_generated/server";
import { v } from "convex/values";

// Minimal mutation: create a new turn
export const createTurn = mutation({
  args: {
    adventureId: v.id("adventures"),
    encounterId: v.string(),
    title: v.string(),
    narrative: v.string(),
    characters: v.array(v.any()),
    order: v.number(),
    isFinalEncounter: v.optional(v.boolean()),
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    return await ctx.db.insert("turns", {
      adventureId: args.adventureId,
      encounterId: args.encounterId,
      title: args.title,
      narrative: args.narrative,
      characters: args.characters,
      order: args.order,
      isFinalEncounter: args.isFinalEncounter,
      createdAt: now,
      updatedAt: now,
    });
  },
});

// Minimal mutation: update a turn (patch)
export const updateTurn = mutation({
  args: {
    turnId: v.id("turns"),
    patch: v.object({
      narrative: v.optional(v.string()),
      characters: v.optional(v.array(v.any())),
      updatedAt: v.optional(v.number()),
    }),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.turnId, args.patch);
    return true;
  },
});

// Minimal mutation: patch adventure
export const patchAdventure = mutation({
  args: {
    adventureId: v.id("adventures"),
    patch: v.object({
      currentTurnId: v.optional(v.id("turns")),
      updatedAt: v.optional(v.number()),
      endedAt: v.optional(v.number()),
    }),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.adventureId, args.patch);
    return true;
  },
}); 

/*
  File: convex/userTokenManagement.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/convex/userTokenManagement.ts
  Directory: convex
*/

--- File: convex/userTokenManagement.ts ---

import { mutation, query } from "./_generated/server";
import { v } from "convex/values";

const INITIAL_TOKEN_GRANT = 10000; // Example: 10,000 tokens on signup

export const ensureUserTokenRecord = mutation({
  args: { userId: v.string() },
  handler: async (ctx, args) => {
    const existingRecord = await ctx.db
      .query("userTokenLedger")
      .withIndex("by_userId", (q) => q.eq("userId", args.userId))
      .unique();

    if (!existingRecord) {
      const now = Date.now();
      // Create the ledger entry
      const ledgerId = await ctx.db.insert("userTokenLedger", {
        userId: args.userId,
        alltimeTokens: INITIAL_TOKEN_GRANT,
        tokensRemaining: INITIAL_TOKEN_GRANT,
        lastTokenUpdate: now,
      });

      // Create the initial transaction history entry
      await ctx.db.insert("tokenTransactionHistory", {
        userId: args.userId,
        type: "initial_grant",
        amount: INITIAL_TOKEN_GRANT, // Positive for a grant
        timestamp: now,
        description: "Initial token grant upon account creation.",
        tokensRemainingAfterTransaction: INITIAL_TOKEN_GRANT,
      });

      return { 
        status: "created", 
        userId: args.userId,
        tokensRemaining: INITIAL_TOKEN_GRANT, 
        alltimeTokens: INITIAL_TOKEN_GRANT,
        ledgerId: ledgerId
      };
    }

    return { 
      status: "exists", 
      userId: args.userId, 
      tokensRemaining: existingRecord.tokensRemaining, 
      alltimeTokens: existingRecord.alltimeTokens ?? 0, // Handle case where it might be undefined due to migration
      ledgerId: existingRecord._id
    };
  },
});

export const decrementTokens = mutation({
  args: {
    userId: v.string(),
    tokensUsed: v.number(),
    transactionType: v.union(
      v.literal("usage_generate_text"),
      v.literal("usage_generate_object"),
      // Add other usage types as needed
    ),
    description: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    if (args.tokensUsed <= 0) {
      // No actual cost, or invalid input
      // Optionally log this or return a specific status if needed
      return { success: true, message: "No tokens to decrement or invalid amount.", tokensRemaining: null };
    }

    const userLedger = await ctx.db
      .query("userTokenLedger")
      .withIndex("by_userId", (q) => q.eq("userId", args.userId))
      .unique();

    if (!userLedger) {
      throw new Error(`User token ledger not found for userId: ${args.userId}. Cannot decrement tokens.`);
    }

    if (userLedger.tokensRemaining < args.tokensUsed) {
      // Not enough tokens. Log this attempt if desired.
      // For now, just throw an error. You could also create a transaction history entry for the failed attempt.
      await ctx.db.insert("tokenTransactionHistory", {
        userId: args.userId,
        type: args.transactionType, 
        amount: -args.tokensUsed, // Record the attempted usage as negative
        timestamp: Date.now(),
        description: args.description ? `${args.description} (Failed - Insufficient tokens)` : `Attempted ${args.transactionType} (Failed - Insufficient tokens)`,
        tokensRemainingAfterTransaction: userLedger.tokensRemaining, // Balance before this failed attempt
      });
      throw new Error(
        `Insufficient tokens for userId: ${args.userId}. ` +
        `Required: ${args.tokensUsed}, Available: ${userLedger.tokensRemaining}.`
      );
    }

    const now = Date.now();
    const newTokensRemaining = userLedger.tokensRemaining - args.tokensUsed;

    await ctx.db.patch(userLedger._id, {
      tokensRemaining: newTokensRemaining,
      lastTokenUpdate: now,
    });

    await ctx.db.insert("tokenTransactionHistory", {
      userId: args.userId,
      type: args.transactionType,
      amount: -args.tokensUsed, // Negative for a deduction
      timestamp: now,
      description: args.description,
      tokensRemainingAfterTransaction: newTokensRemaining,
    });

    return { 
      success: true, 
      tokensRemaining: newTokensRemaining, 
      alltimeTokens: userLedger.alltimeTokens ?? 0 
    };
  },
});

export const getTokenBalance = query({
  args: { userId: v.string() },
  handler: async (ctx, args) => {
    // It's generally better for the calling server action to call ensureUserTokenRecord first.
    // However, if we want this query to be self-sufficient in ensuring a record exists:
    // await ctx.runMutation(api.userTokenManagement.ensureUserTokenRecord, { userId: args.userId });
    // For now, we'll assume ensureUserTokenRecord is called by the server action before this query.

    const userLedger = await ctx.db
      .query("userTokenLedger")
      .withIndex("by_userId", (q) => q.eq("userId", args.userId))
      .unique();

    if (!userLedger) {
      // This case should ideally be handled by ensureUserTokenRecord being called first.
      // If not, the user effectively has 0 tokens until their record is created.
      return { tokensRemaining: 0, alltimeTokens: 0, needsInitialization: true };
    }

    return {
      tokensRemaining: userLedger.tokensRemaining,
      // Handle case where alltimeTokens might be undefined due to schema migration
      alltimeTokens: userLedger.alltimeTokens ?? 0, 
      needsInitialization: false,
    };
  },
}); 

/*
  File: convex/utils.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/convex/utils.ts
  Directory: convex
*/

--- File: convex/utils.ts ---

import { v } from "convex/values";
import { MutationCtx, QueryCtx } from "./_generated/server";
import { Doc, Id } from "./_generated/dataModel";

// Type for successful responses
type SuccessResponse<T> = {
  success: true;
  data?: T;
  id?: Id<any>;
};

// Type for error responses
type ErrorResponse = {
  success: false;
  error: string;
};

// Combined response type
export type ConvexResponse<T = void> = SuccessResponse<T> | ErrorResponse;

// Helper to get current timestamp
export const getCurrentTimestamp = () => Date.now();

// Helper to create base fields for new documents
export const getBaseFields = () => ({
  createdAt: getCurrentTimestamp(),
  updatedAt: getCurrentTimestamp(),
});

// Helper to update timestamp
export const getUpdateFields = () => ({
  updatedAt: getCurrentTimestamp(),
});

// Helper for error handling
export const handleError = (error: unknown): ErrorResponse => ({
  success: false,
  error: error instanceof Error ? error.message : "Unknown error",
});

// Helper for success response
export const handleSuccess = <T>(data?: T, id?: Id<any>): SuccessResponse<T> => ({
  success: true,
  ...(data && { data }),
  ...(id && { id }),
});

// Validation helper
export const validateId = (id: Id<any>) => {
  if (!id) throw new Error("Invalid ID");
  return id;
};

// Query helper for pagination
export type PaginationOptions = {
  limit?: number;
  cursor?: string;
};

// Helper for handling pagination in queries
export const handlePagination = (
  ctx: QueryCtx,
  query: any,
  options?: PaginationOptions
) => {
  if (options?.limit) {
    query = query.take(options.limit);
  }
  if (options?.cursor) {
    query = query.continuePaginationFrom(options.cursor);
  }
  return query;
}; 

/*
  File: convex/visits.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/convex/visits.ts
  Directory: convex
*/

--- File: convex/visits.ts ---

import { v } from "convex/values";
import { mutation, query } from "./_generated/server";
import { Doc, Id } from "./_generated/dataModel";

// Schema is defined in schema.ts
export type Visit = {
  path: string;
  userId: string | null;
  metadata: Record<string, any>;
  createdAt: number;
  updatedAt: number;
};

export const recordVisit = mutation({
  args: {
    path: v.string(),
    userId: v.union(v.string(), v.null()),
    metadata: v.any(),
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    return await ctx.db.insert("visits", {
      path: args.path,
      userId: args.userId,
      metadata: args.metadata,
      createdAt: now,
      updatedAt: now,
    });
  },
});

export const getVisits = query({
  args: {
    userId: v.optional(v.union(v.string(), v.null())),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const query = args.userId !== undefined
      ? await ctx.db
          .query("visits")
          .withIndex("by_user", (q) => q.eq("userId", args.userId as string | null))
          .collect()
      : await ctx.db
          .query("visits")
          .withIndex("by_created")
          .collect();

    return args.limit !== undefined ? query.slice(0, args.limit) : query;
  },
});

export const getVisitsByPath = query({
  args: {
    path: v.string(),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const results = await ctx.db
      .query("visits")
      .withIndex("by_path", (q) => q.eq("path", args.path))
      .collect();

    return args.limit !== undefined ? results.slice(0, args.limit) : results;
  },
});

export const deleteVisit = mutation({
  args: { id: v.id("visits") },
  handler: async (ctx, args) => {
    await ctx.db.delete(args.id);
  },
}); 

/*
  File: data/demo.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/data/demo.ts
  Directory: data
*/

--- File: data/demo.ts ---

import { PCTemplate } from "../types/character";

export const thalbern: PCTemplate = {
  id: "thalbern-demo-1",
  type: "pc",
  name: "Thalbern",
  image: "/images/characters/demo-ranger.png",
  archetype: "Ranger",
  race: "Human",
  gender: "Male",
  appearance: "Lean, weathered, with sharp green eyes and long, tangled brown hair. Wears a cloak of forest hues and carries a longbow.",
  personality: "Solitary, cautious, loyal to those who earn his trust, and deeply connected to nature.",
  background: "Orphaned by border raiders, raised by elves in the Valkarr woods. Lives on the edge of Kordavos, guiding travelers and hunting for survival.",
  motivation: "To protect the Valkarr woods and its people from outside threats, and to find a place where he truly belongs.",
  behavior: "Prefers silence and observation, avoids city politics, acts decisively when the wilds are threatened.",
  healthPercent: 100,
  equipment: [
    { name: "Longbow", description: "A finely crafted elven bow, silent and deadly." },
    { name: "Quiver", description: "A quiver filled with arrows." },
    { name: "Sword", description: "A practical blade for close encounters." },
    { name: "Dagger", description: "A small blade for quick strikes." }
  ],
  skills: ["Stealth", "Tracking", "Archery", "Survival", "Nature Lore"],
  attributes: {
    strength: 13,
    dexterity: 17,
    constitution: 13,
    intelligence: 11,
    wisdom: 13,
    charisma: 10
  }
}; 

/*
  File: data/the-midnight-summons.json
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/data/the-midnight-summons.json
  Directory: data
*/

--- File: data/the-midnight-summons.json ---

{
  "id": "the-midnight-summons",
  "settingId": "realm-of-myr",
  "title": "The Midnight Summons",
  "author": "D20Adventures",
  "version": "1716220800",
  "teaser": "A mysterious summons from an old druid friend draws a reclusive ranger into the wilds of the Valkarr forest.",
  "overview": "Thalbern, a ranger of the Valkarr woods, is called upon by his old friend, the druid Wollandora, to meet him at the Old Standing Stones at midnight. The balance of the forest could depend on it.",
  "party": [1, 1],
  "tags": ["fantasy", "solo", "investigation", "forest", "mystery"],
  "image": "images/settings/realm-of-myr/the-midnight-summons/the-midnight-summons.png",
  "start": "broken-silence",
  "sections": [
    {
      "title": "Journey to the Standing Stones",
      "summary": "Thalbern receives an urgent message and ventures to meet the druid Wollandora, facing an unexpected danger along the way.",
      "scenes": [
        {
          "title": "Path Through The Dark Forest",
          "summary": "Thalbern answers Wollandora's call, navigating the dark forest towards the ancient meeting place.",
          "encounters": [
            {
              "id": "broken-silence",
              "title": "Broken Silence",
              "intro": "Thalbern, a solitary ranger of the Valkarr woods, has always trusted the silence of the wilds more than the promises of men. Orphaned by border raiders and raised by the elves of the Valkrarr Forest, he has spent years living on the edge of Kordavos, guiding travelers, hunting for his own survival, and keeping his distance from the tangled politics of the city.\n\nYet on this night, a message delivered by a red squirrel bearing the unmistakable script of Wollandora, a trusted elven friend and druid, has drawn him from his hidden home. The note was simple and urgent: Meet me at the Old Standing Stones at midnight. The balance of the forest could depend on it.\n\nNow, as midnight approaches, Thalbern moves quietly through the dense undergrowth, guided by memory and instinct. It is dark with almost no moonlight coming through the forest canopy.\n\nSuddenly, the hush of the night is broken by a sharp crack. Something large has just stepped on a branch somewhere off in the distance.",
              "instructions": "A perception check is appropriate if Thalbern investigates (low difficulty with a plus 3 modifier). If successful, he will determine it is a large creature that is approaching quickly. With a high roll (18+), he will determine it is an Owlbear. If combat ensues and Thalbern is below 25% health, Wollandora will intervene. If Thalbern avoids or defeats the Owlbear, or if Wollandora saves him, he proceeds to the Old Standing Stones.",
              "image": "images/settings/realm-of-myr/the-midnight-summons/broken-silence-2.png",
              "transitions": [
                {
                  "condition": "If Thalbern successfully uses stealth to evade and proceeds cautiously towards the Standing Stones, go to meeting-at-stones.",
                  "encounter": "meeting-at-stones"
                },
                {
                  "condition": "If Thalbern fails a perception check, advance to owlbear-confrontation.",
                  "encounter": "owlbear-confrontation"
                },
                {
                  "condition": "If Thalbern fails any dice roll (including stealth, perception, or any other check), advance to owlbear-confrontation.",
                  "encounter": "owlbear-confrontation"
                },
                {
                  "condition": "If Thalbern does NOT successfully use stealth to evade, go to owlbear-confrontation.",
                  "encounter": "owlbear-confrontation"
                },
                {
                  "condition": "If Thalbern does nothing or takes no action, go to owlbear-confrontation.",
                  "encounter": "owlbear-confrontation"
                },
                {
                  "condition": "If Thalbern has a healthPercent of less than 50%, go to wollandora-intervention.",
                  "encounter": "wollandora-intervention"
                }
              ]
            },
            {
              "id": "owlbear-confrontation",
              "title": "Owlbear Confrontation",
              "intro": "From the direction of the sound, a little bit of eye shine glints in the shadows of the tree line. A hulking fifteen foot tall monster with the body of a giant bear and the head of an owl. As it crashes out from the undergrowth, it lets out a guttural squawk, clearly agitated and territorial.",
              "instructions": "The Owlbear will attack. If Thalbern attempts an animal handling check (high difficulty) and succeeds, he can move past the Owlbear. If Thalbern wins initiative and attempts to hide, he can move past the Owlbear if he passes a medium difficulty stealth check. If Thalbern's health drops to a critical level, Wollandora appears and drives off the Owlbear, transitioning to 'wollandora-intervention'. If Thalbern defeats the Owlbear, describe his victory and transition to 'meeting-at-stones'.",
              "image": "images/settings/realm-of-myr/the-midnight-summons/owlbear-confrontation.png",
              "npc": [
                {
                  "id": "owlbear",
                  "behavior": "Aggressively attacks any perceived threat. Will fight until heavily wounded or driven off.",
                  "initialInitiative": 1
                }
              ],
              "transitions": [
                {
                  "condition": "Thalbern defeats the Owlbear, manages to evade it, successfully uses Animal Handling to pacify and move past it, or successfully rolls any other way to move past it.",
                  "encounter": "meeting-at-stones"
                },
                {
                  "condition": "Thalbern is reduced to critical health by the Owlbear.",
                  "encounter": "timely-rescue"
                }
              ]
            },
            {
              "id": "timely-rescue",
              "title": "Timely Rescue",
              "intro": "Just as the Owlbear is about to land a seemingly final blow, a shaft of silvery moonlight pierces the canopy. A calm, authoritative voice calls out, 'That's enough, beast of the wood!' Wollandora steps from the shadows, her staff glowing faintly. With a gesture and a word of power, she unleashes a wave of natural energy that stuns and drives the startled Owlbear back into the depths of the forest.",
              "instructions": "Wollandora quickly checks on Thalbern's condition. She'll offer a brief comment ('You look like you've seen better nights, ranger. Come, the stones are not far, and our business is urgent.'). She then leads him to the Standing Stones.",
              "image": "images/settings/realm-of-myr/the-midnight-summons/timely-rescue.png",
              "npc": [
                {
                  "id": "wollandora",
                  "behavior": "Protective of Thalbern, focused on getting to the meeting."
                }
              ],
              "transitions": [
                {
                  "condition": "Thalbern is able to go to the Standing Stones with Wollandora.",
                  "encounter": "meeting-at-stones"
                }
              ]
            },
            {
              "id": "meeting-at-stones",
              "title": "Meeting at the Stones",
              "intro": "Thalbern arrives at the ancient Standing Stones. The air is thick with anticipation as the moonlight bathes the clearing in a silvery glow.\n\n\"Thalbern, thank you for coming. The forest is grateful for your swiftness,\" Wollandora intones, her voice echoing softly in the stillness. The wise elf's silver hair glistens in the moonlight, and her eyes are a deep forest green, wise and kind, but currently troubled.",
              "instructions": "Write dialogue for Wollandora as she explains the situation. She should say: \"Thalbern, we have a problem. Someone has stolen Valkaran relics from the elves' vaults—items that should never leave these woods.\" She nods toward the river, where the current glides past the standing stones. \"I saw a river boat, Valkaran-made, loaded with crates, heading downstream to Kordavos earlier tonight. You must go to the city and investigate - find these relics before they disappear forever.\" Wollandora should NOT offer any transportation, boats, or assistance beyond information. She only provides the mission details and urges Thalbern to act. Thalbern can ask questions about the relics, the boat, or Kordavos. When ready, transition to 'preparing-for-the-city'.",
              "image": "images/settings/realm-of-myr/the-midnight-summons/meeting-at-the-stones.png",
              "skipInitialNpcTurns": true,
              "npc": [
                {
                  "id": "wollandora",
                  "behavior": "Protective of Thalbern, focused on getting to the meeting.",
                  "initialInitiative": 1
                }
              ],
              "transitions": [
                {
                  "condition": "If Thalbern accepts the mission.",
                  "encounter": "preparing-for-the-city"
                },
                {
                  "condition": "If Thalbern refuses the mission.",
                  "encounter": "preparing-for-the-city"
                },
                {
                  "condition": "If Thalbern has more questions and has not accepted or refused the mission, stay in the same encounter.",
                  "encounter": "meeting-at-stones"
                }
              ]
            },
            {
              "id": "preparing-for-the-city",
              "title": "Preparing for the City",
              "intro": "The following morning, bathed in the soft light of the forest, Thalbern is back at his secluded home. Wollandora's words from the previous night echo in his mind – the stolen relics, the suspicious shipment, the urgent need to investigate in Kordavos.\n\nThe city's tangled ways are far from the quiet paths he knows. Thalbern carefully packs a change of simple, unassuming clothes, ensuring his hunting bow and a quiver of arrows were discreetly bundled, alongside a smaller hand axe and knife. As the sun climbed higher, he left the quiet security of his forest home, turning his steps towards the distant, bustling spires of Kordavos, a place where his survival instincts would be tested in a different kind of wilderness.",
              "instructions": "",
              "image": "images/settings/realm-of-myr/the-midnight-summons/preparing-for-the-city.png",
              "notes": "This encounter serves as a narrative bridge and allows the player to make small, character-flavoring decisions before the next main section of the adventure."
            },
            {
              "id": "back-home",
              "title": "Back home",
              "intro": "The following morning, bathed in the soft light of the forest, Thalbern is back at his secluded home. Wollandora's words from the previous night echo in his mind – the stolen relics, the suspicious shipment, the urgent need to investigate in Kordavos.\n\nHe had turned down her request for his help.\n\nHad he made the right choice? He did not enjoy the city, but Wollandora’s claims of stolen relics were intriguing. Perhaps a trip to the city would prove tobe worth it.",
              "instructions": "",
              "image": "images/settings/realm-of-myr/the-midnight-summons/preparing-for-the-city.png",
              "notes": "This encounter serves as a narrative bridge and allows the player to make small, character-flavoring decisions before the next main section of the adventure."
            }
          ]
        }
      ]
    }
  ],
  "npcs": {
    "wollandora": {
      "id": "wollandora",
      "type": "npc",
      "name": "Wollandora",
      "archetype": "Druid",
      "race": "Elf",
      "gender": "Female",
      "appearance": "A wise elf with silver hair braided with leaves and twigs. Her eyes are a deep forest green, wise and kind, but currently troubled. She carries a staff of gnarled oak.",
      "personality": "Wise, patient, deeply connected to nature, fiercely protective of the forest balance.",
      "background": "An ancient guardian of the Valkarr woods, a friend to Thalbern, and a powerful druid.",
      "motivation": "Recover the stolen relics and restore balance to the forest. Protect the secrets of her people.",
      "behavior": "Generally calm and thoughtful. Will provide information and guidance. Can be firm when necessary.",
      "image": "/images/settings/realm-of-myr/the-midnight-summons/npcs/wollandora.png",
      "healthPercent": 100,
      "attributes": {
        "strength": 10,
        "dexterity": 12,
        "constitution": 12,
        "intelligence": 16,
        "wisdom": 18,
        "charisma": 14
      },
      "status": ""
    },
    "owlbear": {
      "id": "owlbear",
      "type": "npc",
      "name": "Owlbear",
      "archetype": "Monster",
      "race": "Owlbear",
      "appearance": "A hulking monstrosity with the body of a bear and the head of an owl. Thick, matted fur, razor-sharp talons, and a powerful beak. Its eyes glow with a feral intensity.",
      "personality": "Territorial, aggressive, primal.",
      "motivation": "Defend its territory, hunt for food.",
      "behavior": "Attacks perceived threats on sight. Fights with ferocity. Can be driven off by overwhelming force or a display of superior power.",
      "image": "/images/settings/realm-of-myr/the-midnight-summons/npcs/owlbear-portrait.png",
      "healthPercent": 100,
      "attributes": {},
      "status": ""
    }
  }
}

/*
  File: eslint.config.mjs
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/eslint.config.mjs
  Directory: .
*/

--- File: eslint.config.mjs ---

import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
  {
    ignores: [
      ".next/**/*",
      "test-results/**/*",
      "tests-examples/**/*",
      "tests/**/*",
      "coverage/**/*",
      "dist/**/*",
      "build/**/*",
      "**/node_modules/**/*",
      "**/*.min.js",
      "**/*.bundle.js"
    ],
    rules: {
      // Disable noisy rules
      "@typescript-eslint/no-this-alias": "off",
      "react-hooks/exhaustive-deps": "off",
      
      // Enable max-lines rule
      "max-lines": ["error", {
        max: 500,
        skipBlankLines: true,
        skipComments: true
      }]
    }
  }
];

export default eslintConfig;


/*
  File: lib/ai/index.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/ai/index.ts
  Directory: lib/ai
*/

--- File: lib/ai/index.ts ---

"use server"

import { generateObject as baseGenerateObject, streamObject as baseStreamObject, generateText as baseGenerateText } from "ai";
import { geminiModel } from "./llm";
import { auth } from "@clerk/nextjs/server"
import { z } from "zod";
import { decrementUserTokensAction } from "@/app/_actions/tokens";

// Helper function to wait for a specified number of milliseconds
function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Wrapper: uses geminiModel by default, but allows override
export async function generateObject<T extends z.ZodTypeAny>({prompt, schema}: { prompt: string; schema: T; }) {
  let result;
  try {
    console.log('Entering generateObject...');

    const { userId } = await auth()

    if (!userId) {
      throw new Error("User not authenticated");
    }

    result = await baseGenerateObject({
      prompt,
      schema,
      model: geminiModel,
    });

    console.log('generateObject raw result:', result);

    if (result.usage && result.usage.totalTokens > 0) {
      console.log('Token Usage (generateObject):', {
        promptTokens: result.usage.promptTokens,
        completionTokens: result.usage.completionTokens,
        totalTokens: result.usage.totalTokens,
        model: geminiModel.modelId
      });
      const tokenDecrementResult = await decrementUserTokensAction({
        tokensUsed: result.usage.totalTokens,
        transactionType: "usage_generate_object",
        modelId: geminiModel.modelId,
      });

      if (!tokenDecrementResult.success) {
        console.error("Token decrementation failed for generateObject:", tokenDecrementResult.error, tokenDecrementResult.details);
        let errorMessage = '';
        if (tokenDecrementResult.details instanceof Error) {
          errorMessage = tokenDecrementResult.details.message;
        }
        if (errorMessage.includes("Insufficient tokens")) {
          throw new Error(`Insufficient tokens for generateObject operation. Usage: ${result.usage.totalTokens}.`);
        }
        throw new Error("Failed to update token balance after generateObject operation.");
      }
    }

    return result;
  } catch (error) {
    console.warn('generateObject failed. Error details:', error);
    console.warn('Retrying generateObject in 2 seconds...');
    await sleep(2000);
    
    // Retry once
    try {
      result = await baseGenerateObject({
        prompt,
        schema,
        model: geminiModel,
      });

      console.log('generateObject (retry) raw result:', result);

      if (result.usage && result.usage.totalTokens > 0) {
        console.log('Token Usage (generateObject retry):', {
          promptTokens: result.usage.promptTokens,
          completionTokens: result.usage.completionTokens,
          totalTokens: result.usage.totalTokens,
          model: geminiModel.modelId
        });
        const tokenDecrementResultRetry = await decrementUserTokensAction({
          tokensUsed: result.usage.totalTokens,
          transactionType: "usage_generate_object",
          modelId: geminiModel.modelId,
        });

        if (!tokenDecrementResultRetry.success) {
          console.error("Token decrementation failed for generateObject (retry):", tokenDecrementResultRetry.error, tokenDecrementResultRetry.details);
          let errorMessage = '';
          if (tokenDecrementResultRetry.details instanceof Error) {
            errorMessage = tokenDecrementResultRetry.details.message;
          }
          if (errorMessage.includes("Insufficient tokens")) {
            throw new Error(`Insufficient tokens for generateObject operation (retry). Usage: ${result.usage.totalTokens}.`);
          }
          throw new Error("Failed to update token balance after generateObject operation (retry).");
        }
      }
      
      return result;
    } catch (retryError) {
      console.error('generateObject retry also failed. Error details:', retryError);
      throw retryError; // Re-throw the error from the retry attempt
    }
  }
}

// Wrapper for streamObject: uses geminiModel by default, but allows override
export async function streamObject<T extends z.ZodTypeAny>({prompt, schema}: { prompt: string; schema: T; }) {

  const { userId } = await auth()

  if (!userId) {
    throw new Error("User not authenticated");
  }

  return baseStreamObject({
    prompt,
    schema,
    model: geminiModel,
  });
}

// Wrapper for generateText: uses geminiModel by default, but allows override
export async function generateText({prompt}: { prompt: string; }) {
  let result;
  try {
    console.log('Entering generateText...');

    const { userId } = await auth()

    if (!userId) {
      throw new Error("User not authenticated");
    }

    result = await baseGenerateText({
      prompt,
      model: geminiModel,
    });

    console.log('generateText raw result:', result);

    if (result.usage && result.usage.totalTokens > 0) {
      console.log('Token Usage (generateText):', {
        promptTokens: result.usage.promptTokens,
        completionTokens: result.usage.completionTokens,
        totalTokens: result.usage.totalTokens,
        model: geminiModel.modelId
      });
      const tokenDecrementResult = await decrementUserTokensAction({
        tokensUsed: result.usage.totalTokens,
        transactionType: "usage_generate_text",
        modelId: geminiModel.modelId,
      });

      if (!tokenDecrementResult.success) {
        console.error("Token decrementation failed for generateText:", tokenDecrementResult.error, tokenDecrementResult.details);
        let errorMessage = '';
        if (tokenDecrementResult.details instanceof Error) {
          errorMessage = tokenDecrementResult.details.message;
        }
        if (errorMessage.includes("Insufficient tokens")) {
          throw new Error(`Insufficient tokens for generateText operation. Usage: ${result.usage.totalTokens}.`);
        }
        throw new Error("Failed to update token balance after generateText operation.");
      }
    }

    return result;
  } catch (error) {
    console.warn('generateText failed. Error details:', error);
    console.warn('Retrying generateText in 2 seconds...');
    await sleep(2000);
    
    // Retry once
    try {
      result = await baseGenerateText({
        prompt,
        model: geminiModel,
      });

      console.log('generateText (retry) raw result:', result);

      if (result.usage && result.usage.totalTokens > 0) {
        console.log('Token Usage (generateText retry):', {
          promptTokens: result.usage.promptTokens,
          completionTokens: result.usage.completionTokens,
          totalTokens: result.usage.totalTokens,
          model: geminiModel.modelId
        });
        const tokenDecrementResultRetry = await decrementUserTokensAction({
          tokensUsed: result.usage.totalTokens,
          transactionType: "usage_generate_text",
          modelId: geminiModel.modelId,
        });

        if (!tokenDecrementResultRetry.success) {
          console.error("Token decrementation failed for generateText (retry):", tokenDecrementResultRetry.error, tokenDecrementResultRetry.details);
          let errorMessage = '';
          if (tokenDecrementResultRetry.details instanceof Error) {
            errorMessage = tokenDecrementResultRetry.details.message;
          }
          if (errorMessage.includes("Insufficient tokens")) {
            throw new Error(`Insufficient tokens for generateText operation (retry). Usage: ${result.usage.totalTokens}.`);
          }
          throw new Error("Failed to update token balance after generateText operation (retry).");
        }
      }

      return result;
    } catch (retryError) {
      console.error('generateText retry also failed. Error details:', retryError);
      throw retryError; // Re-throw the error from the retry attempt
    }
  }
}

/*
  File: lib/ai/llm.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/ai/llm.ts
  Directory: lib/ai
*/

--- File: lib/ai/llm.ts ---

import { google } from "@ai-sdk/google";

const geminiModel = google('gemini-2.0-flash-lite');

export { geminiModel };


/*
  File: lib/auth-utils.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/auth-utils.ts
  Directory: lib
*/

--- File: lib/auth-utils.ts ---

import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";

export function isClerkConfigured(): boolean {
  return Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
}

export function isAdminConfigured(): boolean {
  return Boolean(process.env.ADMIN_USER_IDS);
}

export function isDev(): boolean {
  return process.env.NODE_ENV === "development";
}

/**
 * Checks if a user is an admin
 * @param userId - Optional user ID to check. If not provided, checks the current user.
 * @returns Promise<boolean> - True if the user is an admin, false otherwise
 */
export async function isAdmin(userId?: string): Promise<boolean> {
  try {
    // If userId is not provided, get the current user's ID
    let userIdToCheck = userId;
    
    if (!userIdToCheck) {
      const { userId: currentUserId } = await auth();
      userIdToCheck = currentUserId || undefined;
    }
    
    // If no user is authenticated, they're not an admin
    if (!userIdToCheck) {
      return false;
    }
    
    // Get the list of admin user IDs from environment variables
    const adminUserIds = process.env.ADMIN_USER_IDS?.split(",") || [];
    
    // Check if the user's ID is in the admin list
    return adminUserIds.includes(userIdToCheck);
  } catch (error) {
    console.error("Error checking admin status:", error);
    return false;
  }
}

/**
 * Checks if the provided user ID is an admin
 * @param userId - The user ID to check
 * @returns boolean - True if the user is an admin, false otherwise
 */
export function isUserAdmin(userId: string | null): boolean {
  if (!userId) {
    return false;
  }
  
  // Get the list of admin user IDs from environment variables
  const adminUserIds = process.env.ADMIN_USER_IDS?.split(",") || [];
  
  // Check if the provided user ID is in the admin list
  return adminUserIds.includes(userId);
}

export type AdminCheckResult = {
  isAdmin: boolean
  userId: string | null
  requiresSetup: boolean
}

export type AuthCheckResult = {
  isAuthenticated: boolean
  userId: string | null
}

/**
 * Checks if the user is authenticated
 * @returns The authentication status and user ID
 */
export async function checkAuth(): Promise<AuthCheckResult> {
  // Get the user's ID from Clerk
  const { userId } = await auth()

  return { 
    isAuthenticated: !!userId, 
    userId 
  }
}

/**
 * Checks if the current user is an admin and redirects if not
 * @returns The user ID if the user is an admin
 */
export async function requireAdmin(): Promise<AdminCheckResult> {
  // Get the user's ID from Clerk
  const { userId } = await auth()

  // If not authenticated, redirect to sign-in in production, return status in development
  if (!userId) {
    if (process.env.NODE_ENV === "production") {
      redirect("/sign-in")
    }
    return { isAdmin: false, userId: null, requiresSetup: false }
  }

  // Get the list of admin user IDs
  const adminUserIds = process.env.ADMIN_USER_IDS?.split(",") || []

  // In development, if no admin IDs are configured, return a special status
  if (process.env.NODE_ENV === "development" && (!adminUserIds.length || adminUserIds[0] === "")) {
    return { isAdmin: false, userId, requiresSetup: true }
  }

  // If the user is not an admin, redirect in production, return status in development
  if (!adminUserIds.includes(userId)) {
    if (process.env.NODE_ENV === "production") {
      redirect("/")
    }
    return { isAdmin: false, userId, requiresSetup: false }
  }

  return { isAdmin: true, userId, requiresSetup: false }
} 

/*
  File: lib/aws.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/aws.ts
  Directory: lib
*/

--- File: lib/aws.ts ---

import { S3Client } from "@aws-sdk/client-s3"

// Environment variables
const awsConfig = {
  region: process.env.AWS_REGION,
  accessKeyId: process.env.AWS_KEY,
  secretAccessKey: process.env.AWS_SECRET,
  bucketPublic: process.env.AWS_BUCKET_PUBLIC,
  cloudfrontDomain: process.env.CLOUDFRONT_DOMAIN,
}

export const AWS_BUCKET_PUBLIC = process.env.AWS_BUCKET_PUBLIC

// Log missing variables in development only
if (process.env.NODE_ENV === 'development') {
  const missingVars = Object.entries(awsConfig)
    .filter(([, value]) => !value)
    .map(([key]) => key)

  if (missingVars.length > 0) {
    console.warn('Missing AWS configuration variables:', missingVars)
  }
}

// Function to check if AWS is configured
export function isAwsConfigured(): boolean {
  return Boolean(
    awsConfig.region &&
    awsConfig.accessKeyId &&
    awsConfig.secretAccessKey &&
    awsConfig.bucketPublic
  )
}

// Create an S3 client if configured
export const s3Client = isAwsConfigured()
  ? new S3Client({
      region: awsConfig.region!,
      credentials: {
        accessKeyId: awsConfig.accessKeyId!,
        secretAccessKey: awsConfig.secretAccessKey!,
      },
    })
  : null

// Function to get asset URL
export function getAssetUrl(key: string, withTimestamp = false): string | null {
  if (!isAwsConfigured()) {
    return null
  }

  const timestamp = withTimestamp ? Date.now() : null
  const keyWithTimestamp = timestamp 
    ? (key.includes('?') ? `${key}&t=${timestamp}` : `${key}?t=${timestamp}`)
    : key

  if (awsConfig.cloudfrontDomain) {
    return `https://${awsConfig.cloudfrontDomain}/${keyWithTimestamp}`
  }

  // Fallback to direct S3 URL
  return `https://${awsConfig.bucketPublic}.s3.${awsConfig.region}.amazonaws.com/${keyWithTimestamp}`
}

// Function to check AWS connection
export async function checkAwsConnection(): Promise<{
  success: boolean
  message: string
  details?: {
    error?: unknown
  }
}> {
  if (!isAwsConfigured()) {
    return {
      success: false,
      message: 'AWS is not configured',
      details: {
        error: 'Missing required environment variables'
      }
    }
  }

  try {
    // Try to make a simple API call to verify connection
    await s3Client!.config.credentials()
    
    return {
      success: true,
      message: 'Successfully connected to AWS'
    }
  } catch (err) {
    console.error('Unexpected error checking AWS connection:', err)
    return {
      success: false,
      message: `Unexpected error: ${err instanceof Error ? err.message : String(err)}`,
      details: { error: err }
    }
  }
} 

/*
  File: lib/clerk.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/clerk.ts
  Directory: lib
*/

--- File: lib/clerk.ts ---

import { createClerkClient } from '@clerk/backend'

if (!process.env.CLERK_SECRET_KEY) {
  throw new Error('CLERK_SECRET_KEY is not defined')
}

export const clerkClient = createClerkClient({ 
  secretKey: process.env.CLERK_SECRET_KEY 
})

// Re-export commonly used types
export type { User } from '@clerk/backend' 

/*
  File: lib/config/navigation.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/config/navigation.ts
  Directory: lib/config
*/

--- File: lib/config/navigation.ts ---

export const navItems = [
  {
    title: "About",
    href: "/about",
  },
  {
    title: "Contact",
    href: "/contact",
  },
] as const

export type NavItem = (typeof navItems)[number] 

/*
  File: lib/config.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/config.ts
  Directory: lib
*/

--- File: lib/config.ts ---

export const IMAGE_HOST = "https://d1dkwd3w4hheqw.cloudfront.net";

export const siteConfig = {
  title: "D20 Adventures",
  description: "A new narrative-driven RPG platform that blends play-by-post gameplay and real-time updates facilitated by an AI Game Master.",
  shortDescription: "A new narrative-driven RPG platform that blends play-by-post gameplay and real-time updates facilitated by an AI Game Master.",
  url: "d20adventures.com",
  shareImage: "https://d20adventures.com/images/screenshot.png",
  x: "",
  github: "",
  logo: "",
  imageHost: IMAGE_HOST,
} as const

export type SiteConfig = {
    title: string
    description: string
    shortDescription: string
    url: string
    shareImage: string
    x: string
    github: string
    logo: string
    imageHost: string
}

/*
  File: lib/context/AdventureContext.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/context/AdventureContext.tsx
  Directory: lib/context
*/

--- File: lib/context/AdventureContext.tsx ---

import React, { createContext, useContext } from "react"
import type { Adventure } from "@/types/adventure"

type AdventureContextType = {
  adventurePlanId: string
  settingId: string
  adventure: Adventure
}

const AdventureContext = createContext<AdventureContextType | undefined>(undefined)

export const AdventureProvider = ({ adventurePlanId, settingId, adventure, children }: { adventurePlanId: string; settingId: string; adventure: Adventure; children: React.ReactNode }) => (
  <AdventureContext.Provider value={{ adventurePlanId, settingId, adventure }}>{children}</AdventureContext.Provider>
)

export function useAdventure() {
  const ctx = useContext(AdventureContext)
  if (!ctx) throw new Error("useAdventure must be used within an AdventureProvider")
  return ctx
}


/*
  File: lib/context/TokenContext.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/context/TokenContext.tsx
  Directory: lib/context
*/

--- File: lib/context/TokenContext.tsx ---

import React, { createContext, useContext, useState, useEffect, useCallback, ReactNode } from "react"
import { fetchUserTokenBalance } from "@/app/_actions/user-token-actions" // Adjust path as necessary

type TokenContextType = {
  tokensRemaining: number | null
  alltimeTokens: number | null
  isLoading: boolean
  error: string | null
  refreshTokens: () => Promise<void>
}

const TokenContext = createContext<TokenContextType | undefined>(undefined)

interface TokenProviderProps {
  children: ReactNode
  pollingInterval?: number // Optional: interval in milliseconds, defaults to 60000
}

export const TokenProvider: React.FC<TokenProviderProps> = ({ children, pollingInterval = 60000 }) => {
  const [tokensRemaining, setTokensRemaining] = useState<number | null>(null)
  const [alltimeTokens, setAlltimeTokens] = useState<number | null>(null)
  const [isLoading, setIsLoading] = useState<boolean>(true)
  const [error, setError] = useState<string | null>(null)

  const handleFetchTokens = useCallback(async () => {
    setIsLoading(true)
    try {
      const balance = await fetchUserTokenBalance()
      setTokensRemaining(balance.tokensRemaining)
      setAlltimeTokens(balance.alltimeTokens)
      setError(null)
    } catch (err) {
      console.error("TokenContext: Failed to fetch token balance", err)
      setError(err instanceof Error ? err.message : "An unknown error occurred while fetching token balance.")
      // Keep existing token values if fetch fails, or set to null based on preference
      // setTokensRemaining(null);
      // setAlltimeTokens(null);
    } finally {
      setIsLoading(false)
    }
  }, [])

  useEffect(() => {
    handleFetchTokens() // Initial fetch

    const intervalId = setInterval(() => {
      handleFetchTokens()
    }, pollingInterval)

    return () => clearInterval(intervalId) // Cleanup interval on unmount
  }, [handleFetchTokens, pollingInterval])

  return <TokenContext.Provider value={{ tokensRemaining, alltimeTokens, isLoading, error, refreshTokens: handleFetchTokens }}>{children}</TokenContext.Provider>
}

export const useTokens = (): TokenContextType => {
  const context = useContext(TokenContext)
  if (context === undefined) {
    throw new Error("useTokens must be used within a TokenProvider")
  }
  return context
}


/*
  File: lib/context/TurnContext.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/context/TurnContext.tsx
  Directory: lib/context
*/

--- File: lib/context/TurnContext.tsx ---

import React, { createContext, useContext, useEffect, useState } from "react"
import type { Turn } from "@/types/adventure" // Adjust as needed
import { mapConvexTurnToTurn } from "@/lib/utils"

type TurnContextType = {
  currentTurn: Turn | null
}

const TurnContext = createContext<TurnContextType | undefined>(undefined)

export const TurnProvider = ({ adventureId, initialTurn, children }: { adventureId: string; initialTurn: Turn | null; children: React.ReactNode }) => {
  const [currentTurn, setCurrentTurn] = useState<Turn | null>(initialTurn)

  useEffect(() => {
    if (!adventureId || adventureId === "demo-adventure") {
      console.warn("[TurnProvider] Not subscribing to SSE: adventureId is", adventureId)
      return
    }
    console.log("[TurnProvider] Subscribing to SSE for adventureId:", adventureId)
    const es = new EventSource(`/api/adventure/stream/${adventureId}`)
    es.onmessage = (event) => {
      console.log("[TurnProvider] SSE data received:", event.data)
      const raw = event.data ? JSON.parse(event.data) : null
      setCurrentTurn(mapConvexTurnToTurn(raw))
    }
    es.onerror = (err) => {
      console.error("[TurnProvider] SSE error:", JSON.stringify(err, null, 2))
    }
    return () => {
      console.log("[TurnProvider] Closing SSE for adventureId:", adventureId)
      es.close()
    }
  }, [adventureId])

  return <TurnContext.Provider value={{ currentTurn }}>{children}</TurnContext.Provider>
}

export const useTurn = () => {
  const context = useContext(TurnContext)
  if (!context) {
    throw new Error("useTurn must be used within a TurnProvider")
  }
  return context.currentTurn
}


/*
  File: lib/convex/client.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/convex/client.ts
  Directory: lib/convex
*/

--- File: lib/convex/client.ts ---

import { ConvexReactClient } from "convex/react";

export const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!); 

/*
  File: lib/convex/server.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/convex/server.ts
  Directory: lib/convex
*/

--- File: lib/convex/server.ts ---

import { ConvexClient } from "convex/browser";
import { api, internal } from "@/convex/_generated/api";

export const convex = new ConvexClient(process.env.CONVEX_URL!);
export { api, internal }; 

/*
  File: lib/email-utils.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/email-utils.ts
  Directory: lib
*/

--- File: lib/email-utils.ts ---

import { createHash } from "crypto"

/**
 * Generates a secure token for email unsubscribe links
 * @param email The email address to generate a token for
 * @returns A secure hash that can be used in unsubscribe links
 */
export function generateUnsubscribeToken(email: string): string {
  if (!process.env.UNSUBSCRIBE_SECRET) {
    throw new Error("UNSUBSCRIBE_SECRET environment variable is not set")
  }

  // Combine email with secret and current year-month
  // This makes the token valid for one month
  const date = new Date()
  const yearMonth = `${date.getUTCFullYear()}-${(date.getUTCMonth() + 1).toString().padStart(2, "0")}`
  const data = `${email}:${yearMonth}:${process.env.UNSUBSCRIBE_SECRET}`

  // Create a SHA-256 hash
  return createHash("sha256").update(data).digest("hex")
}

/**
 * Verifies if an unsubscribe token is valid for a given email
 * @param email The email address to verify
 * @param token The token to verify
 * @returns boolean indicating if the token is valid
 */
export function verifyUnsubscribeToken(email: string, token: string): boolean {
  // Generate a token for the current month and previous month
  // This gives users a grace period when links cross month boundaries
  const currentToken = generateUnsubscribeToken(email)
  
  // Generate token for previous month
  const lastMonth = new Date()
  lastMonth.setUTCMonth(lastMonth.getUTCMonth() - 1)
  const yearMonth = `${lastMonth.getUTCFullYear()}-${(lastMonth.getUTCMonth() + 1).toString().padStart(2, "0")}`
  const lastMonthData = `${email}:${yearMonth}:${process.env.UNSUBSCRIBE_SECRET}`
  const previousToken = createHash("sha256").update(lastMonthData).digest("hex")

  // Check if the token matches either current or previous month
  return token === currentToken || token === previousToken
}

/**
 * Encodes an email address for use in URLs
 * @param email The email address to encode
 * @returns URL-safe base64 encoded email
 */
export function encodeEmail(email: string): string {
  return Buffer.from(email).toString("base64url")
}

/**
 * Decodes an encoded email address from a URL
 * @param encoded The encoded email to decode
 * @returns The original email address
 */
export function decodeEmail(encoded: string): string {
  return Buffer.from(encoded, "base64url").toString("utf-8")
} 

/*
  File: lib/generated/routes.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/generated/routes.ts
  Directory: lib/generated
*/

--- File: lib/generated/routes.ts ---

// This file is auto-generated. DO NOT EDIT IT MANUALLY.
// It is used to generate the validRoutes for tracking user visits.
// To regenerate, run: pnpm generate:routes

export const validRoutes = new Set([
  '*',
  '/',
  'about',
  'account/*',
  'admin',
  'admin/mailing-list',
  'admin/users',
  'contact',
  'demo/ai',
  'demo/upload',
  'mailing-list',
  'pay',
  'privacy',
  'roadmap',
  'terms',
  'unsubscribe'
])


/*
  File: lib/s3-utils.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/s3-utils.ts
  Directory: lib
*/

--- File: lib/s3-utils.ts ---

import { GetObjectCommand,PutObjectCommand } from "@aws-sdk/client-s3"
import { s3Client, isAwsConfigured, getAssetUrl } from "./aws"
import { Readable } from "stream"

/**
 * Upload a file to S3
 * @param file The file to upload
 * @param key The S3 object key (path + filename)
 * @param contentType Optional content type
 * @returns The URL of the uploaded file through CloudFront
 */
export async function uploadFileToS3(
  file: File | Blob,
  key: string,
  contentType?: string
): Promise<string> {
  if (!isAwsConfigured() || !s3Client) {
    throw new Error("AWS S3 is not configured")
  }

  // Convert file to buffer
  const arrayBuffer = await file.arrayBuffer()
  const buffer = Buffer.from(arrayBuffer)

  // Set up the upload parameters
  const params = {
    Bucket: process.env.AWS_BUCKET_PUBLIC,
    Key: key,
    Body: buffer,
    ContentType: contentType || file.type,
    CacheControl: key.includes('hackathon/covers') ? 'no-cache' : "public, max-age=31536000",
  }

  // Upload to S3
  await s3Client.send(new PutObjectCommand(params))
  
  // Get the URL (with timestamp for cache busting)
  const url = getAssetUrl(key, true)
  if (!url) {
    throw new Error("Failed to generate asset URL")
  }
  
  return url
}

export const transferImageToS3 = async (imageUrl: string, key: string): Promise<string> => {
  if (!isAwsConfigured() || !s3Client) {
    throw new Error("AWS S3 is not configured")
  }

  try {
    // Download the image from the URL
    const response = await fetch(imageUrl)
    const arrayBuffer = await response.arrayBuffer()

    // Prepare the parameters for uploading to S3
    const params = {
      Bucket: process.env.AWS_BUCKET_PUBLIC,
      Key: key,
      Body: Buffer.from(arrayBuffer),
      ContentType: response.headers.get("content-type") || "application/octet-stream",
      ContentLength: parseInt(response.headers.get("content-length") || "0", 10),
    }

    // Upload the image to the S3 bucket
    const putCommand = new PutObjectCommand(params)
    
    await s3Client.send(putCommand)

    // Get the URL
    const publicUrl = getAssetUrl(key)
    if (!publicUrl) {
      throw new Error("Failed to generate asset URL")
    }

    return publicUrl
  } catch (error) {
    throw new Error("Error uploading image to S3: " + error)
  }
}

// Helper function to convert a Readable stream to a string
export const streamToString = (stream: Readable): Promise<string> => {
  const chunks: unknown[] = []
  return new Promise((resolve, reject) => {
    stream.on("data", (chunk) => chunks.push(chunk))
    stream.on("end", () => resolve(Buffer.concat(chunks as Buffer[]).toString("utf8")))
    stream.on("error", reject)
  })
}

/**
 * Read a JSON file from S3 (private data bucket)
 * @param key The S3 object key (path + filename)
 * @returns The parsed JSON object
 */
export async function readJsonFromS3(key: string): Promise<unknown> {
  console.log(`[readJsonFromS3] Attempting to read key: ${key}`);
  const bucket = process.env.bucketData || process.env.AWS_BUCKET_DATA;
  if (!bucket) {
    throw new Error("AWS_BUCKET_DATA is not set");
  }
  if (!isAwsConfigured() || !s3Client) {
    throw new Error("AWS S3 is not configured");
  }
  try {
    const command = new GetObjectCommand({
      Bucket: bucket,
      Key: key,
    });
    const response = await s3Client.send(command);
    if (!response.Body) {
      throw new Error("No file body returned from S3");
    }
    // Convert stream to string
    const jsonString = await streamToString(response.Body as Readable);
    try {
      // Parse and return JSON
      return JSON.parse(jsonString);
    } catch (parseError) {
      console.error("Failed to parse JSON from S3:", {
        key,
        jsonString,
        parseError,
      });
      throw new Error(`Invalid JSON in S3 object: ${key}`);
    }
  } catch (error) {
    throw new Error(`Error reading JSON from S3: ${error}`);
  }
}

/*
  File: lib/send-email.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/send-email.ts
  Directory: lib
*/

--- File: lib/send-email.ts ---

import sgMail from "@sendgrid/mail"

if (!process.env.SENDGRID_API_KEY) {
  throw new Error("Missing SENDGRID_API_KEY environment variable")
}

sgMail.setApiKey(process.env.SENDGRID_API_KEY)

interface SendEmailOptions {
  to: string
  subject: string
  text: string
  html?: string
}

export async function sendEmail({ to, subject, text, html }: SendEmailOptions) {
  const msg = {
    to,
    from: process.env.SENDGRID_SENDER || "noreply@example.com",
    subject,
    text,
    html: html || text,
  }

  try {
    await sgMail.send(msg)
  } catch (error) {
    console.error("Error sending email:", error)
    throw error
  }
} 

/*
  File: lib/server/generate-object.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/server/generate-object.ts
  Directory: lib/server
*/

--- File: lib/server/generate-object.ts ---

import { ZodSchema } from "zod";

export async function generateObject<T>(api: string, schema: ZodSchema<T>, prompt: string): Promise<T> {
  const res = await fetch(api, {
    method: "POST",
    body: JSON.stringify({ prompt }),
    headers: { "Content-Type": "application/json" },
  });
  if (!res.ok) {
    throw new Error(`Failed to fetch from AI service: ${res.statusText}`);
  }
  const data = await res.json();
  // Validate with Zod schema
  return schema.parse(data.result);
} 

/*
  File: lib/services/mailing-list.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/services/mailing-list.ts
  Directory: lib/services
*/

--- File: lib/services/mailing-list.ts ---

import { convex, api } from "@/lib/convex/server";
import { Doc } from "@/convex/_generated/dataModel";

export type MailingListSubscription = Doc<"mailing_list_subscriptions">;

/**
 * Retrieves all mailing list subscriptions from Convex
 */
export async function getMailingListSubscriptions(): Promise<MailingListSubscription[]> {
  try {
    return await convex.query(api.mailingList.getSubscriptions, {});
  } catch (error) {
    console.error('Error getting mailing list subscriptions:', error);
    return [];
  }
}

/**
 * Adds a new email subscription to the mailing list
 */
export async function addMailingListSubscription(data: { 
  userId: string, 
  email: string, 
  name?: string | undefined,
  preferences?: {
    marketing: boolean,
    updates: boolean
  }
}): Promise<MailingListSubscription | null> {
  try {
    return await convex.mutation(api.mailingList.subscribe, data);
  } catch (error) {
    console.error('Error adding mailing list subscription:', error);
    return null;
  }
}

/**
 * Removes an email subscription from the mailing list
 */
export async function removeMailingListSubscription(email: string): Promise<boolean> {
  try {
    return await convex.mutation(api.mailingList.unsubscribe, { email });
  } catch (error) {
    console.error('Error removing mailing list subscription:', error);
    return false;
  }
} 

/*
  File: lib/services/narrative-service.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/services/narrative-service.ts
  Directory: lib/services
*/

--- File: lib/services/narrative-service.ts ---

import { generateObject } from "@/lib/ai";
import wait from "waait";
import { z } from "zod";

const rollRequirementSchema = z.object({
  rollType: z.string(),
  difficulty: z.number(),
  modifier: z.number().optional(),
});

const rollModifierSchema = z.object({
  modifier: z.number(),
});

export async function isRedundantOrMinimalAction(action: string, aiNarrative: string, characterName: string): Promise<boolean> {
  const prompt = `
Given the following player action and AI-generated narrative for the character ${characterName}, does the action add any meaningful, non-redundant content that avoids mentioning game mechanics to the narrative? If the action is generic, minimal, or already fully captured by the narrative, answer "yes". Otherwise, answer "no".

Player action:
${action}

AI narrative:
${aiNarrative}

Answer:`.trim();

  const res = await fetch("/api/ai/generate/text", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ input: prompt }),
  });
  if (!res.ok) throw new Error("Failed to judge redundancy");
  const data = await res.json();
  const answer = (data.result || data.text || "").trim().toLowerCase();
  return answer.startsWith("yes");
}

export async function ensureNarrativeAction(characterName: string, playerInput: string): Promise<string> {
  const prompt = `
If the following player action is already a well-written, third-person, present-tense narrative paragraph suitable for a fantasy novel, return it unchanged. Otherwise, rewrite it as such, expanding minimally if needed replacing game mechanics with well-written narrative in the style of a novel..

Character name: ${characterName}

Player input:
${playerInput}

Final narrative action:`.trim();

  const res = await fetch("/api/ai/generate/text", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ input: prompt }),
  });
  if (!res.ok) throw new Error("Failed to process player action");
  const data = await res.json();
  return data.result || data.text || "";
}

export async function generateNarrativeUpdate(previousNarrative: string, playerReply: string): Promise<string> {
  const prompt = `
Continue the following fantasy adventure story as a single, concise paragraph of immersive third-person narrative prose, as if writing a novel. Write exactly two sentences and do not exceed 60 words. Do not use lists, bullet points, or markdown formatting. Write in present tense. Continue naturally from the previous events and the player's latest action. Do not use semicolons in your response. Never mention game mechanics, dice, or rules in your response.

Previous narrative:
${previousNarrative}

Player action:
${playerReply}

Narrative continuation:`.trim();

  const res = await fetch("/api/ai/generate/text", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ input: prompt }),
  });
  if (!res.ok) throw new Error("Failed to generate narrative");
  const data = await res.json();
  return data.result || data.text || "";
}

export async function formatNarrativeAction({
  characterName,
  playerInput,
  narrativeContext,
}: {
  characterName: string;
  playerInput: string;
  narrativeContext: string;
}): Promise<string> {
  // First, check if dialogue should be generated
  const dialogueEvalPrompt = `
Context:
${narrativeContext}

Player's action for ${characterName}: "${playerInput}"

Does this player action suggest that ${characterName} should speak dialogue? Look for actions like "greet", "ask", "say", "tell", "speak", "respond", "answer", "call out", "whisper", "shout", or any action that implies the character is communicating verbally with someone.

Answer only "yes" or "no".`.trim();

  console.log("[formatNarrativeAction] dialogue evaluation prompt:\n", dialogueEvalPrompt);
  
  const dialogueEvalRes = await fetch("/api/ai/generate/text", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ input: dialogueEvalPrompt }),
  });
  
  if (!dialogueEvalRes.ok) throw new Error("Failed to evaluate dialogue need");
  const dialogueEvalData = await dialogueEvalRes.json();
  const shouldGenerateDialogue = (dialogueEvalData.result || dialogueEvalData.text || "").trim().toLowerCase().startsWith("yes");
  
  console.log("[formatNarrativeAction] should generate dialogue:", shouldGenerateDialogue);

  if (shouldGenerateDialogue) {
    // Generate dialogue
    const dialoguePrompt = `
Context:
${narrativeContext}

Player's action for ${characterName}: "${playerInput}"

Write a brief narrative paragraph in third-person present tense that includes actual dialogue for ${characterName}. Base the dialogue on what the player action suggests the character should say. Keep it concise and natural, with up to 2 sentences of narrative, in the style of a novel, with at least one complete sentence of prose. Include dialogue tags (e.g., "says", "asks", "replies"). Do not use semicolons. Never mention game mechanics, dice, or rules.

Output only the narrative paragraph with dialogue.`.trim();

    console.log("[formatNarrativeAction] dialogue generation prompt:\n", dialoguePrompt);
    const dialogueRes = await fetch("/api/ai/generate/text", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ input: dialoguePrompt }),
    });
    if (!dialogueRes.ok) throw new Error("Failed to generate dialogue");
    const dialogueData = await dialogueRes.json();
    const result = dialogueData.result || dialogueData.text || "";
    console.log("[formatNarrativeAction] dialogue result:", result);
    return result;
  }

  // Original logic for non-dialogue actions
  const prompt = `
Context:
${narrativeContext}

Player's original action for ${characterName}: "${playerInput}"

Review the player's original action.
If the action is already a well-written, third-person, present-tense narrative paragraph describing what ${characterName} said or did, then return the player's original action verbatim.
Otherwise, expand the player's action into a vivid, engaging, third-person, present-tense narrative paragraph. If the action is minimal (like "attack" or "hide"), enhance it with appropriate descriptive details that fit the context. Describe how ${characterName} performs the action in a way that's immersive and engaging.
Use the provided context to inform appropriate details (weapons, environment, targets, etc.) but focus on ${characterName}'s specific actions. Write in the style of an adventure novel. Do not use semicolons. Never mention game mechanics, dice, or rules.

Output only the final narrative paragraph.`.trim();

  await wait(500)
  console.log("[formatNarrativeAction] standard formatting prompt:\n", prompt);
  const res = await fetch("/api/ai/generate/text", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ input: prompt }),
  });
  if (!res.ok) throw new Error("Failed to process player action");
  const data = await res.json();
  console.log("[formatNarrativeAction] standard result:", data.result || data.text || "");
  return data.result || data.text || "";
}

export async function generateRollOutcomeNarrativeWithContext({
  characterName,
  rollType,
  rollResult,
  rollDifficulty,
  rollSuccess,
  narrativeContext,
  encounterIntro,
  encounterInstructions,
  playerAction,
}: {
  characterName: string;
  rollType: string;
  rollResult: number;
  rollDifficulty: number;
  rollSuccess: boolean;
  narrativeContext: string;
  encounterIntro: string;
  encounterInstructions: string;
  playerAction: string;
}): Promise<string> {
  const prompt = `
Context:
${narrativeContext}

Encounter Intro:
${encounterIntro}

Encounter Instructions:
${encounterInstructions}

Player action: "${playerAction}"

A dice roll was made for ${characterName}: ${rollType} (Result: ${rollResult}, Difficulty: ${rollDifficulty}, Success: ${rollSuccess ? "yes" : "no"}).

Write a single, concise, immersive third-person narrative paragraph (exactly two sentences, max 60 words) describing the outcome of the roll. Only reference things present in the context and instructions above. Do not invent new objects, people, or events. Write in present tense. Do not use lists, bullet points, or markdown formatting. Do not use semicolons in your response. Never mention game mechanics, dice, or rules in your response.

Output only the narrative paragraph.`.trim();

  console.log("[generateRollOutcomeNarrativeWithContext] prompt:\n", prompt);
  const res = await fetch("/api/ai/generate/text", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ input: prompt }),
  });
  if (!res.ok) throw new Error("Failed to generate roll outcome narrative");
  const data = await res.json();
  console.log("[generateRollOutcomeNarrativeWithContext] AI result:", data.result || data.text || "");
  return data.result || data.text || "";
}

export async function getRollRequirementHelper(playerInput: string, context: { encounterIntro?: string; encounterInstructions?: string; narrativeContext?: string }) {
  const prompt = `
Encounter Intro:
${context.encounterIntro || ""}

Encounter Instructions:
${context.encounterInstructions || ""}

Narrative Context:
${context.narrativeContext || ""}

Player action or narrative: "${playerInput}"

Given the above, decide if a D&D-style roll is required. If so, return the type of roll (choose from: Perception, Investigation, Stealth, Athletics, Acrobatics, Survival, Deception, Persuasion, Intimidation, Insight, Nature, Animal Handling, Medicine, History, Arcana, Sleight of Hand, Performance, Attack, etc.) and a difficulty (DC) between 5 and 20.

Respond in JSON: { "rollType": string, "difficulty": number } or null if no roll is needed.
`;
  const result = await generateObject({ prompt, schema: rollRequirementSchema });
  if (result.object) return result.object;

  // --- Fallback: detect roll type keywords if LLM returns null ---
  // This ensures actions like "sneak away", "hide", "attack", etc. require the appropriate check
  const lower = playerInput.toLowerCase();
  // Attack
  if (/(attack|strike|shoot|stab|slash|hit|swing|fire|punch|kick|smash|lunge|thrust|snipe|ambush|assault|charge|fight|brawl|clash|engage|swing at|fire at|shoot at)/.test(lower)) {
    return { rollType: "Attack Roll", difficulty: 13 };
  }
  // Stealth
  if (/(sneak|hide|conceal|slip away|evade|escape|stealth|shadow|blend in|slink|creep|tiptoe|slither|prowl|skulk|lurk|camouflage|mask|cover|avoid|dodge|elude|flee|retreat|withdraw|vanish|disappear)/.test(lower)) {
    return { rollType: "Stealth Check", difficulty: 15 };
  }
  // Athletics
  if (/(climb|jump|run|swim|lift|push|pull|drag|break|force open|athletic|scale|vault|heave|hoist|tug|haul|sprint|dash|leap|wrestle|grapple|carry|throw|toss|hurl|shove|barge|ram|bust|burst|athletics)/.test(lower)) {
    return { rollType: "Athletics Check", difficulty: 14 };
  }
  // Acrobatics
  if (/(acrobatics|flip|tumble|roll|cartwheel|somersault|dive|dodge|evade|balance|tightrope|spring|vault|slide|slip|twist|spin|pirouette|leap|agile|agility|nimble|dexterous|somersault|handspring|backflip|frontflip|handstand)/.test(lower)) {
    return { rollType: "Acrobatics Check", difficulty: 14 };
  }
  // Survival
  if (/(track|forage|hunt|survive|navigate|find food|find water|build shelter|endure|weather|survival|trail|wilderness|outdoors|camp|trap|snare|follow tracks|read tracks|nature lore)/.test(lower)) {
    return { rollType: "Survival Check", difficulty: 13 };
  }
  // Deception
  if (/(deceiv|lie|bluff|trick|mislead|con|fake|forg|falsif|cheat|hoax|dupe|deception|fib|fabricat|pretend|disguise|mask intent|cover up|conceal intent)/.test(lower)) {
    return { rollType: "Deception Check", difficulty: 13 };
  }
  // Persuasion
  if (/(persuad|convince|influence|charm|appeal|negotiate|bargain|diplomacy|diplomat|reason with|plead|entreat|coax|sway|talk into|win over|persuasion)/.test(lower)) {
    return { rollType: "Persuasion Check", difficulty: 13 };
  }
  // Intimidation
  if (/(intimidat|threaten|bully|coerce|frighten|scare|menace|terrorize|daunt|cow|browbeat|overawe|dominate|intimidation)/.test(lower)) {
    return { rollType: "Intimidation Check", difficulty: 13 };
  }
  // Insight
  if (/(insight|sense motive|discern motive|read emotion|read intent|detect lie|intuition|gut feeling|hunch|perceive motive|perceive intent|understand motive|understand intent)/.test(lower)) {
    return { rollType: "Insight Check", difficulty: 12 };
  }
  // Investigation
  if (/(investigat|search for clues|examin|inspect|analy[sz]e|scrutinize|probe|study|investigation|look for evidence|find evidence|detect|deduce|uncover|solve|research|inquire|delve|explore|question|interrogate)/.test(lower)) {
    return { rollType: "Investigation Check", difficulty: 14 };
  }
  // Nature
  if (/(nature|identify plant|identify animal|recognize animal|recognize plant|natural world|wilderness lore|herbalism|animal lore|plant lore|track animal|animal tracks|plant identification|forage|herb|flora|fauna)/.test(lower)) {
    return { rollType: "Nature Check", difficulty: 13 };
  }
  // Animal Handling
  if (/(animal handling|calm animal|train animal|control animal|soothe animal|befriend animal|command animal|handle animal|ride animal|mount animal|tame|break horse|lead animal|animal empathy|pet|feed animal|groom animal)/.test(lower)) {
    return { rollType: "Animal Handling Check", difficulty: 12 };
  }
  // Medicine
  if (/(medicine|heal|treat wound|bandage|diagnose|cure|first aid|medical|doctor|nurse|tend wound|set bone|apply poultice|stop bleeding|check pulse|revive|resuscitate|medic|herbal remedy|herbal medicine)/.test(lower)) {
    return { rollType: "Medicine Check", difficulty: 12 };
  }
  // History
  if (/(history|recall history|remember event|ancient|legend|lore|historical|present event|old story|ancestry|genealogy|chronicle|record|archive|historian|antiquity|antique|artifact|relic|old tale|old legend)/.test(lower)) {
    return { rollType: "History Check", difficulty: 12 };
  }
  // Arcana
  if (/(arcana|magic|spell|identify spell|recognize spell|magical|arcane|wizardry|sorcery|enchantment|rune|glyph|sigil|ritual|incantation|occult|mystic|eldritch|divination|conjuration|abjuration|evocation|illusion|necromancy|transmutation|spellcraft|magical knowledge)/.test(lower)) {
    return { rollType: "Arcana Check", difficulty: 14 };
  }
  // Sleight of Hand
  if (/(sleight of hand|pickpocket|palm|conceal object|quick fingers|legerdemain|trickery|filch|swipe|steal|lift|plant|switch|swap|hand trick|card trick|coin trick|nimble fingers|deft fingers|dexterous fingers|slide of hand)/.test(lower)) {
    return { rollType: "Sleight of Hand Check", difficulty: 14 };
  }
  // Performance
  if (/(perform|performance|sing|dance|play instrument|recite|act|entertain|show|display talent|put on show|storytell|orate|speech|monologue|soliloquy|juggle|acrobatics performance|musical|theater|theatre|comedy|drama|improv|recital|concert|showcase|presentation)/.test(lower)) {
    return { rollType: "Performance Check", difficulty: 12 };
  }
  // Perception (keep last, as it's a common fallback)
  if (/(perceiv|perception|look|figure out|search|spot|notice|discern|determine|find|sense|scan|study|observe|see|hear|smell|taste|touch|listen|watch|glance|peek|peer|survey|examine|inspect|observe|check|detect|discover|recognize|identify|locate|explore|scout|patrol|monitor|track|survey|scrutinize|investigate)/.test(lower)) {
    return { rollType: "Perception Check", difficulty: 14 };
  }
  return null;
}

export async function getRollModifier(context: { scenario: unknown; rollRequirement: unknown; character: unknown }) {
  const prompt = `
Given the following scenario, roll requirement, and character, determine if there should be a bonus or penalty (modifier) to the roll. Respond in JSON: { "modifier": number } (can be negative, zero, or positive).

Scenario: ${JSON.stringify(context.scenario, null, 2)}
Roll Requirement: ${JSON.stringify(context.rollRequirement, null, 2)}
Character: ${JSON.stringify(context.character, null, 2)}
`;
  const result = await generateObject({ prompt, schema: rollModifierSchema });
  return result.object?.modifier ?? 0;
}

/**
 * Appends new narrative content to the previous narrative, ensuring consistent formatting.
 * Does NOT attempt to diff or remove duplication—callers must ensure newContent is truly new.
 * @param previousNarrative The narrative so far
 * @param newContent The new narrative content to append (string or array of strings)
 * @returns The updated narrative
 */
export function appendNarrative(previousNarrative: string, newContent: string | string[]): string {
  const toAppend = Array.isArray(newContent) ? newContent.filter(Boolean).join('\n') : newContent;
  if (!toAppend) return previousNarrative || '';
  if (!previousNarrative) return toAppend;
  // Always separate with two newlines for clarity
  return previousNarrative.trimEnd() + '\n\n' + toAppend.trimStart();
} 

/*
  File: lib/services/npc-turn-service.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/services/npc-turn-service.ts
  Directory: lib/services
*/

--- File: lib/services/npc-turn-service.ts ---

import { z } from "zod";
import { generateObject } from "@/lib/ai";
import { getRollRequirementForAction } from "@/lib/services/roll-requirement-service";
import { getRollModifier, appendNarrative } from "@/lib/services/narrative-service";
import { rollD20 } from "@/lib/utils";
import type { Turn, TurnCharacter } from "@/types/adventure";
import { convex } from "@/lib/convex/server";
import { api } from "@/convex/_generated/api";
import type { Id } from "@/convex/_generated/dataModel";
import { analyzeAndApplyDiceRoll } from "@/lib/services/turn-update-service";
import { readJsonFromS3 } from "@/lib/s3-utils";
import type { AdventurePlan, AdventureEncounter } from "@/types/adventure-plan";

// Step 1: Schema for LLM to decide NPC action
const npcActionSchema = z.object({
  actionSummary: z.string(), // e.g. "The goblin tries to sneak behind the hero and attack."
  narrative: z.string(), // Narrative update for the action
  effects: z.array(z.object({
    targetId: z.string(),
    equipmentToAdd: z.array(z.object({
      name: z.string(),
      description: z.string().optional(),
    })).optional(),
  })).optional(),
});

// Step 2: Schema for LLM to decide outcome of the action after roll
const npcActionOutcomeSchema = z.object({
  narrative: z.string(), // Narrative update for the outcome
  effects: z.array(z.object({
    targetId: z.string(),
    healthPercentDelta: z.number().optional(),
    status: z.string().optional(),
    equipmentToAdd: z.array(z.object({
      name: z.string(),
      description: z.string().optional(),
    })).optional(),
  })),
});

export async function processNpcTurnWithLLM({
  turn,
  npcId,
  encounterContext,
}: {
  turn: Turn;
  npcId: string;
  encounterContext?: { intro?: string; instructions?: string };
}): Promise<{
  updatedNarrative: string;
  updatedCharacters: TurnCharacter[];
  actionSummary: string;
  rollInfo?: { rollType: string; difficulty: number; baseRoll: number; modifier: number; result: number; success: boolean };
  effects?: Array<{ targetId: string; healthPercentDelta?: number; status?: string; equipmentToAdd?: Array<{name: string, description?: string}> }>;
  shortcode?: string;
  narrativeToAppend: string;
}> {
  // 1. LLM decides NPC action
  const npc = turn.characters.find((c) => c.id === npcId);
  if (!npc) throw new Error("NPC not found");
  const narrativeContext = (turn.narrative || "").split(/\n\n+/).slice(-2).join("\n\n");
  const playerCharactersForPrompt1 = turn.characters.filter(c => c.type === 'pc');
  const playerCharacterNamesForPrompt1 = playerCharactersForPrompt1.map(c => c.name);
  const prompt1 = `You are the DM for a tabletop RPG. Given the following context, decide what action the NPC should take this turn. Be creative and act as a real DM would. Output a short narrative for the action.
If the NPC's action involves giving items to a player character, include an "effects" array. Each object in "effects" should have a "targetId" (the ID of the character receiving items) and an "equipmentToAdd" array listing the items ({name: string, description?: string}).

Only include the NPC in the short narrative output: ${npc.name}
Targetable Player Characters: ${playerCharacterNamesForPrompt1.join(', ')} (IDs: ${playerCharactersForPrompt1.map(c => c.id).join(', ')})
${encounterContext?.intro ? `Encounter Intro: ${encounterContext.intro}\n` : ""}
${encounterContext?.instructions ? `Encounter Instructions: ${encounterContext.instructions}\n` : ""}
Recent Narrative:
${narrativeContext}

Respond as JSON:
{
  actionSummary: string,
  narrative: string,
  effects?: [ { targetId: string, equipmentToAdd?: [{name: string, description?: string}] } ]
}`;
  const actionResult = (await generateObject({ prompt: prompt1, schema: npcActionSchema })).object;

  let updatedNarrative = (turn.narrative || "");
  let narrativeToAppend = "";
  let updatedCharacters = [...turn.characters];
  let rollInfo = undefined;
  let effects: Array<{ targetId: string; healthPercentDelta?: number; status?: string; equipmentToAdd?: Array<{name: string, description?: string}> }> | undefined = undefined;
  let shortcode = undefined;

  // 2. Use roll requirement utility to determine if a roll is needed
  const rollRequirement = await getRollRequirementForAction(actionResult.actionSummary);
  if (rollRequirement && rollRequirement.rollType && rollRequirement.difficulty) {
    // 3. Get modifier
    const modifier = await getRollModifier({
      scenario: {
        encounterIntro: encounterContext?.intro || "",
        encounterInstructions: encounterContext?.instructions || "",
        narrativeContext: turn.narrative || "",
      },
      rollRequirement,
      character: npc,
    });
    // 4. Perform the roll
    const baseRoll = rollD20();
    const result = baseRoll + (modifier || 0);
    const success = result >= rollRequirement.difficulty;
    rollInfo = {
      rollType: rollRequirement.rollType,
      difficulty: rollRequirement.difficulty,
      baseRoll,
      modifier,
      result,
      success,
    };
    // 5. Build DiceRoll shortcode
    shortcode = `[DiceRoll:rollType=${rollRequirement.rollType};baseRoll=${baseRoll};modifier=${modifier >= 0 ? "+" + modifier : modifier};result=${result};difficulty=${rollRequirement.difficulty};character=${npc.name};image=${npc.image};success=${success}]\n`;
    // 6. LLM: Given the action, roll result, and context, generate the outcome
    const playerCharacters = turn.characters.filter(c => c.type === 'pc');
    const playerCharacterNames = playerCharacters.map(c => c.name);
    const prompt2 = `You are the DM for a tabletop RPG. Given the action, the dice roll result, and the context, write a short narrative describing the outcome. Focus the narrative on the interacting characters. **Do not narrate any actions or dialogue for player characters.** Then, output a JSON array of effects for any characters affected (targetId, healthPercentDelta, status). If the NPC\'s action results in any characters receiving items, specify these in an \`equipmentToAdd\` array (each item as \`{name: string, description?: string}\`) within the corresponding effect object for the target character.\n\nNPC: ${npc.name}\nPlayer Characters: ${playerCharacterNames.join(', ')}\nAction: ${actionResult.actionSummary}\nRoll Type: ${rollRequirement.rollType}\nRoll Result: ${result} (difficulty: ${rollRequirement.difficulty}, success: ${success})\n${encounterContext?.intro ? `Encounter Intro: ${encounterContext.intro}\n` : ""}${encounterContext?.instructions ? `Encounter Instructions: ${encounterContext.instructions}\n` : ""}Recent Narrative:\n${updatedNarrative}\n\nRespond as JSON:\n{\n  narrative: string,\n  effects: [ { targetId: string, healthPercentDelta?: number, status?: string, equipmentToAdd?: [{name: string, description?: string}] } ]\n}`;
    const outcomeResult = (await generateObject({ prompt: prompt2, schema: npcActionOutcomeSchema })).object;
    
    console.log("[NPC TURN] LLM-generated outcome result:", JSON.stringify(outcomeResult, null, 2));
    
    narrativeToAppend = (shortcode ? shortcode : "") + (outcomeResult.narrative || "");
    effects = outcomeResult.effects;
    
    console.log("[NPC TURN] Effects to apply:", JSON.stringify(effects, null, 2));
    
    // Log character health BEFORE applying effects
    console.log("[NPC TURN] Character health BEFORE applying effects:");
    updatedCharacters.forEach(c => {
      console.log(`  ${c.name} (${c.id}): ${c.healthPercent}%`);
    });
    
    // Apply effects to characters
    updatedCharacters = updatedCharacters.map((c) => {
      const effect = effects?.find((e) => e.targetId === c.id);
      const updated = { ...c };
      if (effect) {
        console.log(`[NPC TURN] Applying effect to ${c.name} (${c.id}):`, JSON.stringify(effect, null, 2));
        
        if (effect.healthPercentDelta !== undefined) {
          const oldHealth = c.healthPercent ?? 100;
          const newHealth = Math.max(0, oldHealth + effect.healthPercentDelta);
          updated.healthPercent = newHealth;
          console.log(`[NPC TURN] Health update for ${c.name}: ${oldHealth}% -> ${newHealth}% (delta: ${effect.healthPercentDelta})`);
        }
        
        updated.status = effect.status || c.status;
        if (effect.equipmentToAdd && effect.equipmentToAdd.length > 0) {
          const existingEquipment = Array.isArray(c.equipment) ? c.equipment : [];
          updated.equipment = [...existingEquipment, ...effect.equipmentToAdd];
          console.log(`[NPC TURN] Added equipment to ${c.name}:`, effect.equipmentToAdd);
        }
      }
      // Mark this NPC as having acted
      if (c.id === npc.id) {
        updated.hasReplied = true;
        updated.isComplete = true;
      }
      return updated;
    });
    
    // Log character health AFTER applying effects
    console.log("[NPC TURN] Character health AFTER applying effects:");
    updatedCharacters.forEach(c => {
      console.log(`  ${c.name} (${c.id}): ${c.healthPercent}%`);
    });
    
    // Logging for verification
    console.log("[NPC TURN] Roll required. Appending shortcode and outcome narrative...");

    // --- AI health update: analyzeAndApplyDiceRoll ---
    const diceRoll = {
      rollType: rollRequirement.rollType,
      baseRoll,
      modifier,
      result,
      difficulty: rollRequirement.difficulty,
      character: npc.name,
      // Try to infer the target from effects (first effect targetId)
      target: outcomeResult.effects && outcomeResult.effects[0] ? outcomeResult.effects[0].targetId : undefined,
      success,
    };
    
    console.log("[NPC TURN] Calling analyzeAndApplyDiceRoll with diceRoll:", JSON.stringify(diceRoll, null, 2));
    console.log("[NPC TURN] Character health BEFORE analyzeAndApplyDiceRoll:");
    updatedCharacters.forEach(c => {
      console.log(`  ${c.name} (${c.id}): ${c.healthPercent}%`);
    });
    
    const aiTurn = await analyzeAndApplyDiceRoll({
      turn: { ...turn, characters: updatedCharacters },
      diceRoll,
      narrative: appendNarrative(updatedNarrative, narrativeToAppend),
    });
    console.log("[NPC TURN] analyzeAndApplyDiceRoll result:", aiTurn.characters);
    
    // Log detailed comparison of AI updates
    console.log("[NPC TURN] Detailed AI character updates:");
    aiTurn.characters.forEach(aiChar => {
      const origChar = updatedCharacters.find(c => c.id === aiChar.id);
      if (origChar) {
        console.log(`  ${origChar.name} (${aiChar.id}):`);
        if (origChar.healthPercent !== aiChar.healthPercent) {
          console.log(`    Health: ${origChar.healthPercent}% -> ${aiChar.healthPercent}%`);
        }
        if (origChar.status !== aiChar.status) {
          console.log(`    Status: "${origChar.status}" -> "${aiChar.status}"`);
        }
      }
    });
    
    // Merge AI-updated fields into original TurnCharacter objects
    updatedCharacters = updatedCharacters.map(orig =>
      aiTurn.characters.find(ai => ai.id === orig.id)
        ? { ...orig, ...aiTurn.characters.find(ai => ai.id === orig.id) }
        : orig
    );
    
    // Log final character health state
    console.log("[NPC TURN] FINAL character health after AI merge:");
    updatedCharacters.forEach(c => {
      console.log(`  ${c.name} (${c.id}): ${c.healthPercent}%`);
    });
  } else {
    narrativeToAppend = actionResult.narrative;
    effects = actionResult.effects;

    updatedCharacters = updatedCharacters.map((c) => {
      const effect = effects?.find((e) => e.targetId === c.id);
      const updated = { ...c };
      if (effect) {
        if (effect.equipmentToAdd && effect.equipmentToAdd.length > 0) {
          const existingEquipment = Array.isArray(c.equipment) ? c.equipment : [];
          updated.equipment = [...existingEquipment, ...effect.equipmentToAdd];
        }
      }
      // Mark this NPC as having acted
      if (c.id === npc.id) {
        updated.hasReplied = true;
        updated.isComplete = true;
      }
      return updated;
    });
    // Logging for verification
    console.log("[NPC TURN] No roll required. Appending action narrative only:");
    console.log("[NPC TURN] Action narrative:", actionResult.narrative);
    if (effects && effects.length > 0) {
      console.log("[NPC TURN] Effects from no-roll action:", JSON.stringify(effects, null, 2));
    }
  }
  updatedNarrative = appendNarrative(updatedNarrative, narrativeToAppend);

  return {
    updatedNarrative,
    updatedCharacters,
    actionSummary: actionResult.actionSummary,
    rollInfo,
    effects,
    shortcode,
    narrativeToAppend,
  };
}

// Helper function to find encounter in plan
const findEncounterInPlan = (plan: AdventurePlan, encounterId: string): AdventureEncounter | null =>
  plan.sections
    .flatMap(section => section.scenes)
    .flatMap(scene => scene.encounters)
    .find(encounter => encounter.id === encounterId) ?? null;

export async function processNpcTurnsAfterCurrent(turnId: Id<"turns">) {
  let turn = await convex.query(api.adventure.getTurnById, { turnId });
  if (!turn) throw new Error("Turn not found");

  const adventure = await convex.query(api.adventure.getAdventureById, { adventureId: turn.adventureId });
  if (!adventure) throw new Error(`Adventure not found for ID: ${turn.adventureId.toString()}`);

  const plan = (await readJsonFromS3(`settings/${adventure.settingId}/${adventure.planId}.json`)) as AdventurePlan;
  if (!plan || !plan.id || !plan.sections || !plan.title) {
    throw new Error("Adventure plan is missing required fields or could not be loaded");
  }

  let characters = turn.characters as TurnCharacter[];
  // Take a snapshot of the current initiative order
  const initiativeOrder = characters
    .filter((c) => !c.hasReplied && !c.isComplete)
    .sort((a, b) => (b.initiative ?? 0) - (a.initiative ?? 0));

  for (const char of initiativeOrder) {
    if (char.type !== "npc") break; // Process NPCs in order, then stop

    // Always reload the latest turn state before processing each NPC
    // as previous NPC actions in the same turn might have updated it.
    const currentTurnState = await convex.query(api.adventure.getTurnById, { turnId });
    if (!currentTurnState) {
      console.warn("[NPC TURN] Could not reload turn state, stopping NPC processing for this turn.");
      break;
    }
    turn = currentTurnState; // Update local turn variable
    characters = turn.characters as TurnCharacter[]; // Update local characters variable

    const npc = characters.find((c) => c.id === char.id && c.type === "npc" && !c.hasReplied && !c.isComplete);
    if (!npc) continue; // NPC already processed or no longer eligible

    const currentEncounterDetails = findEncounterInPlan(plan, turn.encounterId);
    let encounterContext: { intro?: string; instructions?: string } = {};
    if (currentEncounterDetails) {
      encounterContext = {
        intro: currentEncounterDetails.intro,
        instructions: currentEncounterDetails.instructions,
      };
    } else {
      console.warn(`[NPC TURN] Could not find details for encounter ${turn.encounterId} in the plan.`);
    }

    const result = await processNpcTurnWithLLM({
      turn: { ...turn, id: turn._id, characters }, // Pass the reloaded turn characters
      npcId: npc.id,
      encounterContext, // Pass the populated context
    });
    // Logging for verification
    console.log("[NPC TURN] Previous narrative:\n", turn.narrative);
    console.log("[NPC TURN] Shortcode:", result.shortcode);
    // Use appendNarrative utility for consistent narrative updates
    const newNarrative = appendNarrative(turn.narrative || "", result.narrativeToAppend || "");
    console.log("[NPC TURN] Updated narrative to be saved:\n", newNarrative);
    await convex.mutation(api.turns.updateTurn, {
      turnId: turn._id,
      patch: {
        characters: result.updatedCharacters,
        narrative: newNarrative,
        updatedAt: Date.now(),
      },
    });
  }
} 

/*
  File: lib/services/roll-requirement-service.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/services/roll-requirement-service.ts
  Directory: lib/services
*/

--- File: lib/services/roll-requirement-service.ts ---

import { rollRequirementSchema } from "@/lib/validations/roll-requirement-schema";
import { generateObject } from "@/lib/ai";

/**
 * Given an action or reply string, determine if a dice roll is required.
 * Returns { rollType, difficulty } or null if no roll is required.
 */
export async function getRollRequirementForAction(action: string) {
  const prompt = `
Given the following player or NPC action, determine if a dice roll is required for the character to attempt the action. If a roll is required, return a JSON object with "rollType" (choose the most appropriate from the list below) and "difficulty" (a number between 5 and 25). If no roll is required, return the JSON value null (not a string).

Possible roll types:
- Perception Check
- Investigation Check
- Insight Check
- Stealth Check
- Athletics Check
- Acrobatics Check
- Survival Check
- Nature Check
- Arcana Check
- History Check
- Medicine Check
- Animal Handling Check
- Persuasion Check
- Deception Check
- Intimidation Check
- Performance Check
- Sleight of Hand Check
- Strength Check
- Dexterity Check
- Constitution Check
- Intelligence Check
- Wisdom Check
- Charisma Check
- Attack Roll
- Spellcasting Check
- Saving Throw
- Initiative Roll
- Luck Check
- Reflex Saving Throw
- Fortitude Saving Throw
- Will Saving Throw
- Concentration Check
- Endurance Check
- Religion Check
- Technology Check
- Engineering Check
- Piloting Check
- Driving Check
- Climbing Check
- Swimming Check
- Jumping Check
- Disguise Check
- Bluff Check
- Sense Motive Check
- Use Magic Device Check
- Use Rope Check
- Escape Artist Check
- Appraise Check
- Disable Device Check
- Knowledge (Any) Check
- Perform (Any) Check
- Craft (Any) Check
- Profession (Any) Check
- Read Lips Check
- Tumble Check
- Balance Check
- Ride Check
- Handle Animal Check
- Gather Information Check
- Search Check
- Listen Check
- Spot Check
- Open Lock Check
- Forgery Check
- Diplomacy Check
- Intuition Check
- Morale Check
- Sanity Check
- Willpower Check
- Faith Check
- Social Check
- Streetwise Check
- Investigation Check
- Technology Use Check
- Computer Use Check
- Hacking Check
- Science Check
- Alchemy Check
- Herbalism Check
- Tracking Check
- Navigation Check
- Weather Sense Check
- Cooking Check
- Brewing Check
- Gambling Check
- Barter Check
- Command Check
- Leadership Check
- Strategy Check
- Tactics Check
- Animal Empathy Check
- Psionics Check
- Telepathy Check
- Intuition Check
- Perception (Hearing) Check
- Perception (Sight) Check
- Perception (Smell) Check
- Perception (Taste) Check
- Perception (Touch) Check

Examples:
Action: "Try to sneak past the guards."
Result: { "rollType": "Stealth Check", "difficulty": 15 }

Action: "Attack the goblin."
Result: { "rollType": "Attack Roll", "difficulty": 12 }

Action: "Try to determine what the sound is."
Result: { "rollType": "Perception Check", "difficulty": 10 }

Action: "Say hello."
Result: null

Now, given the following action, determine the roll requirement.

Action: "${action}"
`;
  try {
    const result = await generateObject({
      schema: rollRequirementSchema,
      prompt,
    });
    if (
      result.object &&
      typeof result.object === "object" &&
      "rollType" in result.object &&
      (result.object.rollType === "null" || result.object.rollType === "none" || result.object.rollType === "")
    ) {
      return null;
    }
    return result.object ?? null;
  } catch (error) {
    throw error;
  }
} 

/*
  File: lib/services/turn-update-service.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/services/turn-update-service.ts
  Directory: lib/services
*/

--- File: lib/services/turn-update-service.ts ---

import { generateObject } from "@/lib/ai";
import { z } from "zod";

// Zod schema for the AI's expected output
const characterUpdateSchema = z.object({
  id: z.string(), // character id
  healthPercent: z.number().min(0).max(100),
  status: z.string().optional(),
});

// Types for dice roll and character (customize as needed)
export interface DiceRoll {
  rollType: string;
  baseRoll: number;
  modifier: string | number;
  result: number;
  difficulty: number;
  character: string;
  success: boolean;
  // ...other fields as needed
}

export interface Character {
  id: string;
  healthPercent: number;
  status?: string;
  // ...other fields as needed
}

export interface Turn {
  characters: Character[];
  // ...other fields as needed
}

/**
 * Extracts the narrative text that follows the last [DiceRoll:...] shortcode.
 */
function extractNarrativeAfterLastDiceRoll(narrative: string): string | null {
  const diceRollRegex = /\[DiceRoll:[^\]]+\]/g;
  let match: RegExpExecArray | null;
  let lastIndex = -1;
  while ((match = diceRollRegex.exec(narrative)) !== null) {
    lastIndex = match.index + match[0].length;
  }
  if (lastIndex === -1) return null;
  return narrative.slice(lastIndex).trim();
}

/**
 * Uses generateObject to analyze the most recent dice roll and outcome narrative,
 * and returns an updated turn object with the character's healthPercent and status updated as needed.
 */
export async function analyzeAndApplyDiceRoll({
  turn,
  diceRoll,
  narrative,
}: {
  turn: Turn;
  diceRoll: DiceRoll;
  narrative: string;
}): Promise<Turn> {
  // Extract only the narrative following the last dice roll shortcode
  const relevantNarrative = extractNarrativeAfterLastDiceRoll(narrative);

  if (!relevantNarrative) {
    // If we can't find the relevant narrative, return the turn unchanged
    return turn;
  }

  // Determine if this is a natural 1 or 20, or calculate performance delta
  let narrativeGuidance = "";
  
  if (diceRoll.baseRoll === 1) {
    narrativeGuidance = "This was a catastrophic failure. The narrative should reflect dramatic, unexpected negative consequences that go beyond a simple failure.";
  } else if (diceRoll.baseRoll === 20) {
    narrativeGuidance = "This was a spectacular success. The narrative should reflect exceptional, dramatically positive outcomes that exceed normal success.";
  } else {
    const delta = diceRoll.result - diceRoll.difficulty;
    if (delta > 0) {
      narrativeGuidance = `This was a success that exceeded the target by ${delta} points. The narrative should reflect how well the action was performed.`;
    } else {
      narrativeGuidance = `This was a failure that missed the target by ${Math.abs(delta)} points. The narrative should reflect the degree of the failure.`;
    }
  }

  // Compose a prompt for the AI
  const prompt = `
Given the outcome narrative and performance context, decide if any character's healthPercent or status should be updated. Only update if the narrative describes harm, healing, or a condition change.

${narrativeGuidance}

Outcome Narrative: ${relevantNarrative}
Current Characters: ${JSON.stringify(turn.characters)}

Return an object with the character id, new healthPercent (0-100), and optional status if any changes are warranted.
`;

  // Call the AI
  const update = await generateObject({
    prompt,
    schema: characterUpdateSchema,
  });

  console.log("[analyzeAndApplyDiceRoll] update:", JSON.stringify(update.object, null, 2))

  // If the AI didn't return a valid update, return the turn unchanged
  if (!update.object || !update.object.id) return turn;

  // Find and update the character in the turn
  const updatedCharacters = turn.characters.map((c) =>
    c.id === update.object.id
      ? {
          ...c,
          healthPercent: typeof update.object.healthPercent === "number" ? update.object.healthPercent : c.healthPercent,
          status: (typeof update.object.healthPercent === "number" && update.object.healthPercent <= 0) ? "Dead" : (update.object.status ?? c.status),
        }
      : c
  );

  // Return the updated turn
  return {
    ...turn,
    characters: updatedCharacters,
  };
} 

/*
  File: lib/services/visits.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/services/visits.ts
  Directory: lib/services
*/

--- File: lib/services/visits.ts ---

import { convex, api } from "@/lib/convex/server";

/**
 * Records a new visit to a page
 */
export async function recordVisit(data: {
  path: string;
  userId: string | null;
  metadata: Record<string, unknown>;
}) {
  return await convex.mutation(api.visits.recordVisit, data);
}

/**
 * Gets visits for a specific user
 */
export async function getVisitsByUser(userId: string | null, limit?: number) {
  return await convex.query(api.visits.getVisits, { userId, limit });
}

/**
 * Gets visits for a specific path
 */
export async function getVisitsByPath(path: string, limit?: number) {
  return await convex.query(api.visits.getVisitsByPath, { path, limit });
}

/**
 * Gets all visits
 */
export async function getAllVisits(limit?: number) {
  return await convex.query(api.visits.getVisits, { limit });
} 

/*
  File: lib/stripe.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/stripe.ts
  Directory: lib
*/

--- File: lib/stripe.ts ---

import Stripe from "stripe"

// Environment variables
const stripeSecretKey = process.env.STRIPE_SECRET_KEY

// Log missing variables in development only
if (process.env.NODE_ENV === 'development' && !stripeSecretKey) {
  console.warn('Missing Stripe secret key environment variable')
}

// Function to check if Stripe is configured
export function isStripeConfigured(): boolean {
  return Boolean(stripeSecretKey)
}

// Create a Stripe instance if configured
export const stripe = stripeSecretKey
  ? new Stripe(stripeSecretKey, {
      apiVersion: "2025-04-30.basil",
    })
  : null

// Function to check Stripe connection
export async function checkStripeConnection(): Promise<{
  success: boolean
  message: string
  details?: {
    error?: unknown
  }
}> {
  if (!isStripeConfigured()) {
    return {
      success: false,
      message: 'Stripe is not configured',
      details: {
        error: 'Missing required environment variables'
      }
    }
  }

  try {
    // Try to make a simple API call to verify connection
    await stripe?.balance.retrieve()
    
    return {
      success: true,
      message: 'Successfully connected to Stripe'
    }
  } catch (err) {
    console.error('Unexpected error checking Stripe connection:', err)
    return {
      success: false,
      message: `Unexpected error: ${err instanceof Error ? err.message : String(err)}`,
      details: { error: err }
    }
  }
} 

/*
  File: lib/upload-utils.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/upload-utils.ts
  Directory: lib
*/

--- File: lib/upload-utils.ts ---

"use client"

import { useState } from "react"

interface UploadOptions {
  folder?: string
  maxSize?: number // in bytes
  allowedTypes?: string[]
}

const defaultOptions: UploadOptions = {
  folder: "uploads",
  maxSize: 5 * 1024 * 1024, // 5MB
  allowedTypes: ["image/jpeg", "image/png", "image/webp", "image/gif", "image/svg+xml"],
}

export async function uploadFile(file: File, options: UploadOptions = {}): Promise<string> {
  const { folder = "uploads", maxSize, allowedTypes } = { ...defaultOptions, ...options }

  if (!file) {
    throw new Error("No file provided")
  }

  // Validate file type if allowedTypes is provided
  if (allowedTypes && !allowedTypes.includes(file.type)) {
    throw new Error(`File type not allowed. Please upload one of: ${allowedTypes.join(", ")}`)
  }

  // Validate file size if maxSize is provided
  if (maxSize && file.size > maxSize) {
    throw new Error(`File size exceeds ${Math.round(maxSize / (1024 * 1024))}MB limit`)
  }

  const formData = new FormData()
  formData.append("file", file)
  formData.append("folder", folder)

  try {
    const response = await fetch("/api/upload", {
      method: "POST",
      body: formData,
    })

    if (!response.ok) {
      const data = await response.json()
      throw new Error(data.error || "Failed to upload file")
    }

    const data = await response.json()
    return data.url
  } catch (error) {
    console.error("Error uploading file:", error)
    throw error
  }
}

export function useFileUpload(options: UploadOptions = {}) {
  const [isUploading, setIsUploading] = useState(false)

  const upload = async (file: File): Promise<string> => {
    setIsUploading(true)
    try {
      const url = await uploadFile(file, options)
      return url
    } finally {
      setIsUploading(false)
    }
  }

  return {
    upload,
    isUploading,
  }
} 

/*
  File: lib/utils/case-transforms.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/utils/case-transforms.ts
  Directory: lib/utils
*/

--- File: lib/utils/case-transforms.ts ---

import { camelCase, snakeCase } from 'lodash-es'

// Type transformations for TypeScript type system
type CamelToSnakeCase<S extends string> = S extends `${infer T}${infer U}`
  ? T extends Uppercase<T>
    ? `_${Lowercase<T>}${CamelToSnakeCase<U>}`
    : `${T}${CamelToSnakeCase<U>}`
  : S

type SnakeToCamelCase<S extends string> = S extends `${infer T}_${infer U}`
  ? `${T}${Capitalize<SnakeToCamelCase<U>>}`
  : S

type TransformKeys<T, Transform extends (str: string) => string> = T extends object
  ? {
      [K in keyof T as K extends string
        ? string extends K
          ? string
          : Transform extends typeof snakeCase
            ? Uncapitalize<CamelToSnakeCase<K>>
            : Uncapitalize<SnakeToCamelCase<K>>
        : K]: T[K] extends object
        ? TransformKeys<T[K], Transform>
        : T[K]
    }
  : T

/**
 * Transforms an object's keys from camelCase to snake_case recursively
 */
export function toSnakeCase<T extends object>(obj: T): TransformKeys<T, typeof snakeCase> {
  if (Array.isArray(obj)) {
    return obj.map((item) =>
      typeof item === 'object' ? toSnakeCase(item) : item
    ) as TransformKeys<T, typeof snakeCase>
  }

  if (obj === null || typeof obj !== 'object') {
    return obj as TransformKeys<T, typeof snakeCase>
  }

  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => [
      snakeCase(key),
      typeof value === 'object' ? toSnakeCase(value) : value,
    ])
  ) as TransformKeys<T, typeof snakeCase>
}

/**
 * Transforms an object's keys from snake_case to camelCase recursively
 */
export function toCamelCase<T extends object>(obj: T): TransformKeys<T, typeof camelCase> {
  if (Array.isArray(obj)) {
    return obj.map((item) =>
      typeof item === 'object' ? toCamelCase(item) : item
    ) as TransformKeys<T, typeof camelCase>
  }

  if (obj === null || typeof obj !== 'object') {
    return obj as TransformKeys<T, typeof camelCase>
  }

  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => [
      camelCase(key),
      typeof value === 'object' ? toCamelCase(value) : value,
    ])
  ) as TransformKeys<T, typeof camelCase>
}

/**
 * Alias for toCamelCase, used for consistency with existing codebase
 */
export const deepToCamelCase = toCamelCase

/**
 * Type helper to convert a type from camelCase to snake_case
 * @example
 * interface UserInput {
 *   firstName: string
 *   lastName: string
 * }
 * 
 * type DatabaseUser = ToSnakeCase<UserInput>
 * // Result: { first_name: string, last_name: string }
 */
export type ToSnakeCase<T> = TransformKeys<T, typeof snakeCase>

/**
 * Type helper to convert a type from snake_case to camelCase
 * @example
 * interface DatabaseUser {
 *   first_name: string
 *   last_name: string
 * }
 * 
 * type ClientUser = ToCamelCase<DatabaseUser>
 * // Result: { firstName: string, lastName: string }
 */
export type ToCamelCase<T> = TransformKeys<T, typeof camelCase>

// Types for backward compatibility
export type Primitive = string | number | boolean | null | undefined
export type TransformableObject = { [key: string]: Transformable }
export type TransformableArray = Transformable[]
export type Transformable = Primitive | TransformableObject | TransformableArray 

/*
  File: lib/utils/parse-narrative.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/utils/parse-narrative.ts
  Directory: lib/utils
*/

--- File: lib/utils/parse-narrative.ts ---

// Utility to parse narrative with [DiceRoll:rollType=...;result=...;difficulty=...;character=...;image=...;success=...]

export type NarrativePart =
  | { type: 'paragraph'; value: string }
  | { type: 'diceroll'; rollType: string; baseRoll?: number; modifier?: number; result: number; difficulty: number; character: string; image?: string; success: boolean };

const diceRollRegex = /^\[DiceRoll:([^\]]+)\]$/i;

export function parseNarrative(narrative: string): NarrativePart[] {
  // Convert escaped newlines to actual newlines
  const processedNarrative = narrative.replace(/\\n/g, '\n');
  
  return processedNarrative.split(/\n/).map<NarrativePart>(line => {
    const trimmed = line.trim();
    const match = trimmed.match(diceRollRegex);
    if (match) {
      // Parse key=value pairs
      const fields = Object.fromEntries(
        match[1].split(';').map(pair => {
          const [key, ...rest] = pair.split('=');
          return [key.trim(), rest.join('=').trim()];
        })
      );
      return {
        type: 'diceroll',
        rollType: fields.rollType || '',
        baseRoll: fields.baseRoll !== undefined && fields.baseRoll !== '' ? Number(fields.baseRoll) : undefined,
        modifier: fields.modifier !== undefined && fields.modifier !== '' ? Number(fields.modifier) : undefined,
        result: Number(fields.result),
        difficulty: Number(fields.difficulty),
        character: fields.character || '',
        image: fields.image || '',
        success: fields.success === 'true',
      } as const;
    }
    return { type: 'paragraph', value: trimmed } as const;
  }).filter(part => part.type === 'diceroll' || (part.type === 'paragraph' && part.value.length > 0));
} 

/*
  File: lib/utils.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/utils.ts
  Directory: lib
*/

--- File: lib/utils.ts ---

import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

/**
 * Format a date string to a more readable format
 * @param dateString ISO date string
 * @returns Formatted date string (e.g., "Jan 1, 2023")
 */
export function formatDate(dateString: string): string {
  const date = new Date(dateString)
  return date.toLocaleDateString("en-US", {
    month: "short",
    day: "numeric",
    year: "numeric",
  })
}

export function formatCurrency(amount: number) {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(amount)
}

export const getInitials = (name: string) => {
  return name
    .split(" ")
    .map((n) => n[0])
    .join("")
    .toUpperCase()
    .substring(0, 2)
}

export function hasBooleanProp(obj: unknown, prop: string): obj is { [key: string]: boolean } {
  return !!obj && typeof obj === "object" && prop in obj && typeof (obj as { [key: string]: unknown })[prop] === "boolean"
}
export function hasNumberProp(obj: unknown, prop: string): obj is { [key: string]: number } {
  return !!obj && typeof obj === "object" && prop in obj && typeof (obj as { [key: string]: unknown })[prop] === "number"
}
export function isRollRequired(obj: unknown): obj is { rollType: string; difficulty?: number; modifier?: number } {
  return !!obj && typeof obj === "object" && "rollType" in obj
}

/**
 * Map a Convex turn document to the frontend Turn type
 * @param raw Convex turn document
 * @returns Turn or null
 */
export function mapConvexTurnToTurn(raw: unknown): import("@/types/adventure").Turn | null {
  if (!raw || typeof raw !== "object" || !("encounterId" in raw) || !("title" in raw)) return null;
  const t = raw as { _id: string; encounterId: string; title: string; narrative: string; characters: import("@/types/adventure").TurnCharacter[]; adventureId: string; isFinalEncounter?: boolean };
  return {
    id: t._id,
    encounterId: t.encounterId,
    title: t.title,
    narrative: t.narrative,
    characters: t.characters,
    adventureId: t.adventureId,
    isFinalEncounter: t.isFinalEncounter,
  };
}

export function rollD20(): number {
  return Math.floor(Math.random() * 20) + 1;
}

export function formatNumberToK(num: number): string {
  if (num >= 1000000) {
    return (num / 1000000).toFixed(1).replace(/\.0$/, "") + "m";
  }
  if (num >= 1000) {
    return (num / 1000).toFixed(1).replace(/\.0$/, "") + "k";
  }
  return num.toString();
}


/*
  File: lib/validations/roll-requirement-schema.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/validations/roll-requirement-schema.ts
  Directory: lib/validations
*/

--- File: lib/validations/roll-requirement-schema.ts ---

import { z } from "zod";

export const rollRequirementSchema = z.union([
  z.object({
    rollType: z.string().describe("The type of roll required, e.g. 'Stealth Check'"),
    difficulty: z.number().describe("The difficulty class (DC) for the roll"),
    modifier: z.number().optional().describe("Bonus or penalty to the roll, e.g. +2 or -1"),
  }),
  z.null()
]);

export type RollRequirement = z.infer<typeof rollRequirementSchema>; 

/*
  File: middleware.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/middleware.ts
  Directory: .
*/

--- File: middleware.ts ---

import { clerkMiddleware } from '@clerk/nextjs/server'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export default clerkMiddleware((auth, req: NextRequest) => {
  // Get the default response from Clerk
  const res = NextResponse.next();
  // Set the pathname as a custom header
  res.headers.set('x-pathname', req.nextUrl.pathname);
  return res;
});

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}

/*
  File: next.config.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/next.config.ts
  Directory: .
*/

--- File: next.config.ts ---

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'vibecodeparty-public.s3.us-east-1.amazonaws.com',
      },
      {
        protocol: 'https',
        hostname: 'vibecodeparty-public.s3.amazonaws.com',
      },
      {
        protocol: 'https',
        hostname: 'img.clerk.com',
      },
      {
        protocol: 'https',
        hostname: 'd1dkwd3w4hheqw.cloudfront.net',
      },
    ],
  },
};

export default nextConfig;


/*
  File: package.json
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/package.json
  Directory: .
*/

--- File: package.json ---

{
  "name": "d20adventures.com",
  "version": "0.1.0",
  "license": "None",
  "description": "A new narrative-driven RPG platform that blends play-by-post gameplay and real-time updates facilitated by an AI Game Master.",
  "keywords": [
    "nextjs",
    "template",
    "starter",
    "vibecoding"
  ],
  "author": "johnpolacek",
  "scripts": {
    "kill:ports": "kill-port 3000 4000 4400 4500 5001 8080 8085 9000 9099 9199 || true",
    "dev": "pnpm kill:ports && concurrently \"pnpm convex:dev\" \"next dev -p ${PORT:-3000}\" --kill-others --names \"convex,next\" --prefix-colors \"yellow.bold,cyan.bold\"",
    "convex:dev": "convex dev",
    "convex:deploy": "convex deploy",
    "build": "pnpm generate:routes && next build",
    "postinstall": "npx convex codegen",
    "start": "next start",
    "lint": "next lint",
    "boot:convex": "sh ./scripts/boot-convex.sh",
    "boot:github": "brew install gh && gh auth login",
    "boot:vercel": "pnpm i -g vercel",
    "boot:repo": "chmod +x ./scripts/init-repo.sh && ./scripts/init-repo.sh",
    "boot": "pnpm boot:github && pnpm boot:vercel && pnpm boot:convex && pnpm boot:repo",
    "go": "pnpm generate:routes && git add . && aicommits && pnpm generate:llm && git add . && git commit -m 'update llm.txt' && git push origin main",
    "test:run": "playwright test",
    "test:wait": "wait-on tcp:3000 tcp:4000 && pnpm test:run",
    "test": "pnpm build && concurrently \"pnpm dev\" \"pnpm test:wait\" --success first --kill-others --names \"dev,test\" --prefix-colors \"yellow.bold,cyan.bold\"",
    "ship": "pnpm test && pnpm go",
    "test:clean": "rm -rf ~/.cache/ms-playwright-tests test-results/ playwright-report/",
    "pw": "playwright test --ui --debug",
    "pw:headless": "playwright test",
    "db:admin": "open https://dashboard.convex.dev",
    "generate:routes": "tsx scripts/generate-routes.ts",
    "generate:llm": "tsx scripts/bundle-code.ts . llm.txt",
    "test:setup": "pnpm dev",
    "test:full": "pnpm test:setup && pnpm test"
  },
  "dependencies": {
    "@ai-sdk/google": "^1.2.18",
    "@ai-sdk/openai": "^1.3.22",
    "@ai-sdk/react": "^1.2.12",
    "@ai-sdk/replicate": "^0.2.8",
    "@aws-sdk/client-s3": "^3.812.0",
    "@aws-sdk/s3-request-presigner": "^3.812.0",
    "@clerk/backend": "^1.32.3",
    "@clerk/nextjs": "^6.19.5",
    "@clerk/themes": "^2.2.46",
    "@heroicons/react": "^2.2.0",
    "@octokit/rest": "^21.1.1",
    "@radix-ui/react-accordion": "^1.2.10",
    "@radix-ui/react-alert-dialog": "^1.1.13",
    "@radix-ui/react-avatar": "^1.1.9",
    "@radix-ui/react-checkbox": "^1.3.1",
    "@radix-ui/react-collapsible": "^1.1.10",
    "@radix-ui/react-dialog": "^1.1.13",
    "@radix-ui/react-dropdown-menu": "^2.1.14",
    "@radix-ui/react-icons": "^1.3.2",
    "@radix-ui/react-label": "^2.1.6",
    "@radix-ui/react-popover": "^1.1.13",
    "@radix-ui/react-progress": "^1.1.6",
    "@radix-ui/react-radio-group": "^1.3.6",
    "@radix-ui/react-scroll-area": "^1.2.8",
    "@radix-ui/react-select": "^2.2.4",
    "@radix-ui/react-separator": "^1.1.6",
    "@radix-ui/react-slot": "^1.2.2",
    "@radix-ui/react-switch": "^1.2.4",
    "@radix-ui/react-tabs": "^1.1.11",
    "@sendgrid/mail": "^8.1.5",
    "@stripe/react-stripe-js": "^3.7.0",
    "@stripe/stripe-js": "^7.3.0",
    "@types/lodash-es": "^4.17.12",
    "@types/react-google-recaptcha": "^2.1.9",
    "ai": "^4.3.16",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "convex": "^1.24.1",
    "date-fns": "^4.1.0",
    "eslint-config-prettier": "^10.1.5",
    "eslint-plugin-prettier": "^5.4.0",
    "ignore": "^7.0.4",
    "lodash-es": "^4.17.21",
    "lucide-react": "^0.511.0",
    "next": "15.3.2",
    "next-themes": "^0.4.6",
    "playwright": "link:@clerk/testing/playwright",
    "prettier": "^3.5.3",
    "react": "^19.1.0",
    "react-day-picker": "8.10.1",
    "react-dom": "^19.1.0",
    "react-google-recaptcha": "^3.1.0",
    "react-icons": "^5.5.0",
    "react-markdown": "^10.1.0",
    "server": "link:@clerk/nextjs/server",
    "slugify": "^1.6.6",
    "sonner": "^2.0.3",
    "stripe": "^18.1.1",
    "tailwind-merge": "^3.3.0",
    "tailwindcss-animate": "^1.0.7",
    "uuid": "^11.1.0",
    "waait": "^1.0.5",
    "zod": "^3.25.7",
    "zod-to-json-schema": "^3.24.5"
  },
  "devDependencies": {
    "@clerk/testing": "^1.7.2",
    "@eslint/eslintrc": "^3.3.1",
    "@playwright/test": "^1.52.0",
    "@tailwindcss/postcss": "^4.1.7",
    "@tailwindcss/typography": "^0.5.16",
    "@types/node": "^22.15.19",
    "@types/react": "^19.1.4",
    "@types/react-dom": "^19.1.5",
    "@types/uuid": "^10.0.0",
    "concurrently": "^9.1.2",
    "dotenv": "^16.5.0",
    "dotenv-cli": "^8.0.0",
    "eslint": "^9.27.0",
    "eslint-config-next": "15.3.2",
    "kill-port": "^2.0.1",
    "tailwindcss": "^4.1.7",
    "ts-node": "^10.9.2",
    "tsx": "^4.19.4",
    "typescript": "^5.8.3",
    "wait-on": "^8.0.3"
  }
}

/*
  File: playwright.config.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/playwright.config.ts
  Directory: .
*/

--- File: playwright.config.ts ---

import { defineConfig, devices } from '@playwright/test';
import path from 'path';

/**
 * Read environment variables from file.
 * https://github.com/motdotla/dotenv
 */
import dotenv from 'dotenv';
// Load environment variables in order of precedence (later files take precedence)
dotenv.config({ path: path.resolve(__dirname, '.env') });
dotenv.config({ path: path.resolve(__dirname, '.env.test') });
dotenv.config({ path: path.resolve(__dirname, '.env.local') });

/**
 * See https://playwright.dev/docs/test-configuration.
 */
export default defineConfig({
  testDir: './tests',
  /* Run tests in files in parallel - except in UI mode */
  fullyParallel: false,
  /* Fail the build on CI if you accidentally left test.only in the source code. */
  forbidOnly: !!process.env.CI,
  /* Retry on CI only */
  retries: process.env.CI ? 2 : 0,
  /* Opt out of parallel tests on CI or in UI mode */
  workers: 1,
  /* Reporter to use. See https://playwright.dev/docs/test-reporters */
  reporter: 'html',
  /* Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions. */
  use: {
    /* Base URL to use in actions like `await page.goto('/')`. */
    baseURL: 'http://localhost:3000',

    /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */
    trace: 'on-first-retry',
  },

  /* Configure projects for major browsers */
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },

    // {
    //   name: 'firefox',
    //   use: { ...devices['Desktop Firefox'] },
    // },

    // {
    //   name: 'webkit',
    //   use: { ...devices['Desktop Safari'] },
    // },

    /* Test against mobile viewports. */
    // {
    //   name: 'Mobile Chrome',
    //   use: { ...devices['Pixel 5'] },
    // },
    // {
    //   name: 'Mobile Safari',
    //   use: { ...devices['iPhone 12'] },
    // },

    /* Test against branded browsers. */
    // {
    //   name: 'Microsoft Edge',
    //   use: { ...devices['Desktop Edge'], channel: 'msedge' },
    // },
    // {
    //   name: 'Google Chrome',
    //   use: { ...devices['Desktop Chrome'], channel: 'chrome' },
    // },
  ],

  /* Since we're running the Next.js server separately, we don't need the webServer config */
  // webServer: {
  //   command: 'pnpm dev',
  //   url: 'http://127.0.0.1:3000',
  //   reuseExistingServer: !process.env.CI,
  //   timeout: 120000,
  // },
  
  /* Global setup to run before all tests */
  globalSetup: process.env.PLAYWRIGHT_UI_MODE ? undefined : './tests/global-setup.ts',
});


/*
  File: postcss.config.mjs
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/postcss.config.mjs
  Directory: .
*/

--- File: postcss.config.mjs ---

const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;


/*
  File: scripts/boot-convex.sh
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/scripts/boot-convex.sh
  Directory: scripts
*/

--- File: scripts/boot-convex.sh ---

#!/bin/bash

# Install Convex CLI globally
pnpm add -g convex@latest

# Check for CONVEX_DEPLOYMENT in Convex production environment
DEPLOY_KEY=$(npx convex env --prod get CONVEX_DEPLOYMENT 2>&1)

if echo "$DEPLOY_KEY" | grep -q 'not found'; then
  echo "\n\033[0;31m✖ Environment variable 'CONVEX_DEPLOYMENT' not found.\033[0m"
  echo "\nTo deploy with Convex, you need to set your deploy key."
  echo "1. Visit your Convex dashboard: https://dashboard.convex.dev"
  echo "2. Go to your project settings and copy the Deploy Key."
  echo "3. Add it to your environment variables as CONVEX_DEPLOYMENT."
  echo "\nExample (.env):\nCONVEX_DEPLOYMENT=your-deploy-key-here\n"
  # Try to get CONVEX_DEPLOYMENT from local .env
  if [ -f .env ]; then
    LOCAL_KEY=$(grep '^CONVEX_DEPLOYMENT=' .env | cut -d '=' -f2-)
    if [ -n "$LOCAL_KEY" ]; then
      echo "\033[0;34mFound CONVEX_DEPLOYMENT in local .env. Attempting to add to Vercel production env...\033[0m"
      TMPFILE=$(mktemp)
      echo "$LOCAL_KEY" > "$TMPFILE"
      if vercel env add CONVEX_DEPLOYMENT production < "$TMPFILE"; then
        echo "\033[0;32m✓ Successfully added CONVEX_DEPLOYMENT to Vercel production environment.\033[0m"
      else
        echo "\033[0;31m✖ Failed to add CONVEX_DEPLOYMENT to Vercel. Please add it manually.\033[0m"
      fi
      rm "$TMPFILE"
    fi
  fi
else
  echo "\033[0;32m✓ CONVEX_DEPLOYMENT found in Convex production environment.\033[0m"
fi 

/*
  File: scripts/bundle-code.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/scripts/bundle-code.ts
  Directory: scripts
*/

--- File: scripts/bundle-code.ts ---

#!/usr/bin/env node

import fs from 'fs/promises';
import path from 'path';
import ignore from 'ignore';
import type { Dirent } from 'fs'; // Import Dirent type

// --- Configuration ---

// Directories to exclude entirely
const EXCLUDED_DIRS: Set<string> = new Set([
    'node_modules',
    '.git',
    '.next',
    'dist',
    'build',
    'out',
    'coverage',
    '.vscode',
    '.idea',
    'public', // Often contains large assets, adjust if needed
    // Add any other directories you want to skip
]);

// Specific files or patterns to exclude
const EXCLUDED_FILES_PATTERNS: string[] = [
    'package-lock.json',
    'yarn.lock',
    'pnpm-lock.yaml',
    '.DS_Store',
    // Add any specific files or patterns
];

// File extensions or specific filenames to include (add more as needed)
const INCLUDED_EXTENSIONS: Set<string> = new Set([
    // Extensions
    '.js',
    '.jsx',
    '.ts',
    '.tsx',
    '.mjs',
    '.cjs',
    '.css',
    '.scss',
    '.sass',
    '.less',
    '.html',
    '.md',
    '.json',
    '.yaml',
    '.yml',
    '.sh',
    '.env',
    '.env.local',
    '.env.development',
    '.env.production',
    '.env.example', // Often useful for context
    '.gitignore', // Useful for context
    '.npmrc',
    // Specific filenames (often config files)
    'next.config.js',
    'next.config.mjs',
    'postcss.config.js',
    'tailwind.config.js',
    'tailwind.config.ts',
    'tsconfig.json',
    'jsconfig.json',
    '.eslintrc.json',
    '.prettierrc',
    'Dockerfile',
    // Add specific filenames relevant to your project
]);

// Initialize gitignore
let ig = ignore();

async function loadGitignore(projectRoot: string): Promise<void> {
    try {
        const gitignorePath = path.join(projectRoot, '.gitignore');
        const gitignoreContent = await fs.readFile(gitignorePath, 'utf-8');
        ig = ignore().add(gitignoreContent);
    } catch (err: unknown) {
        if (err && typeof err === 'object' && 'code' in err && err.code === 'ENOENT') {
            console.log('No .gitignore file found, continuing without it');
        } else if (err instanceof Error) {
            console.error('Error reading .gitignore:', err.message);
        }
    }
}

// --- Helper Functions ---

function isExcluded(entryPath: string, entryName: string, isDirectory: boolean): boolean {
    // Check gitignore patterns first
    const relativePath = entryPath.replace(/\\/g, '/'); // Normalize path separators
    if (ig.ignores(relativePath)) {
        return true;
    }

    // Then check our manual exclusions
    if (isDirectory && EXCLUDED_DIRS.has(entryName)) {
        return true;
    }
    if (!isDirectory && EXCLUDED_FILES_PATTERNS.some(pattern => entryName === pattern)) {
        // Add more complex pattern matching here if needed (e.g., regex)
        return true;
    }
     // Check if the path contains an excluded directory component
    const pathParts = entryPath.split(path.sep);
    if (pathParts.some(part => EXCLUDED_DIRS.has(part))) {
       return true;
    }
    return false;
}

function isIncluded(entryName: string): boolean {
    const ext = path.extname(entryName).toLowerCase();
    // Check by specific name first, then by extension
    return INCLUDED_EXTENSIONS.has(entryName) || (ext !== '' && INCLUDED_EXTENSIONS.has(ext));
}

async function walkDir(dir: string, projectRoot: string, allContents: string[]): Promise<void> {
    let entries: Dirent[];
    try {
        entries = await fs.readdir(dir, { withFileTypes: true });
    } catch (err: unknown) {
        if (err instanceof Error) {
            console.error(`Error reading directory ${dir}: ${err.message}`);
        }
        return; // Skip directories we can't read
    }

    for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        const relativePath = path.relative(projectRoot, fullPath);

        if (isExcluded(relativePath, entry.name, entry.isDirectory())) {
            console.log(`(-) Excluding: ${relativePath}`);
            continue;
        }

        if (entry.isDirectory()) {
            await walkDir(fullPath, projectRoot, allContents);
        } else if (entry.isFile() && isIncluded(entry.name)) {
            try {
                console.log(`(+) Including: ${relativePath}`);
                const content = await fs.readFile(fullPath, 'utf-8');
                // Normalize line endings to prevent excessive diffs if files have mixed endings
                const normalizedContent = content.replace(/\r\n/g, '\n');
                // Directory structure (relative, split by path.sep, joined by /)
                const dirStructure = path.dirname(relativePath).split(path.sep).filter(Boolean).join('/');
                // Reference comment block
                const referenceBlock = `/*\n  File: ${relativePath}\n  Absolute: ${fullPath}\n  Directory: ${dirStructure || '.'}\n*/\n`;
                allContents.push(`${referenceBlock}\n--- File: ${relativePath} ---\n\n${normalizedContent}\n\n`);
            } catch (err: unknown) {
                if (err instanceof Error) {
                    console.error(`Error reading file ${fullPath}: ${err.message}`);
                    // Directory structure for error case
                    const dirStructure = path.dirname(relativePath).split(path.sep).filter(Boolean).join('/');
                    const referenceBlock = `/*\n  File: ${relativePath}\n  Absolute: ${fullPath}\n  Directory: ${dirStructure || '.'}\n*/\n`;
                    allContents.push(`${referenceBlock}\n--- File: ${relativePath} ---\n\n!!! Error reading file: ${err.message} !!!\n\n`);
                }
            }
        } else {
             // Optional: Log files that are neither excluded nor included
             // console.log(`(?) Skipping (not included): ${relativePath}`);
        }
    }
}

// --- Main Execution ---

async function main(): Promise<void> {
    // Basic argument parsing: tsx scripts/bundle-code.ts [targetDir] [outputFile]
    const args: string[] = process.argv.slice(2);
    const targetDirArg: string | undefined = args[0];
    const outputFileArg: string | undefined = args[1];

    const targetDir: string = path.resolve(targetDirArg || '.'); // Default to current directory
    const outputFilePath: string | null = outputFileArg ? path.resolve(outputFileArg) : null; // Default to console output

    // Load .gitignore before processing
    await loadGitignore(targetDir);

    console.log(`Scanning directory: ${targetDir}`);
    if (outputFilePath) {
        console.log(`Output will be written to: ${outputFilePath}`);
    } else {
        console.log(`Output will be printed to console.`);
    }

    const allContents: string[] = [];
    try {
        // Check if target directory exists
        const stats = await fs.stat(targetDir);
        if (!stats.isDirectory()) {
            throw new Error(`Target path is not a directory: ${targetDir}`);
        }

        await walkDir(targetDir, targetDir, allContents);

        const combinedOutput: string = allContents.join('');

        if (outputFilePath) {
            await fs.writeFile(outputFilePath, combinedOutput);
            console.log(`\n✅ Successfully wrote bundled code to ${outputFilePath}`);
        } else {
            console.log("\n--- BUNDLED CODE OUTPUT ---");
            console.log(combinedOutput);
            console.log("--- END BUNDLED CODE OUTPUT ---");
            console.log(`\n✅ Successfully generated bundled code.`);
        }

    } catch (err: unknown) {
        if (err && typeof err === 'object' && 'code' in err && err.code === 'ENOENT') {
            console.error(`\n❌ Error: Target directory not found: ${targetDir}`);
        } else if (err instanceof Error) {
            console.error(`\n❌ An error occurred: ${err.message}`);
            console.error(err.stack); // Print stack trace for debugging
        }
        process.exit(1); // Exit with error code
    }
}

main();

/*
  File: scripts/generate-routes.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/scripts/generate-routes.ts
  Directory: scripts
*/

--- File: scripts/generate-routes.ts ---

import fs from 'fs'
import path from 'path'

// Function to get all route paths from the app directory
function getRoutePaths(dir: string, basePath: string = ''): string[] {
  const entries = fs.readdirSync(dir, { withFileTypes: true })
  const paths: string[] = []

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name)
    const routePath = path.join(basePath, entry.name)

    if (entry.isDirectory()) {
      // Skip private folders (starting with _) and api routes
      if (entry.name.startsWith('_') || entry.name === 'api') {
        continue
      }

      // Handle dynamic routes
      const routeName = entry.name.startsWith('[') ? entry.name : null
      if (routeName) {
        // Add the dynamic route pattern
        paths.push(path.join(basePath, '*'))
      } else {
        // Recursively get routes from subdirectories
        paths.push(...getRoutePaths(fullPath, routePath))
      }
    } else if (entry.name === 'page.tsx' || entry.name === 'page.ts') {
      // Add the route path for page files
      paths.push(basePath)
    }
  }

  return paths
}

// Generate the routes file
function generateRoutesFile() {
  const appDir = path.join(process.cwd(), 'app')
  const routePaths = getRoutePaths(appDir)
  
  // Format the paths
  const formattedPaths = routePaths
    .map(p => p.replace(/\\/g, '/')) // Convert Windows paths to forward slashes
    .map(p => p || '/') // Convert empty string to root path
    .sort()

  // Generate the file content
  const fileContent = `// This file is auto-generated. DO NOT EDIT IT MANUALLY.
// It is used to generate the validRoutes for tracking user visits.
// To regenerate, run: pnpm generate:routes

export const validRoutes = new Set([
  ${formattedPaths.map(p => `'${p}'`).join(',\n  ')}
])
`

  // Write the file
  const outputPath = path.join(process.cwd(), 'lib', 'generated', 'routes.ts')
  fs.mkdirSync(path.dirname(outputPath), { recursive: true })
  fs.writeFileSync(outputPath, fileContent)

  console.log('✅ Generated routes file')
}

generateRoutesFile() 

/*
  File: scripts/init-repo.sh
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/scripts/init-repo.sh
  Directory: scripts
*/

--- File: scripts/init-repo.sh ---

#!/bin/bash

# --- Configuration ---
# Set this to the main branch name you prefer (usually main or master)
MAIN_BRANCH_NAME="main"
# Set to 'true' if you want to automatically confirm Vercel deployments
AUTO_CONFIRM_VERCEL="true"

# --- Error Handling ---
# Exit immediately if a command exits with a non-zero status.
set -e

# Keep track of errors
ERRORS=()

# Function to report errors and exit
handle_error() {
    local command="$1"
    local message="$2"
    ERRORS+=("Error running command: $command")
    ERRORS+=("Details: $message")
    echo "-----------------------------------------------------" >&2
    echo "❌ FATAL ERROR during setup process ❌" >&2
    echo "Command failed: $command" >&2
    echo "Error details: $message" >&2
    echo "Setup process aborted." >&2
    echo "-----------------------------------------------------" >&2
    if [ ${#ERRORS[@]} -gt 0 ]; then
        echo "Summary of errors:" >&2
        for error in "${ERRORS[@]}"; do
            echo "- $error" >&2
        done
    fi
    exit 1
}

# Function to open URL in browser based on OS
open_url() {
    local url=$1
    case "$OSTYPE" in
        "darwin"*) # macOS
            open "$url"
            ;;
        "linux"*) # Linux
            if command -v xdg-open > /dev/null; then
                xdg-open "$url"
            elif command -v gnome-open > /dev/null; then
                gnome-open "$url"
            else
                echo "Could not detect the web browser to use."
            fi
            ;;
        *) # Other OS
            echo "Could not detect the web browser to use."
            ;;
    esac
}

# Function to read value from .env file
get_env_value() {
    local key=$1
    local value=""
    if [ -f ".env" ]; then
        value=$(grep "^${key}=" .env | cut -d '=' -f2)
    fi
    echo "$value"
}

# Function to add or update value in .env file
update_env_file() {
    local key=$1
    local value=$2
    local env_file=".env"
    
    # Create .env if it doesn't exist
    if [ ! -f "$env_file" ]; then
        touch "$env_file"
    fi
    
    # Check if key exists and replace, otherwise add
    if grep -q "^${key}=" "$env_file"; then
        if [[ "$OSTYPE" == "darwin"* ]]; then
            sed -i '' "s|^${key}=.*|${key}=${value}|" "$env_file"
        else
            sed -i "s|^${key}=.*|${key}=${value}|" "$env_file"
        fi
    else
        echo "${key}=${value}" >> "$env_file"
    fi
}

# Function to deploy all env vars to Vercel
deploy_env_to_vercel() {
    local env_file=".env"
    if [ ! -f "$env_file" ]; then
        echo "No .env file found. Skipping environment variable deployment."
        return
    fi

    echo "Deploying environment variables to Vercel..."
    
    # Read each line from .env
    while IFS= read -r line || [ -n "$line" ]; do
        # Skip empty lines and comments
        if [ -z "$line" ] || [[ $line == \#* ]]; then
            continue
        fi
        
        # Extract key and value
        if [[ $line =~ ^([^=]+)=(.*)$ ]]; then
            key="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"
            
            # Remove any surrounding quotes from the value
            value=$(echo "$value" | sed -e 's/^"//' -e 's/"$//' -e "s/^'//" -e "s/'$//")
            
            echo "Setting $key in Vercel..."
            
            # Add to environment
            vercel env add "$key" production "$value" > /dev/null 2>&1
        fi
    done < "$env_file"
    
    echo "✅ Environment variables deployed to Vercel"
}

# --- Get User Input ---

echo "🚀 Starting Project Initialization 🚀"
echo ""

# Get current directory name as default repo name
DEFAULT_REPO_NAME=$(basename "$PWD")

# Prompt for the GitHub repository name with default suggestion
read -p "Enter the desired GitHub repository name [$DEFAULT_REPO_NAME]: " REPO_NAME
REPO_NAME=${REPO_NAME:-$DEFAULT_REPO_NAME}

if [ -z "$REPO_NAME" ]; then
  handle_error "User Input" "No repository name provided."
fi

# Prompt for repository visibility with public as default
read -p "Enter repository visibility [public/private]: " REPO_VISIBILITY_INPUT
REPO_VISIBILITY=${REPO_VISIBILITY_INPUT:-"public"}

# Validate repository visibility input
REPO_VISIBILITY=$(echo "$REPO_VISIBILITY" | tr '[:upper:]' '[:lower:]') # Convert to lowercase
if [[ "$REPO_VISIBILITY" != "public" && "$REPO_VISIBILITY" != "private" ]]; then
  handle_error "User Input" "Invalid visibility '$REPO_VISIBILITY_INPUT'. Please enter 'public' or 'private'."
fi

# Get the GitHub username using the authenticated GH CLI
GITHUB_USERNAME=$(gh api user --jq .login 2>/dev/null) || handle_error "gh api user" "Could not retrieve GitHub username. Is 'gh auth login' complete?"

FULL_REPO_NAME="$GITHUB_USERNAME/$REPO_NAME"
GIT_REMOTE_URL="git@github.com:$FULL_REPO_NAME.git" # Using SSH URL

echo ""
echo "--- Project Details ---"
echo "Local Directory: $(pwd)"
echo "GitHub Repository: $FULL_REPO_NAME ($REPO_VISIBILITY)"
echo "Vercel Linking Git URL: $GIT_REMOTE_URL"
echo "Main Branch: $MAIN_BRANCH_NAME"
echo "-----------------------"
echo ""
read -p "Does this look correct? [Y/n]: " confirm
if [[ "$confirm" =~ ^[Nn]$ ]]; then
    echo "Setup cancelled by user."
    exit 1
fi

echo "" # Add space before next section

# --- Step 1: Initialize Git Repository (if not already) ---
echo "--- 1/4: Setting up local Git repository ---"

# Check if .git directory exists. If not, initialize.
if [ ! -d ".git" ]; then
  git init || handle_error "git init" "Failed to initialize Git repository."
  echo "Git repository initialized."
else
  echo "Existing Git repository found."
fi

# Update config.ts with GitHub URL before initial commit if public repo
if [ "$REPO_VISIBILITY" == "public" ]; then
    config_file="lib/config.ts"
    if [ -f "$config_file" ]; then
        # Use sed to update the github field in config.ts
        # The pattern looks for the 'github: ""' line and replaces it with the new URL
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS requires an empty string after -i
            sed -i '' "s|github: \".*\"|github: \"https://github.com/$FULL_REPO_NAME\"|" "$config_file"
        else
            # Linux version
            sed -i "s|github: \".*\"|github: \"https://github.com/$FULL_REPO_NAME\"|" "$config_file"
        fi
        echo "Updated $config_file with GitHub repository URL"
    else
        ERRORS+=("Warning: Could not find $config_file to update GitHub URL")
    fi
fi

# Add all current files and commit
git add . || handle_error "git add ." "Failed to add files to staging."
# Check if there are staged changes before committing
if git diff --cached --quiet; then
    echo "No new changes to commit. Skipping commit step."
else
    git commit -m "Initial commit from init script" || handle_error "git commit" "Failed to create initial commit."
    echo "Initial commit created."
fi


# Ensure the main branch exists and is named correctly
# Use '--force' to rename if it exists with a different case (like master)
if git branch --list | grep -q "\b$MAIN_BRANCH_NAME\b"; then
    echo "Branch '$MAIN_BRANCH_NAME' already exists."
elif git branch --list | grep -q "\bmaster\b" && [ "$MAIN_BRANCH_NAME" == "main" ]; then
    git branch -m $MAIN_BRANCH_NAME || handle_error "git branch -m" "Failed to rename branch from 'master' to '$MAIN_BRANCH_NAME'."
    echo "Renamed 'master' branch to '$MAIN_BRANCH_NAME'."
else
     # Create the branch if it doesn't exist and there's no master to rename
     # This case is less common after git init and commit, but good practice
     # Check if HEAD exists first (implies a commit has been made)
     if git rev-parse --verify HEAD > /dev/null 2>&1; then
        git branch $MAIN_BRANCH_NAME || handle_error "git branch" "Failed to create '$MAIN_BRANCH_NAME' branch."
        git checkout $MAIN_BRANCH_NAME || handle_error "git checkout" "Failed to checkout '$MAIN_BRANCH_NAME' branch."
        echo "Created and checked out '$MAIN_BRANCH_NAME' branch."
     else
         # No commits yet, branch will be created upon first commit/push
         echo "No commits yet, branch '$MAIN_BRANCH_NAME' will be set on push."
     fi
fi
git checkout $MAIN_BRANCH_NAME > /dev/null 2>&1 || handle_error "git checkout" "Failed to ensure checkout of '$MAIN_BRANCH_NAME'."
echo "Ensured checkout of branch '$MAIN_BRANCH_NAME'."


echo "Local Git setup complete."
echo ""

# --- Step 2: Create GitHub Repository and Push ---
echo "--- 2/4: Creating GitHub repository and pushing ---"

# Check if origin remote already exists and points to the correct repo
echo "Checking for existing git remote..."
CURRENT_ORIGIN=$(git remote get-url origin 2>/dev/null || echo "")

if [ -n "$CURRENT_ORIGIN" ]; then
    echo "Found existing remote: $CURRENT_ORIGIN"
    # Normalize the URLs for comparison (both SSH format)
    EXPECTED_URL="git@github.com:$FULL_REPO_NAME.git"
    if [ "$CURRENT_ORIGIN" = "$EXPECTED_URL" ]; then
        echo "✓ Git remote 'origin' already exists and points to correct repository"
        echo "Continuing with existing remote..."
    else
        echo "Warning: Git remote 'origin' exists but points to unexpected repository"
        echo "Current:  $CURRENT_ORIGIN"
        echo "Expected: $EXPECTED_URL"
        handle_error "Git Remote Conflict" "Existing 'origin' remote points to unexpected repository. Please resolve manually."
    fi
else
    echo "No existing remote found. Creating new repository..."
    
    # Create the repository and push in one command
    echo "Creating GitHub repository '$FULL_REPO_NAME' ($REPO_VISIBILITY)..."
    
    CREATE_COMMAND=""
    if [ "$REPO_VISIBILITY" == "private" ]; then
        CREATE_COMMAND="gh repo create \"$REPO_NAME\" --private --source=. --remote=origin --push"
    else
        CREATE_COMMAND="gh repo create \"$REPO_NAME\" --public --source=. --remote=origin --push"
    fi
    
    echo "Executing: $CREATE_COMMAND"
    eval "$CREATE_COMMAND" || {
        echo "Error occurred while creating repository. Exit code: $?"
        handle_error "gh repo create" "Failed to create and push to $REPO_VISIBILITY GitHub repository '$FULL_REPO_NAME'."
    }
    
    echo "GitHub repository created and code pushed successfully."
fi

echo "GitHub setup and push complete."
echo ""

# --- Step 3: Link Project to Vercel and GitHub ---
echo "--- 3/4: Linking project to Vercel and GitHub ---"

# Check if Vercel project is already linked
if vercel status --connected 2>/dev/null; then
    echo "Vercel project is already linked."
else
    echo "Linking project to Vercel..."
    # First link the project
    echo "Running: vercel link"
    vercel link || handle_error "vercel link" "Failed to link project to Vercel."
fi

# Check if Git is already connected
echo "Checking Git connection status..."
if vercel git ls 2>&1 | grep -q "$FULL_REPO_NAME"; then
    echo "✓ GitHub repository $FULL_REPO_NAME is already connected to Vercel"
else
    # Connect to GitHub
    echo "Connecting to GitHub repository..."
    echo "Running: vercel git connect"
    if ! output=$(vercel git connect 2>&1); then
        # Check if the error is just that it's already connected
        if echo "$output" | grep -q "is already connected to your project"; then
            echo "✓ GitHub repository is already connected to Vercel"
        else
            echo "$output"
            handle_error "vercel git connect" "Failed to connect GitHub repository to Vercel."
        fi
    fi
fi

echo "Project linked to Vercel and GitHub connection established."
echo ""

# Set up Clerk environment variables if not in .env
echo ""
echo "Setting up Clerk environment variables..."
echo "These are required for authentication to work. You can find them in your Clerk Dashboard."
echo "Visit https://dashboard.clerk.com/ to get your keys."
echo ""

# Try to get values from .env first
CLERK_PUB_KEY=$(get_env_value "NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY")
CLERK_SECRET_KEY=$(get_env_value "CLERK_SECRET_KEY")

# Function to validate Clerk key format
validate_clerk_key() {
    local key=$1
    local key_type=$2
    
    if [ -z "$key" ]; then
        return 1
    fi
    
    # Public key should start with pk_test_ or pk_live_
    if [ "$key_type" = "public" ] && ! [[ $key =~ ^pk_(test|live)_ ]]; then
        return 1
    fi
    
    # Secret key should start with sk_test_ or sk_live_
    if [ "$key_type" = "secret" ] && ! [[ $key =~ ^sk_(test|live)_ ]]; then
        return 1
    fi
    
    return 0
}

# Handle public key
if validate_clerk_key "$CLERK_PUB_KEY" "public"; then
    echo "✓ Using existing NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY from .env"
else
    while ! validate_clerk_key "$CLERK_PUB_KEY" "public"; do
        if [ -n "$CLERK_PUB_KEY" ]; then
            echo "❌ Invalid Clerk publishable key format. It should start with pk_test_ or pk_live_"
        else
            echo "NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY not found in .env"
        fi
        echo "Visit https://dashboard.clerk.com/last-active/api-keys to get your publishable key"
        read -p "Enter your NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: " CLERK_PUB_KEY
    done
    # Only update .env if we had to ask for a new value
    update_env_file "NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY" "$CLERK_PUB_KEY"
fi

# Handle secret key
if validate_clerk_key "$CLERK_SECRET_KEY" "secret"; then
    echo "✓ Using existing CLERK_SECRET_KEY from .env"
else
    while ! validate_clerk_key "$CLERK_SECRET_KEY" "secret"; do
        if [ -n "$CLERK_SECRET_KEY" ]; then
            echo "❌ Invalid Clerk secret key format. It should start with sk_test_ or sk_live_"
        else
            echo "CLERK_SECRET_KEY not found in .env"
        fi
        echo "Visit https://dashboard.clerk.com/last-active/api-keys to get your secret key"
        read -p "Enter your CLERK_SECRET_KEY: " CLERK_SECRET_KEY
    done
    # Only update .env if we had to ask for a new value
    update_env_file "CLERK_SECRET_KEY" "$CLERK_SECRET_KEY"
fi

# Function to add env var to Vercel for production
add_vercel_env() {
    local key=$1
    local value=$2
    
    echo "----------------------------------------"
    echo "🔄 Setting up $key for production environment"
    
    # First try to remove any existing value
    echo "Removing existing $key from production environment if it exists..."
    vercel env rm "$key" production || {
        echo "Note: No existing variable to remove or removal failed (this is usually ok)"
    }
    
    # Create a temporary file
    local tmp_file
    tmp_file=$(mktemp)
    echo "$value" > "$tmp_file"
    
    # Add the new value
    echo "Adding $key to production environment..."
    echo "Running environment variable add command..."
    if vercel env add "$key" production < "$tmp_file"; then
        echo "✅ Successfully added $key to production environment"
        rm "$tmp_file"
    else
        local exit_code=$?
        echo "❌ Failed to add environment variable"
        echo "Exit code: $exit_code"
        rm "$tmp_file"
        handle_error "vercel env add" "Failed to add $key to Vercel production environment (exit code: $exit_code)"
    fi
    echo "----------------------------------------"
}

# Add variables to production environment
echo "🔐 Setting up Clerk environment variables in Vercel..."
echo ""
add_vercel_env "NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY" "$CLERK_PUB_KEY"
add_vercel_env "CLERK_SECRET_KEY" "$CLERK_SECRET_KEY"

echo ""
echo "✅ Clerk environment variables have been set up successfully."
echo ""

# --- Step 4: Final Vercel Deployment ---
echo "--- 4/4: Initiating Vercel deployment ---"

VERCEL_DEPLOY_COMMAND="vercel deploy --confirm"
echo "Running: $VERCEL_DEPLOY_COMMAND"
$VERCEL_DEPLOY_COMMAND || handle_error "$VERCEL_DEPLOY_COMMAND" "Failed to initiate Vercel deployment."
echo "Vercel deployment initiated."
echo ""


# --- Completion ---
echo "🎉 Project Initialization Complete! 🎉"
echo "Your project is now:"
echo "- Local Git repository initialized and committed."
echo "- GitHub repository created at https://github.com/$FULL_REPO_NAME"
echo "- Code pushed to the '$MAIN_BRANCH_NAME' branch on GitHub."
echo "- Vercel project linked to the GitHub repository."
echo "- Vercel deployment triggered. Visit your Vercel dashboard to see the status."

# Open Vercel project in browser
echo ""
echo "Opening Vercel project in browser..."
VERCEL_PROJECT_URL=$(vercel project ls --json | grep -o '"url":"[^"]*"' | head -1 | cut -d'"' -f4)
if [ -n "$VERCEL_PROJECT_URL" ]; then
    open_url "https://$VERCEL_PROJECT_URL"
else
    echo "Could not determine Vercel project URL."
fi

if [ ${#ERRORS[@]} -gt 0 ]; then
    echo ""
    echo "⚠️ Warnings and Non-Fatal Issues Encountered: ⚠️"
    for error in "${ERRORS[@]}"; do
        # Filter out the fatal error header if it was added by handle_error
        if [[ "$error" != *"FATAL ERROR"* && "$error" != *"Summary of errors:"* && "$error" != *"- Error running command:"* && "$error" != *"- Details:"* ]]; then
            echo "- $error"
        fi
    done
    echo "Please review the output above for details."
fi

exit 0


/*
  File: tailwind.config.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/tailwind.config.ts
  Directory: .
*/

--- File: tailwind.config.ts ---

import type { Config } from "tailwindcss"
import tailwindcssAnimate from "tailwindcss-animate"
import typography from '@tailwindcss/typography'

const config = {
  darkMode: "class",
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
    "*.{js,ts,jsx,tsx,mdx}",
  ],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar))",
          foreground: "hsl(var(--sidebar-foreground))",
          border: "hsl(var(--sidebar-border))",
          primary: "hsl(var(--sidebar-primary))",
          "primary-foreground": "hsl(var(--sidebar-primary-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
        float: {
          "0%, 100%": { transform: "translateY(0)" },
          "50%": { transform: "translateY(-20px)" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        float: "float 15s ease-in-out infinite",
      },
      typography: {
        DEFAULT: {
          css: {
            maxWidth: 'none',
            color: 'hsl(var(--foreground))',
            a: {
              color: 'hsl(var(--primary))',
              textDecoration: 'underline',
              fontWeight: '500',
            },
            h1: {
              color: 'hsl(var(--foreground))',
            },
            h2: {
              color: 'hsl(var(--foreground))',
            },
            h3: {
              color: 'hsl(var(--foreground))',
            },
            h4: {
              color: 'hsl(var(--foreground))',
            },
            code: {
              color: 'hsl(var(--foreground))',
              backgroundColor: 'hsl(var(--muted))',
              borderRadius: '0.25rem',
              padding: '0.15rem 0.3rem',
            },
            pre: {
              backgroundColor: 'hsl(var(--muted))',
              borderRadius: '0.5rem',
              padding: '1rem',
            },
            blockquote: {
              color: 'hsl(var(--muted-foreground))',
              borderLeftColor: 'hsl(var(--border))',
            },
            hr: {
              borderColor: 'hsl(var(--border))',
            },
            strong: {
              color: 'hsl(var(--foreground))',
            },
            thead: {
              color: 'hsl(var(--foreground))',
              borderBottomColor: 'hsl(var(--border))',
            },
            tbody: {
              tr: {
                borderBottomColor: 'hsl(var(--border))',
              },
            },
          },
        },
      },
    },
  },
  plugins: [
    tailwindcssAnimate,
    typography,
  ],
} satisfies Config

export default config



/*
  File: tests/admin.spec.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/tests/admin.spec.ts
  Directory: tests
*/

--- File: tests/admin.spec.ts ---

import { test, expect } from '@playwright/test';
import { setupAuthenticatedUser, setupCleanDatabase } from './utils/test-helpers';

test('should not be public', async ({ page }) => {
  await page.goto('/admin');
  await expect(page.getByRole('heading', { name: 'Access Denied' })).toBeVisible();
  await expect(page.getByRole('heading', { name: 'Development Environment' })).toBeVisible();
});

test('should load the admin dashboard', async ({ page }) => {
  // Reset database before this test
    await setupCleanDatabase();
    
    // Login as test user
    await setupAuthenticatedUser(page);
    
    // Navigate to the page
    await page.goto('/admin');
    await expect(page.getByRole('heading', { name: 'Admin Dashboard' })).toBeVisible();
});

test('can view analytics', async ({ page }) => {
  // Reset database before this test
    await setupCleanDatabase();
    
    // Login as test user
    await setupAuthenticatedUser(page);
    
    // Navigate to the page
    await page.goto('/admin/analytics');
    await expect(page.getByRole('heading', { name: 'Analytics' })).toBeVisible();
    await expect(page.getByRole('heading', { name: 'Total Visits (30 Days)' })).toBeVisible();
    await expect(page.getByRole('heading', { name: 'Recent Visits' })).toBeVisible();
});

test('can view mailing list', async ({ page }) => {
  // Reset database before this test
    await setupCleanDatabase();
    
    // Login as test user
    await setupAuthenticatedUser(page);

    // Navigate to the page
    await page.goto('/admin/mailing-list');
    await expect(page.getByRole('heading', { name: 'Mailing List' })).toBeVisible();    
});
  

/*
  File: tests/auth.spec.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/tests/auth.spec.ts
  Directory: tests
*/

--- File: tests/auth.spec.ts ---

import { test, expect } from '@playwright/test';

test('should be able to fill out the sign up form', async ({ page }) => {
  await page.goto('http://localhost:3000');
  await page.getByRole('button', { name: 'Sign Up' }).click();
  await page.getByRole('textbox', { name: 'Email address' }).fill('hey@gmail.com');
  await page.getByRole('textbox', { name: 'Password' }).fill('GoodVibrations');
  await expect(page.getByRole('button', { name: 'Continue' })).toBeVisible();
});


/*
  File: tests/contact.spec.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/tests/contact.spec.ts
  Directory: tests
*/

--- File: tests/contact.spec.ts ---

import { test, expect } from '@playwright/test';

test('should be able to fill out the contact form', async ({ page }) => {
  await page.goto('http://localhost:3000/contact');
  await expect(page.getByText('Contact Us')).toBeVisible();
  await page.getByRole('textbox', { name: 'Name' }).fill('Kickin Poppin');
  await page.getByRole('textbox', { name: 'Email' }).fill('kickin@poppin.com');
  await page.getByRole('textbox', { name: 'Message' }).fill('Hey Yo');
});


/*
  File: tests/global-setup.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/tests/global-setup.ts
  Directory: tests
*/

--- File: tests/global-setup.ts ---

import { setupTestDatabase } from "./utils/db-reset"

/**
 * Global setup function that runs before all tests
 */
export default async function globalSetup() {
  await setupTestDatabase()
} 

/*
  File: tests/subscribe.spec.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/tests/subscribe.spec.ts
  Directory: tests
*/

--- File: tests/subscribe.spec.ts ---

import { test, expect } from '@playwright/test';
import { setupAuthenticatedUser, setupCleanDatabase } from './utils/test-helpers';
import { ConvexHttpClient } from "convex/browser";
import { api } from "@/convex/_generated/api";
import { Doc } from "@/convex/_generated/dataModel";

type MailingListSubscription = Doc<"mailing_list_subscriptions">;

// Initialize Convex client for test verification
const convex = new ConvexHttpClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

// Helper function to safely cast Convex response
async function getSubscriptions() {
  const response = await convex.query(api.mailingList.getSubscriptions);
  return response as unknown as MailingListSubscription[];
}

test('should have to sign in to subscribe', async ({ page }) => {
  await page.goto('http://localhost:3000/mailing-list');
  await expect(page.getByText('Please sign in to subscribe')).toBeVisible();
});

test('should be able to subscribe to the mailing list when signed in', async ({ page }) => {
  // Reset database before this test
  await setupCleanDatabase();
  
  // Login as test user
  await setupAuthenticatedUser(page);

  // Subscribe
  await page.goto('http://localhost:3000/mailing-list');
  
  // Wait for the form to be ready
  await page.waitForSelector('button:has-text("Subscribe")');

  // Click subscribe and wait for navigation/refresh
  await page.getByRole('button', { name: 'Subscribe' }).click();
  await page.waitForLoadState('networkidle');
  
  // Check for success message
  const toastText = await page.getByText('Successfully subscribed').textContent();
  console.log('Toast message:', toastText);
  
  // Check subscription status
  const statusText = await page.getByText('You are currently subscribed').textContent();
  console.log('Status message:', statusText);

  // Verify the document in Convex
  const subscriptions = await getSubscriptions();
  const subscription = subscriptions.find(s => s.email === 'john.polacek@gmail.com');
  expect(subscription).toBeTruthy();
  expect(subscription?.email).toBe('john.polacek@gmail.com');
  expect(subscription?.subscribedAt).toBeTruthy();
  expect(subscription?.unsubscribedAt).toBeNull();

  // Navigate to admin and check list
  await page.goto('http://localhost:3000/admin/mailing-list');
  await page.waitForLoadState('networkidle');

  // Wait for page to load and data to be fetched
  await expect(page.getByRole('heading', { name: 'Mailing List Subscribers' })).toBeVisible();
  
  // Check if email is in the list
  const emailCell = page.getByRole('cell', { name: 'john.polacek@gmail.com' });
  const isEmailVisible = await emailCell.isVisible();
  console.log('Email visible in admin list:', isEmailVisible);
  await expect(emailCell).toBeVisible();
  
  // Unsubscribe
  await page.goto('http://localhost:3000/mailing-list');
  await page.getByRole('button', { name: 'Unsubscribe' }).click();
  await expect(page.getByText('Subscribe to Our Mailing List')).toBeVisible();
  await page.goto('http://localhost:3000/admin/mailing-list');
  await expect(page.getByRole('cell', { name: 'john.polacek@gmail.com' })).toBeVisible();
  await expect(page.getByText('Unsubscribed')).toBeVisible();

  // Verify unsubscribe in Convex
  const updatedSubscriptions = await getSubscriptions();
  const unsubscription = updatedSubscriptions.find(s => s.email === 'john.polacek@gmail.com');
  expect(unsubscription).toBeTruthy();
  expect(unsubscription?.unsubscribedAt).toBeTruthy();
});


/*
  File: tests/utils/auth-helpers.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/tests/utils/auth-helpers.ts
  Directory: tests/utils
*/

--- File: tests/utils/auth-helpers.ts ---

import { Page, expect } from '@playwright/test';
import { clerk, clerkSetup } from '@clerk/testing/playwright';

/**
 * Login credentials for test user
 */
export const TEST_USER = {
  email: process.env.TEST_USER_EMAIL!,
  password: process.env.TEST_USER_PASSWORD!,
  fullName: process.env.TEST_USER_FULL_NAME!,
  username: process.env.TEST_USER_USERNAME!,
  userId: process.env.TEST_USER_ID!
};

/**
 * Login a test user using Clerk authentication
 * @param page - Playwright page object
 */
export async function loginTestUser(page: Page): Promise<void> {
  // Navigate to an unprotected page that loads Clerk
  await page.goto('/');

  // Setup Clerk for testing
  await clerkSetup();

  // Use Clerk's testing utilities to sign in
  await clerk.signIn({
    page,
    signInParams: {
      strategy: 'password',
      identifier: TEST_USER.email,
      password: TEST_USER.password
    }
  });

  // Navigate to the home page and verify we're logged in
  await page.goto('/');
  await expect(page.getByRole('button', { name: 'Open user button' })).toBeVisible({timeout: 30000});
}

/**
 * Helper function to fill in login credentials and wait for successful login
 */
export async function fillLoginCredentials(page: Page): Promise<void> {
  await page.getByRole('textbox', { name: 'Email address' }).fill(TEST_USER.email);
  await page.waitForTimeout(500);
  await page.getByRole('button', { name: 'Continue' }).click();
  await page.waitForTimeout(500);
  await page.getByRole('textbox', { name: 'Password' }).fill(TEST_USER.password);
  await page.waitForTimeout(1000);
  await page.getByRole('button', { name: 'Continue' }).click();
  await expect(page.getByRole('button', { name: 'Open user button' })).toBeVisible({timeout: 30000});
}

/**
 * Logout the current user
 * @param page - Playwright page object
 */
export async function logoutUser(page: Page): Promise<void> {
  // Navigate to an unprotected page that loads Clerk
  await page.goto('/');
  
  await clerk.signOut({ page });
  await page.waitForTimeout(500);
} 

/*
  File: tests/utils/db-reset.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/tests/utils/db-reset.ts
  Directory: tests/utils
*/

--- File: tests/utils/db-reset.ts ---

import { ConvexHttpClient } from "convex/browser"
import { api } from "@/convex/_generated/api"
import dotenv from 'dotenv'

dotenv.config()
const NODE_ENV = process.env.NODE_ENV || 'test'

// Ensure we're in test environment
if (NODE_ENV !== 'test' && NODE_ENV !== 'development') {
  throw new Error('Database reset utilities should only be used in test or development environment')
}

// Initialize Convex client
const convex = new ConvexHttpClient(process.env.NEXT_PUBLIC_CONVEX_URL!)

const TABLES_TO_RESET = ['mailing_list_subscriptions', 'visits'] as const
// Restrict to allowed table names for type safety
type TableName = typeof TABLES_TO_RESET[number]

/**
 * Delete all documents in a table
 */
export async function deleteCollection(tableName: TableName): Promise<void> {
  try {
    await convex.mutation(api.testing.deleteAll, { tableName })
    console.log(`Deleted all documents from ${tableName}`)
  } catch (error) {
    console.warn(`Warning: Failed to delete table ${tableName}:`, error)
  }
}

/**
 * Reset database for testing
 */
export async function resetDatabase(): Promise<void> {
  console.log('Resetting database...')
  for (const table of TABLES_TO_RESET) {
    await deleteCollection(table)
  }
  console.log('Database reset complete')
}

/**
 * Seed test data using Convex test mutation
 */
export async function seedTestData(): Promise<void> {
  console.log('Seeding test data...')
  await convex.mutation(api.testing.seedTestData, {})
  console.log('Test data seeding complete')
}

/**
 * Verify that all tables are empty
 */
export async function verifyDatabaseReset(): Promise<boolean> {
  try {
    for (const table of TABLES_TO_RESET) {
      const count = await convex.query(api.testing.countDocuments, { tableName: table })
      if (count > 0) {
        console.error(`Table ${table} is not empty`)
        return false
      }
    }
    return true
  } catch (error) {
    console.error('Error verifying database reset:', error)
    return false
  }
}

/**
 * Reset database for testing
 */
export async function setupTestDatabase(): Promise<void> {
  await resetDatabase()
  const isReset = await verifyDatabaseReset()
  if (!isReset) {
    throw new Error('Failed to reset database')
  }
} 

/*
  File: tests/utils/test-helpers.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/tests/utils/test-helpers.ts
  Directory: tests/utils
*/

--- File: tests/utils/test-helpers.ts ---

import { test, expect, Page } from '@playwright/test';
import { resetDatabase, seedTestData } from './db-reset';
import { loginTestUser, logoutUser } from './auth-helpers';

/**
 * Reset the database before a test or group of tests
 */
export async function setupCleanDatabase() {
  await resetDatabase();
}

/**
 * Reset the database and seed it with test data
 */
export async function setupSeededDatabase() {
  await resetDatabase();
  await seedTestData();
}

/**
 * Login a test user
 * @param page - Playwright page object
 */
export async function setupAuthenticatedUser(page: Page) {
  await loginTestUser(page);
}

/**
 * Logout a user
 * @param page - Playwright page object
 */
export async function teardownAuthenticatedUser(page: Page) {
  await logoutUser(page).catch(e => console.warn('Failed to logout:', e));
}

// Export test and expect for convenience
export { test, expect }; 

/*
  File: tsconfig.json
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/tsconfig.json
  Directory: .
*/

--- File: tsconfig.json ---

{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


/*
  File: types/adventure-plan.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/types/adventure-plan.ts
  Directory: types
*/

--- File: types/adventure-plan.ts ---

import type { Character } from "./character";

export interface AdventurePlan {
  id: string;
  settingId: string;
  title: string;
  author: string;
  version: string;
  teaser: string;
  overview: string;
  party: [number, number];
  tags: string[];
  image: string;
  start: string;
  sections: AdventureSection[];
  npcs: Record<string, Character>;
}

export interface AdventureSection {
  title: string;
  summary: string;
  scenes: AdventureScene[];
}

export interface AdventureScene {
  title: string;
  summary: string;
  encounters: AdventureEncounter[];
}

export interface AdventureEncounter {
  id: string;
  title: string;
  intro: string;
  instructions?: string;
  image?: string;
  notes?: string;
  transitions?: EncounterTransition[];
  npc?: EncounterCharacterRef[];
  skipInitialNpcTurns?: boolean;
}

export interface EncounterTransition {
  condition: string;
  encounter: string;
}

export interface EncounterCharacterRef {
  id: string;
  behavior: string;
  initialInitiative?: number;
} 

/*
  File: types/adventure.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/types/adventure.ts
  Directory: types
*/

--- File: types/adventure.ts ---

import type { PC, NPC } from "./character";
import type { RollRequirement } from "@/lib/validations/roll-requirement-schema";

export interface Adventure {
  id: string;
  title: string;
  adventurePlanId: string;
  settingId: string;
  party: PC[];
  turns: Turn[];
  startedAt: string;
  endedAt?: string;
  pausedAt?: string;
}

export type TurnCharacter =
  | (PC & { 
      type: "pc"; 
      initiative: number; 
      hasReplied?: boolean; 
      isComplete?: boolean;
      rollRequired?: RollRequirement;
      rollResult?: number;
    })
  | (NPC & { 
      type: "npc"; 
      initiative: number; 
      hasReplied?: boolean; 
      isComplete?: boolean;
      rollRequired?: RollRequirement;
      rollResult?: number;
    });

export interface Turn {
  id: string;
  encounterId: string;
  title: string;
  narrative: string;
  characters: TurnCharacter[];
  adventureId: string;
  isFinalEncounter?: boolean;
}

/*
  File: types/character.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/types/character.ts
  Directory: types
*/

--- File: types/character.ts ---

// Base type for all characters
export interface BaseCharacter {
  id: string;
  name: string;
  image: string;
  archetype: string;
  race: string;
  gender?: string;
  appearance: string;
  personality?: string;
  background?: string;
  motivation?: string;
  behavior?: string;
  healthPercent: number; // 0-100, percentage
  equipment?: EquipmentItem[];
  skills?: string[];
  status?: string;
}

// Equipment item type
export interface EquipmentItem {
  name: string;
  description?: string;
}

// Standard RPG attributes (1-20)
export interface Attributes {
  strength: number;
  dexterity: number;
  constitution: number;
  intelligence: number;
  wisdom: number;
  charisma: number;
}

// Player Character (PC) type
export interface PC extends BaseCharacter {
  type: "pc";
  userId: string; // Clerk user id
  attributes: Attributes;
}

// Non-Player Character (NPC) type
export interface NPC extends BaseCharacter {
  type: "npc";
  attributes?: Partial<Attributes>; // Some NPCs may have attributes
}

// Pre-rolled Player Character template (no userId)
export interface PCTemplate extends BaseCharacter {
  type: "pc";
  attributes: Attributes;
}

// Union type for all characters
export type Character = PC | NPC; 

/*
  File: types/mailing-list.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/types/mailing-list.ts
  Directory: types
*/

--- File: types/mailing-list.ts ---

export interface MailingListPreferences {
  marketing: boolean
  updates: boolean
}

export interface MailingListSubscription {
  id: string
  user_id: string
  email: string
  name: string | null
  subscribed_at: string
  unsubscribed_at: string | null
  preferences: MailingListPreferences
  created_at: string
  updated_at: string
}

export type CreateMailingListSubscription = Pick<MailingListSubscription, 'user_id' | 'email' | 'name'> & {
  preferences?: Partial<MailingListPreferences>
}

export type UpdateMailingListSubscription = Partial<Pick<MailingListSubscription, 'name' | 'unsubscribed_at'>> & {
  preferences?: Partial<MailingListPreferences>
} 

