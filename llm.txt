/*
  File: .gitignore
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/.gitignore
  Directory: .
*/

--- File: .gitignore ---

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# clerk configuration (can include secrets)
/.clerk/

# Playwright
node_modules/
/test-results/
/playwright-report/
/blob-report/
/playwright/.cache/

# Database backups
/backups/

# LLM contexts for third party tools
llm-convex.txt

# Convex
.convex/
convex/_generated/
.env.local

# clerk configuration (can include secrets)
/.clerk/

/*
  File: .prettierrc
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/.prettierrc
  Directory: .
*/

--- File: .prettierrc ---

{
  "endOfLine": "lf",
  "printWidth": 200,
  "semi": false,
  "singleQuote": false,
  "tabWidth": 2,
  "trailingComma": "es5"
}


/*
  File: README.md
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/README.md
  Directory: .
*/

--- File: README.md ---

# d20adventures.com

A new narrative-driven RPG platform that blends play-by-post gameplay and real-time updates facilitated by an AI Game Master.

--

### Work in Progress

Doing test play throughs and tweaking the prompts:

- 1: `/realm-of-myr/the-midnight-summons/jh74yx5mqjw0f9tbfh6q24nr5d7h4npr/1` (gemini-2.0-flash-lite)
- 2: `/realm-of-myr/the-midnight-summons/jh7da623rz0wd328p8pnkcpgz57h4j6q/1` (gemini-2.0-flash-lite)
- 3: `/realm-of-myr/the-midnight-summons/jh7b2xsg8w0jcsyvzxqjzpkpf57h5cch/1` (gemini-2.5-flash-preview-05-20)


### Future Adventure Ideas

Olav’s Outpost - A tavern at the edge of civilization across from a mysterious forest island
Shadow of the Caldera


#### Test Responses

Response 1 (test rewrite)
Try to figure out what it is and draw my bow

Response 2 (better response, should not be overwritten, prompt animal handling roll)
“Easy there big guy,” says Thalbern, trying to keep his voice steady. “I have no quarrel with you. Why don’t you just move alone”

Using the skills he had learned from the elves as a youth, the ranger used his body and voice to calm the wild beast and direct him to move onward.

Response 3 (if forced to attack)

“Violence it is then!” the ranger exclaims as he draws his sword and attacks the wild beast.

Reponse 4 (unclear action, attack or intimidation)

“Begone wild beast!” the ranger shouted through gritted teeth, hoping to drive the thing away into the woods as he brandished his blade in defense.

Responses (brief should be rewritten)

attack more aggressively now

try a different tactic in attacking

##### Alt Path, avoiding Owlbear

Response 2
Thalbern bows slightly in deference to the druid, then straightens. "Wollandora. It is great to see you again old friend," he replies. "Now please tell me what urgent matter caused you to summon me out here at this late hour. I had a near miss encounter on the way here with an owlbear, you should know."

Response 3
Try to hide and let it pass

Response 4
“This is troubling indeed,” says Thalbern, his brow furrowing as he considers the implications. “Is there anything else you can tell me about who might be behind this?”


---

### Overview

The prototype for D20 Adventures is a proof of concept for a turn based narrative driven RPG platform where players work their way through an adventure module run by an AI game master.

Each turn begins with an introduction and a character response order randomly determined by a D20 initiative roll. When it is the player’s turn, they can reply to update the narrative of the adventure with their character’s actions and dialogue. 

If it is determined that a dice role is needed, the player can roll their D20 and the result will determine the direction of the story.

The AI is trained to choose an appopriate dice roll check and the target for success, then will update the narrative based on the roll result and the instructions for the encounter in the adventure module.

At the end of each turn, the AI decides whether to move to a new encounter or continue with the current scenario.

Each encounter has its own image, intro, title, NPCs and instructions for the AI Game Master.

If the player enters well written prose, it will be preserved as as, otherwise it will be enhanced to fit the story’s narrative, cleaning up spelling and grammar while preserving the intent of the original response.

Similarly each NPC will have an opportunity to respond and make dice rolls, all coordinated against an overall adventure plan linking one encounter to another.

This initial D20 Adventures prototype is a simple one shot single player character adventure inspired by Deborah Ann Woll’s appearance on the Real Ones with Jon Bernthal podcast where she spontaneously invented an adventure scenario to demonstrate the fun of D and D gameplay.

The simple confrontation she concocted between a ranger and an owlbear in the forest at night could also be a good test of whether a game can be led by an AI game master and actually be fun.

When you are working with AI, it is best to avoid lots of complicated game mechanics, so I tried to keep it simple. Just roll a D20. If you roll high, good things happen. Roll low, not so much.

We keep track of the characters turn over turn, including adjusting status and health percentage.

With a name like D20 Adventures, of course we have to pay special attention to natural twenties and ones. Hopefully more twenties for the players but sometimes that's not how it goes.

Hopefully Jon Bernthal and Deborah Ann Woll don't object to my homage! 

In the future, I want to build true multiplayer, where you can form a group of friends and play through an adventure together. 

Eventually I would like to allow anyone create their own settings and adventure modules for a community of players to discover.

D20 Adventures is a fun project for me to see if I can create a cool new multiplayer narrative rpg experience with AI. 

Head over to D20 Adventures.com to join the discord, sign up for the wait list or find the source code on Github.

You can also follow me on X, Bluesky and Medium for project updates.



/*
  File: app/_actions/advance-turn.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/advance-turn.ts
  Directory: app/_actions
*/

--- File: app/_actions/advance-turn.ts ---

"use server"
import { convex } from "@/lib/convex/server";
import { api } from "@/convex/_generated/api";
import { readJsonFromS3 } from "@/lib/s3-utils";
import { generateObject } from "@/lib/ai";
import { z } from "zod";
import type { Id } from "@/convex/_generated/dataModel";
import type { AdventurePlan } from "@/types/adventure-plan";
import type { Turn, TurnCharacter } from "@/types/adventure";
import { processNpcTurnsAfterCurrent } from "@/lib/services/npc-turn-service";
import { mapConvexTurnToTurn, rollD20 } from "@/lib/utils";
import wait from "waait"
import { appendNarrative } from "@/lib/services/narrative-service";

const encounterProgressionSchema = z.object({
  nextEncounterId: z.string(),
  narrative: z.string(),
});

// Type guard for characters with rollRequired and rollResult
function hasRollFields(
  c: TurnCharacter
): c is TurnCharacter & { rollRequired: { rollType: string; difficulty: number; modifier?: number }; rollResult: number } {
  return (
    "rollResult" in c &&
    typeof c.rollResult === "number" &&
    "rollRequired" in c &&
    typeof c.rollRequired === "object" &&
    c.rollRequired !== null
  );
}

export async function advanceTurn({ turnId, settingId, adventurePlanId }: { turnId: Id<"turns">; settingId: string; adventurePlanId: string }) {
  let shouldProcessNpcTurns = true; // Initialize to true by default
  // 1. Fetch the turn from Convex
  const turnData = await convex.query(api.adventure.getTurnById, { turnId });
  if (!turnData) throw new Error("Turn not found");
  const turn = mapConvexTurnToTurn({ ...turnData, adventureId: turnData.adventureId.toString() });
  if (!turn) throw new Error("Turn not found");

  // 2. Load the plan from S3
  console.log("[advanceTurn] settingId:", settingId, "adventurePlanId:", adventurePlanId);
  const plan = (await readJsonFromS3(`settings/${settingId}/${adventurePlanId}.json`)) as AdventurePlan;
  if (!plan || !plan.id || !plan.sections || !plan.title) {
    throw new Error("Adventure plan is missing required fields");
  }

  // 3. Find current encounter
  const findCurrentEncounter = (plan: AdventurePlan, currentEncounterId: string) =>
  plan.sections
    .flatMap(section => section.scenes)
    .flatMap(scene => scene.encounters)
    .find(encounter => encounter.id === currentEncounterId) ?? null;

  const currentEncounter = findCurrentEncounter(plan, turn.encounterId);
  if (!currentEncounter) throw new Error("Current encounter not found in plan");

  const encounterIntro = currentEncounter.intro ?? "";
  const encounterInstructions = currentEncounter.instructions ?? "";
  const narrativeContext = (turn.narrative ?? "");

  // Extract the player's most recent action from the narrative
  const mostRecentNarrativeBlock = (turn.narrative ?? "").split(/\n\n/).filter(Boolean).at(-1) ?? "";

  // Try to parse the last DiceRoll from the narrative to construct rollInfo
  const diceRollRegex = /\[DiceRoll:([^\]]+)\]/g;
  const narrativeForRollParsing = turn.narrative ?? "";
  let matches;
  let lastDiceRollParamsStr: string | null = null;
  while ((matches = diceRollRegex.exec(narrativeForRollParsing)) !== null) {
    lastDiceRollParamsStr = matches[1];
  }

  let rollInfo = "No character-specific dice roll was identified as the immediate precursor to this state."; // Default

  if (lastDiceRollParamsStr) {
    const params = lastDiceRollParamsStr.split(';').reduce((acc, part) => {
      const [key, ...valueParts] = part.split('=');
      const value = valueParts.join('=');
      if (key && value !== undefined) acc[key.trim()] = value.trim();
      return acc;
    }, {} as Record<string, string>);

    const characterName = params.character;
    const rollType = params.rollType;
    const resultStr = params.result;
    const difficultyStr = params.difficulty;
    const successStr = params.success;
    const modifierStr = params.modifier;

    if (characterName && rollType && resultStr && difficultyStr && successStr) {
      const rollResult = parseInt(resultStr, 10);
      const difficulty = parseInt(difficultyStr, 10);
      const success = successStr === 'true';
      let modifier: number | undefined = undefined;
      let modifierText = "";

      if (modifierStr) {
          const parsedModifier = parseInt(modifierStr, 10);
          if (!isNaN(parsedModifier)) {
              modifier = parsedModifier;
              modifierText = `, modifier: ${modifier}`;
          }
      }

      if (!isNaN(rollResult) && !isNaN(difficulty)) {
        rollInfo = `Regarding the most recent dice roll: Character '${characterName}' attempted a '${rollType}'. The result was ${rollResult} (difficulty: ${difficulty}${modifierText}). This roll was a ${success ? 'SUCCESS' : 'FAILURE'}.`;
        console.log("[advanceTurn] Constructed rollInfo from parsed narrative:", rollInfo);
      } else {
        console.log("[advanceTurn] Failed to parse numeric rollResult/difficulty from DiceRoll tag. Parsed params:", JSON.stringify(params));
      }
    } else {
      console.log("[advanceTurn] Could not parse all required fields (character, rollType, result, difficulty, success) from DiceRoll tag. Parsed params:", JSON.stringify(params));
    }
  } else {
    console.log("[advanceTurn] No DiceRoll tag found in narrative. Attempting fallback to character object data for rollInfo.");
    const lastRollingCharacter = (turn.characters as TurnCharacter[]).find(hasRollFields);
    if (lastRollingCharacter) {
      const { name, rollRequired, rollResult: charRollResult } = lastRollingCharacter;
      const { rollType: charRollType, difficulty: charDifficulty, modifier: charModifier = 0 } = rollRequired;
      const charSuccess = charRollResult >= charDifficulty;
      rollInfo = `Regarding the most recent dice roll (from character data): Character '${name}' attempted a '${charRollType}'. The result was ${charRollResult} (difficulty: ${charDifficulty}, modifier: ${charModifier}). This roll was a ${charSuccess ? 'SUCCESS' : 'FAILURE'}.`;
      console.log("[advanceTurn] Constructed rollInfo from character data (fallback):", rollInfo);
    } else {
      console.log("[advanceTurn] No specific roll found in character data either (fallback). Using default message for rollInfo.");
    }
  }

  // Identify player characters
  const playerCharacters = (turn.characters as TurnCharacter[]).filter(c => c.type === 'pc');
  const playerCharacterNames = playerCharacters.map(c => c.name).join(", ");

  // 4. Ask LLM if encounter is resolved
  const transitionsText = currentEncounter.transitions
    ? (currentEncounter.transitions as { condition: string; encounter: string }[]).map(
        (t, i) =>
          `Transition Option ${i + 1} (leads to encounter ID: '${t.encounter}'):\n  Condition to check: ${t.condition}`
      ).join("\n")
    : "No explicit transitions defined for this encounter.";

  // Find current section and scene for context
  let currentSection = undefined;
  let currentScene = undefined;
  for (const section of plan.sections) {
    for (const scene of section.scenes) {
      if (scene.encounters.some(enc => enc.id === turn.encounterId)) {
        currentSection = section;
        currentScene = scene;
        break;
      }
    }
    if (currentSection && currentScene) break;
  }

  const sectionContext = currentSection ? `Section Title: ${currentSection.title || ""}\nSection Summary: ${currentSection.summary || ""}` : "";
  const sceneContext = currentScene ? `Scene Title: ${currentScene.title || ""}\nScene Summary: ${currentScene.summary || ""}` : "";
  const adventureOverview = plan.overview ? `Adventure Overview: ${plan.overview}` : "";

  // --- DETAILED LOGGING FOR LLM PROMPT INPUTS ---
  console.log("\n[advanceTurn] --- LLM PROMPT INPUTS ---");
  console.log("[advanceTurn] Adventure Overview:", plan.overview);
  if (currentSection) {
    console.log("[advanceTurn] Section Title:", currentSection.title);
    console.log("[advanceTurn] Section Summary:", currentSection.summary);
  }
  if (currentScene) {
    console.log("[advanceTurn] Scene Title:", currentScene.title);
    console.log("[advanceTurn] Scene Summary:", currentScene.summary);
  }
  console.log("[advanceTurn] Current Encounter Title:", currentEncounter.title);
  console.log("[advanceTurn] Current Encounter ID:", currentEncounter.id);
  console.log("[advanceTurn] Current Encounter Intro:", encounterIntro);
  console.log("[advanceTurn] Current Encounter Instructions:", encounterInstructions);
  console.log("[advanceTurn] Recent Narrative (context):\n", narrativeContext);
  console.log("[advanceTurn] Most Recent Narrative Block (action/event):\n", mostRecentNarrativeBlock);
  console.log("[advanceTurn] Roll Information For Context:", rollInfo);
  console.log("[advanceTurn] Available Transitions Text:\n", transitionsText);
  console.log("[advanceTurn] Player Character Names:", playerCharacterNames);
  console.log("--- END LLM PROMPT INPUTS ---\n");
  // --- END DETAILED LOGGING ---

  const prompt = `
${adventureOverview}

${sectionContext}

${sceneContext}

Current Encounter Title: ${currentEncounter.title}
Current Encounter ID: ${currentEncounter.id}
Current Encounter Intro:
${encounterIntro}
Current Encounter Instructions:
${encounterInstructions}

Recent Narrative Context (last few paragraphs):
${narrativeContext}

Most Recent Action/Event from the narrative (this is what the player/environment JUST DID):
${mostRecentNarrativeBlock}

${rollInfo ? `Key Information Regarding Recent Dice Roll (related to the 'Most Recent Action/Event'):
${rollInfo}
` : 'No specific dice roll outcome to report for the most recent action.'}
Available Transition Options for '${currentEncounter.id}':
${transitionsText}

Your Task:
1. Carefully review the 'Recent Narrative Context', the 'Most Recent Action/Event', and any 'Key Information Regarding Recent Dice Roll'. These describe events that HAVE ALREADY HAPPENED.
2. Evaluate 'Most Recent Action/Event' against 'Available Transition Options' (if any):
    - If a transition condition IS clearly met by PAST actions/rolls: Set 'nextEncounterId' to the 'encounter' ID specified in that transition option. The 'Available Transition Options' list is the definitive guide for all transitions. If the 'Most Recent Action/Event' directly and clearly fulfills a 'condition' in this list, that transition MUST occur. This takes strict precedence over any general interaction possibilities mentioned in the 'Current Encounter Instructions'.
3. Determine the 'nextEncounterId':
    - If a transition condition IS MET: Use the 'leads to encounter ID' from that transition.
    - If MULTIPLE transition conditions appear to be met by PAST actions/rolls: Prioritize conditions related to explicit success or failure of a recent dice roll if applicable. If still ambiguous, use the first one that clearly applies.
    - If NO transition condition is met the 'nextEncounterId' should remain the Current Encounter ID ('${currentEncounter.id}').
4. Generate a 'narrative' response:
    - If transitioning (because a condition was met by PAST actions/rolls): The narrative should briefly describe the events or state that fulfill the transition condition and logically lead into the new encounter. This acts as a bridge.
    - If NOT transitioning (i.e., 'nextEncounterId' is '${currentEncounter.id}'): The narrative MUST describe what happens next in the current encounter based on the 'Most Recent Action/Event' and 'Key Information Regarding Recent Dice Roll'. It should set the stage for the player's NEXT decision. For example, if a creature was detected, the narrative might describe the creature appearing or its immediate reaction, prompting the player to decide their next move. DO NOT write new actions or decisions for the player character(s).
    - Do NOT add any questions at the end like 'What does he do next?'
    - Do NOT mention any game mechanics such as dice rolls.

IMPORTANT GUIDELINES:
- Only use encounter IDs explicitly listed in the 'Available Transition Options' or the 'Current Encounter ID' ('${currentEncounter.id}').
- Your 'narrative' response will set the stage for the player's NEXT turn.
- **CRITICAL REMINDER: DO NOT write new actions, dialogue, choices, or internal thoughts for the player character(s) (e.g., ${playerCharacterNames}).** The narrative must describe NPC actions, environmental changes, or the direct, immediate consequences of the player's PAST action/roll. The goal is to prepare for the player's *next actual decision*, not to make it for them.
- If a transition occurs due to a failed dice roll (that already happened), ensure the narrative reflects the consequences of that failure leading to the new situation.
- If a transition occurs due to a successful dice roll (that already happened), ensure the narrative reflects the consequences of that success.
- If no transition occurs, the narrative should clearly end in a way that prompts the player for their next action. For instance, describe the scene and end with a question like "What does Thalbern do next?" or simply describe the immediate situation that demands a response.

Respond in JSON:
{
  "nextEncounterId": string, // ID of the next/current encounter based on your evaluation
  "narrative": string      // Narrative prose for the transition OR for continuing the current encounter. IMPORTANT: Do NOT include any questions at the end such as 'What does [character name] do next?' and do NOT mention any game mechanics such as dice rolls.
}
`;

  await wait(1000);
  const llmResult = (await generateObject({ prompt, schema: encounterProgressionSchema })).object;

  // Log the LLM's raw response
  console.log("[advanceTurn] LLM result:", JSON.stringify(llmResult, null, 2));

  // Log what the LLM decided about encounter progression
  console.log("[advanceTurn] Next encounterId:", llmResult.nextEncounterId);

  // 6. Build the new turn object
  let newTurn: Turn | null = null;
  if (llmResult.nextEncounterId === turn.encounterId) {
    // Continue current encounter
    let newCharacters: TurnCharacter[] = (turn.characters as TurnCharacter[]).filter((c) => c.status !== "dead" && c.status !== "fled");
    const narrative = llmResult.narrative || ""; // Use LLM narrative
    // Reset hasReplied, isComplete, and re-roll initiative for all characters
    newCharacters = newCharacters.map((c) => ({
      ...c,
      hasReplied: false,
      isComplete: false,
      initiative: rollD20(), // Re-roll initiative
    }));

    // Sort by new initiative
    newCharacters.sort((a, b) => (b.initiative ?? 0) - (a.initiative ?? 0));

    newTurn = {
      id: "", // placeholder, Convex will generate
      adventureId: turnData.adventureId,
      encounterId: turn.encounterId,
      title: currentEncounter.title,
      narrative,
      characters: newCharacters,
    };
  } else {
    // Transition to new encounter
    const nextEncounter = findCurrentEncounter(plan, llmResult.nextEncounterId);

    if (nextEncounter && nextEncounter.skipInitialNpcTurns) {
      console.log(`[advanceTurn] Skipping initial NPC turns for new encounter: ${nextEncounter.id}`);
      shouldProcessNpcTurns = false;
    }

    if (!nextEncounter) {
      await convex.mutation(api.turns.patchAdventure, { adventureId: turnData.adventureId, patch: { endedAt: Date.now(), updatedAt: Date.now() } });
      return { status: "adventure_complete" };
    }
    // PCs: persist from previous turn (remove dead/fled) and re-roll initiative
    let pcs: TurnCharacter[] = (turn.characters as TurnCharacter[])
      .filter((c) => c.type === "pc" && c.status !== "dead" && c.status !== "fled")
      .map((pc) => ({
        ...pc,
        initiative: rollD20(), // Re-roll PC initiative
      }));

    // Reset health if the encounter has resetHealth flag
    if (nextEncounter.resetHealth) {
      console.log(`[advanceTurn] Resetting health for all characters due to resetHealth flag in encounter: ${nextEncounter.id}`);
      pcs = pcs.map((pc) => ({
        ...pc,
        healthPercent: 100,
        status: pc.status === "dead" ? "" : pc.status, // Clear dead status if health is being reset
      }));
    }

    // NPCs: add from next encounter
    const npcs: TurnCharacter[] = (nextEncounter.npc || []).map((npcRef: { id: string; initialInitiative?: number }) => {
      const npc = plan.npcs[npcRef.id];
      return {
        ...npc,
        id: npcRef.id,
        type: "npc",
        isComplete: false,
        hasReplied: false,
        initiative: typeof npcRef.initialInitiative === 'number' ? npcRef.initialInitiative : rollD20(),
        // NPCs always start at full health
        healthPercent: 100,
      };
    });
    let allCharacters: TurnCharacter[] = [...pcs, ...npcs];
    // Reset hasReplied and isComplete for all characters
    allCharacters = allCharacters.map((c) => ({
      ...c,
      hasReplied: false,
      isComplete: false,
    }));
    // Sort by new initiative
    allCharacters.sort((a, b) => (b.initiative ?? 0) - (a.initiative ?? 0));

    // Use appendNarrative utility for new encounter intro and new narrative
    const narrative = appendNarrative(llmResult.narrative || "", nextEncounter.intro || "");
    newTurn = {
      id: "", // placeholder, Convex will generate
      adventureId: turnData.adventureId,
      encounterId: nextEncounter.id,
      title: nextEncounter.title,
      narrative,
      characters: allCharacters, // Use the sorted and updated list
    };
  }

  // Determine if this new turn is for the final encounter
  const resolvedNextEncounterForFinalCheck = findCurrentEncounter(plan, newTurn.encounterId);
  const isFinalEncounter = resolvedNextEncounterForFinalCheck
    ? !resolvedNextEncounterForFinalCheck.transitions || resolvedNextEncounterForFinalCheck.transitions.length === 0
    : false;

  // 7. Create the new turn in Convex
  const newTurnId = await convex.mutation(api.turns.createTurn, {
    adventureId: turnData.adventureId,
    encounterId: newTurn.encounterId,
    title: newTurn.title,
    narrative: newTurn.narrative,
    characters: newTurn.characters,
    order: (turnData.order || 0) + 1,
    isFinalEncounter: isFinalEncounter,
  });

  // 8. Patch adventure with new currentTurnId
  await convex.mutation(api.turns.patchAdventure, {
    adventureId: turnData.adventureId,
    patch: { currentTurnId: newTurnId },
  });

  // 9. After creating the new turn, process NPC turn if needed
  if (shouldProcessNpcTurns) {
    await processNpcTurnsAfterCurrent(newTurnId);
  } else {
    console.log(`[advanceTurn] NPC turns processing was skipped for turnId: ${newTurnId}`);
  }

  // 10. Return the new turn/adventure state
  return { status: "turn_advanced", turn: newTurn };
} 

/*
  File: app/_actions/adventure-plan-actions.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/adventure-plan-actions.ts
  Directory: app/_actions
*/

--- File: app/_actions/adventure-plan-actions.ts ---

'use server'

import { auth } from "@clerk/nextjs/server"
import { updateJsonOnS3, copyS3Object, readJsonFromS3 } from "@/lib/s3-utils"
import type { AdventurePlan } from "@/types/adventure-plan"

interface UpdateAdventurePlanParams {
  adventurePlan: AdventurePlan
}

export async function updateAdventurePlanAction(
  params: UpdateAdventurePlanParams
): Promise<{ success: boolean; message?: string; error?: string }> {
  console.log("updateAdventurePlanAction: Received params:", JSON.stringify(params, null, 2)); // Log received params

  const { userId } = await auth()
  if (!userId) {
    console.error("updateAdventurePlanAction: Unauthorized access attempt.");
    return { success: false, error: "Unauthorized" }
  }

  const { adventurePlan } = params
  console.log("updateAdventurePlanAction: Extracted adventurePlan object:", JSON.stringify(adventurePlan, null, 2)); // Log extracted adventurePlan

  if (!adventurePlan || !adventurePlan.id || !adventurePlan.settingId) {
    console.error("updateAdventurePlanAction: Invalid adventure plan data provided:", adventurePlan);
    return { success: false, error: "Invalid adventure plan data provided." }
  }

  const originalKey = `settings/${adventurePlan.settingId}/${adventurePlan.id}.json`
  const timestamp = Date.now()
  const backupKey = `settings/${adventurePlan.settingId}/backups/${adventurePlan.id}-${timestamp}.json`

  try {
    try {
      await readJsonFromS3(originalKey)
      await copyS3Object(originalKey, backupKey)
      console.log(`updateAdventurePlanAction: Backup created for ${originalKey} at ${backupKey}`)
    } catch (readError: unknown) {
      let errorMessage = "An unknown error occurred during pre-backup check."
      if (readError instanceof Error) {
        errorMessage = readError.message;
      }
      if (errorMessage.includes("No file body returned from S3") || errorMessage.includes("NoSuchKey")) {
        console.log(`updateAdventurePlanAction: Original file ${originalKey} not found, skipping backup.`)
      } else {
        console.warn(`updateAdventurePlanAction: Could not back up ${originalKey} due to an unexpected error during pre-backup check: ${errorMessage}`, readError)
      }
    }
    
    // Log adventurePlan and its sections before calling updateJsonOnS3
    console.log("updateAdventurePlanAction: adventurePlan.sections before S3 update:", JSON.stringify(adventurePlan.sections, null, 2));
    console.log("updateAdventurePlanAction: Full adventurePlan object before S3 update:", JSON.stringify(adventurePlan, null, 2));

    await updateJsonOnS3(originalKey, adventurePlan)
    return { success: true, message: "Adventure plan updated successfully." }
  } catch (error) {
    console.error(`updateAdventurePlanAction: Error during S3 operations for ${originalKey}:`, error)
    console.error("updateAdventurePlanAction: Failed adventurePlan object structure:", JSON.stringify(adventurePlan, null, 2)); // Log the object that failed
    const errorMessage = error instanceof Error ? error.message : "An unknown error occurred"
    return { success: false, error: `Failed to update adventure plan: ${errorMessage}` }
  }
} 

/*
  File: app/_actions/adventure.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/adventure.ts
  Directory: app/_actions
*/

--- File: app/_actions/adventure.ts ---

'use server'
import { api } from "@/convex/_generated/api"
import { convex } from "@/lib/convex/server"
import { auth } from "@clerk/nextjs/server"
import type { Id } from "@/convex/_generated/dataModel"
import type { TurnCharacter } from "@/types/adventure"
import { getRollRequirementHelper, getRollModifier, appendNarrative } from "@/lib/services/narrative-service"
import { generateText } from "@/lib/ai"
import { readJsonFromS3 } from "@/lib/s3-utils"
import type { AdventurePlan } from "@/types/adventure-plan"
import { getRollRequirementForAction } from "@/lib/services/roll-requirement-service"
import { processNpcTurnsAfterCurrent } from "@/lib/services/npc-turn-service"
import { analyzeAndApplyDiceRoll } from "@/lib/services/turn-update-service"
import wait from "waait"

// Placeholder type for ActionAssessment until it's defined in roll-requirement-service.ts
interface ActionAssessment {
  isPlausible?: boolean;
  feedback?: string | null;
  rollRequirement?: {
    rollType: string;
    difficulty: number;
    modifier?: number;
  } | null;
  rollType?: string;
  difficulty?: number;
  modifier?: number;
}

export async function processTurnReply({ turnId, characterId, narrativeAction }: { turnId: Id<"turns">; characterId: string; narrativeAction: string }) {
  console.log('[processTurnReply] CALLED')
  const { userId } = await auth()
  if (!userId) {
    console.error('[processTurnReply] Unauthorized access attempt.');
    throw new Error("Unauthorized")
  }
  
  const turn = await convex.query(api.adventure.getTurnById, { turnId })
  if (!turn) {
    console.error('[processTurnReply] Turn not found for turnId:', turnId);
    throw new Error("Turn not found")
  }
  
  const adventure = await convex.query(api.adventure.getAdventureById, { adventureId: turn.adventureId })
  if (!adventure) {
    console.error('[processTurnReply] Adventure not found for adventureId:', turn.adventureId);
    throw new Error("Adventure not found")
  }
  
  const planPath = `settings/${adventure.settingId}/${adventure.planId}.json`;
  const plan = (await readJsonFromS3(planPath)) as AdventurePlan
  if (!plan) {
    console.error('[processTurnReply] Adventure plan not found at path:', planPath);
    throw new Error("Adventure plan not found")
  }
  
  const encounter = plan.sections
    .flatMap((section) => section.scenes)
    .flatMap((scene) => scene.encounters)
    .find((e) => e.id === turn.encounterId)
  if (!encounter) {
    console.error('[processTurnReply] Encounter not found for encounterId:', turn.encounterId);
    throw new Error("Encounter not found")
  }
  console.log('[processTurnReply] Fetched encounter:', JSON.stringify(encounter, null, 2));
  
  const characterPerformingAction = turn.characters.find(c => c.id === characterId);
  if (!characterPerformingAction) {
    console.error('[processTurnReply] Character performing action not found for characterId:', characterId);
    throw new Error("Character performing action not found in turn data");
  }
  console.log('[processTurnReply] Character performing action:', JSON.stringify(characterPerformingAction, null, 2));

  // Prepare context for the updated getRollRequirementForAction
  const actionContext = {
    character: {
      name: characterPerformingAction.name,
      archetype: characterPerformingAction.archetype,
      race: characterPerformingAction.race,
      attributes: characterPerformingAction.attributes,
      skills: characterPerformingAction.skills,
      equipment: characterPerformingAction.equipment,
    },
    encounter: {
      id: encounter.id,
      instructions: encounter.instructions || "",
    },
    plan: {
      planId: adventure.planId,
      settingId: adventure.settingId,
    }
  };
  console.log('[processTurnReply] Action context for getRollRequirementForAction:', JSON.stringify(actionContext, null, 2));

  // Call the (soon to be updated) getRollRequirementForAction
  // This function will now also return plausibility and feedback
  const assessment: ActionAssessment = await getRollRequirementForAction(narrativeAction, characterPerformingAction as import("@/types/character").Character)
  console.log("[processTurnReply] action assessment from getRollRequirementForAction:", JSON.stringify(assessment, null, 2));

  if (assessment && assessment.isPlausible === false) {
    // Action is not plausible, return feedback to the user to try again
    console.log('[processTurnReply] Action deemed implausible. Feedback:', assessment.feedback);
    return {
      actionImplausible: true,
      feedback: assessment.feedback || "This action is not possible or doesn't make sense in the current situation. Please try something else.",
    }
  }
  console.log('[processTurnReply] Action deemed plausible or plausibility check not present.');

  // If plausible, proceed with existing logic
  let rollRequirementDetails = null;
  if (assessment?.rollRequirement) {
    rollRequirementDetails = assessment.rollRequirement;
  } else if (assessment?.rollType && typeof assessment.difficulty === 'number') {
    rollRequirementDetails = {
      rollType: assessment.rollType,
      difficulty: assessment.difficulty,
      modifier: assessment.modifier,
    };
  }

  console.log('[processTurnReply] Derived rollRequirementDetails:', JSON.stringify(rollRequirementDetails, null, 2));

  if (rollRequirementDetails && rollRequirementDetails.rollType && typeof rollRequirementDetails.difficulty === 'number') {
    console.log('[processTurnReply] Roll IS required. Calling getRollModifier...');
    
    // Calculate modifier using the enhanced getRollModifier function
    const modifierContext = {
      scenario: { 
        encounterIntro: encounter.instructions || "",
        encounterInstructions: encounter.instructions || "",
        narrativeContext: turn.narrative || "",
      },
      rollRequirement: rollRequirementDetails,
      character: characterPerformingAction,
    };
    console.log('[processTurnReply] Modifier context being passed to getRollModifier:', JSON.stringify(modifierContext, null, 2));
    
    const calculatedModifier = await getRollModifier(modifierContext);
    console.log('[processTurnReply] Calculated modifier from getRollModifier:', calculatedModifier);
    
    // Override the modifier with the calculated one
    rollRequirementDetails.modifier = calculatedModifier;
    
    console.log('[processTurnReply] Final rollRequirementDetails with calculated modifier:', JSON.stringify(rollRequirementDetails, null, 2));
    
    // Set rollRequirement for the character, do not mark as complete
    const submitReplyArgs = {
      turnId,
      characterId,
      narrativeAction,
      rollRequirement: rollRequirementDetails, // Pass the details with calculated modifier
    };
    console.log('[processTurnReply] Convex mutation api.adventure.submitReply ARGS (roll required):', JSON.stringify(submitReplyArgs, null, 2));
    await convex.mutation(api.adventure.submitReply, submitReplyArgs)
    console.log('[processTurnReply] Convex mutation api.adventure.submitReply successful (roll required).');
    return { rollRequired: rollRequirementDetails }
  } else {
    console.log('[processTurnReply] Roll IS NOT required or rollRequirementDetails is malformed. Marking character complete.');
    // Mark character as complete and hasReplied
    const submitReplyArgs = {
      turnId,
      characterId,
      narrativeAction,
      rollRequirement: undefined,
    };
    console.log('[processTurnReply] Convex mutation api.adventure.submitReply ARGS (no roll):', JSON.stringify(submitReplyArgs, null, 2));
    await convex.mutation(api.adventure.submitReply, submitReplyArgs)
    console.log('[processTurnReply] Convex mutation api.adventure.submitReply successful (no roll).');
    // After marking player complete, process NPCs
    console.log('[processTurnReply] Processing NPC turns after player reply.');
    await processNpcTurnsAfterCurrent(turnId);
    console.log('[processTurnReply] NPC turn processing complete.');
    return { rollRequired: null }
  }
}

export async function createAdventureWithFirstTurn(payload: {
  planId: string;
  settingId: string;
  ownerId: string;
  playerIds: string[];
  title: string;
  startedAt: number;
  playerInput: string;
  turn: {
    encounterId: string;
    narrative: string;
    characters: TurnCharacter[];
    order: number;
  };
}) {
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");

  // Read the adventure plan to get the encounter title
  const plan = (await readJsonFromS3(`settings/${payload.settingId}/${payload.planId}.json`)) as AdventurePlan;
  if (!plan || !plan.sections) {
    throw new Error("Adventure plan not found or is invalid");
  }
  const firstEncounter = plan.sections
    .flatMap(section => section.scenes)
    .flatMap(scene => scene.encounters)
    .find(encounter => encounter.id === payload.turn.encounterId);

  if (!firstEncounter || !firstEncounter.title) {
    throw new Error(`First encounter (ID: ${payload.turn.encounterId}) not found in plan or is missing a title.`);
  }

  const turnWithTitle = {
    ...payload.turn,
    title: firstEncounter.title,
  };

  // Prepare context for AI
  const paragraphs = (payload.turn.narrative || "").split(/\n\n+/).filter(Boolean);
  const lastAction = paragraphs[paragraphs.length - 1] || "";
  const encounterIntro = "";
  const encounterInstructions = "";
  const narrativeContext = paragraphs.slice(-2).join("\n\n");
  let rollRequirement = null;
  if (payload.playerInput && payload.playerInput.trim().length > 0) {
    rollRequirement = await getRollRequirementHelper(payload.playerInput, {
      encounterIntro,
      encounterInstructions,
      narrativeContext,
    });
    if (rollRequirement) {
      const actor = payload.turn.characters[0];
      const modifier = await getRollModifier({
        scenario: { encounterIntro, encounterInstructions, narrativeContext },
        rollRequirement,
        character: actor,
      });
      if (typeof modifier === "number") {
        rollRequirement.modifier = modifier;
      }
    }
  }
  if (!rollRequirement && lastAction && lastAction.trim().length > 0) {
    rollRequirement = await getRollRequirementHelper(lastAction, {
      encounterIntro,
      encounterInstructions,
      narrativeContext,
    });
    if (rollRequirement) {
      const actor = payload.turn.characters[0];
      const modifier = await getRollModifier({
        scenario: { encounterIntro, encounterInstructions, narrativeContext },
        rollRequirement,
        character: actor,
      });
      if (typeof modifier === "number") {
        rollRequirement.modifier = modifier;
      }
    }
  }

  // Overwrite ownerId with the authenticated user
  return convex.mutation(api.adventure.createAdventureWithFirstTurn, {
    ...payload,
    settingId: payload.settingId,
    ownerId: userId,
    turn: turnWithTitle, // Pass the turn object with the title
    rollRequirement,
  });
}

export async function resolvePlayerRollResult({
  turnId,
  characterId,
  result,
}: {
  turnId: Id<"turns">;
  characterId: string;
  result: number;
}) {
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");

  // 1. Fetch the turn
  const turn = await convex.query(api.adventure.getTurnById, { turnId });
  if (!turn) throw new Error("Turn not found");
  const character = turn.characters.find((c) => c.id === characterId);
  if (!character) throw new Error("Character not found");
  if (!character.rollRequired) throw new Error("No roll required for this character");
  if (typeof character.rollResult === "number") throw new Error("Roll already completed");

  // 2. Fetch the adventure and plan
  const adventure = await convex.query(api.adventure.getAdventureById, { adventureId: turn.adventureId });
  if (!adventure) throw new Error("Adventure not found");
  const planKey = `settings/${adventure.settingId}/${adventure.planId}.json`;
  const plan = (await readJsonFromS3(planKey)) as AdventurePlan;
  if (!plan || !Array.isArray(plan.sections)) throw new Error("Adventure plan not found or invalid");

  // 3. Extract encounter instructions
  let encounterInstructions = "";
  for (const section of plan.sections) {
    for (const scene of section.scenes) {
      const encounter = scene.encounters.find((e: { id: string }) => e.id === turn.encounterId);
      if (encounter) {
        encounterInstructions = encounter.instructions || "";
        break;
      }
    }
    if (encounterInstructions) break;
  }

  // 4. Build the prompt and call the LLM
  const { rollType, difficulty, modifier = 0 } = character.rollRequired;
  const baseRoll = result;
  const totalResult = baseRoll + modifier;
  const success = totalResult >= difficulty;
  const margin = totalResult - difficulty;
  const shortcode = `[DiceRoll:rollType=${rollType};baseRoll=${baseRoll};modifier=${modifier >= 0 ? "+" + modifier : modifier};result=${totalResult};difficulty=${difficulty};character=${character.name};image=${character.image};success=${success}]\n`;

  let newNarrative = appendNarrative(turn.narrative || "", shortcode);
  
  const narrativeContext = (turn.narrative || "").split(/\n\n+/).slice(-2).join("\n\n");
  const rollOutcomePrompt = `
Context:
${narrativeContext}

Encounter Instructions:
${encounterInstructions}

Player action: "${shortcode}"

A dice roll was made for ${character.name}: ${rollType} (Result: ${totalResult}, Difficulty: ${difficulty}, Margin: ${margin}).

The margin indicates how close the roll was to the target number. Use this information to inspire the drama, tension, or impact of the outcome, but write a creative, immersive narrative that fits the context. Do not use game terms like "margin" or "DC" in the narrative.

Write a single, concise, immersive third-person PRESENT-tense narrative paragraph (exactly two sentences, max 60 words) describing the direct outcome of the roll. Focus on what the character perceives or the immediate result of their action (e.g., a lock clicking open, a rope snapping, information gained). If the roll was for perception, describe what is now sensed or known. **Do not narrate combat actions, damage, or status effects inflicted by other entities as part of this roll\'s outcome; these will be handled by subsequent game mechanics.** Only describe self-inflicted effects if the character\'s own roll was a critical failure of an action they were taking. Only reference things present in the context. Do not invent new objects, people, or events not implied by the context or encounter instructions. Write in third person PRESENT tense. Do not use lists, bullet points, or markdown formatting. Do not use semicolons. Never mention game mechanics, dice, or rules.

Output only the narrative paragraph.`.trim();

  let rollOutcome = "";
  try {
    const { text } = await generateText({ prompt: rollOutcomePrompt });
    rollOutcome = text;
    // LOGGING: Before appending rollOutcome
    console.log("[appendNarrative] BEFORE rollOutcome", { prev: newNarrative, rollOutcome });
    newNarrative = appendNarrative(newNarrative, rollOutcome);
    // LOGGING: After appending rollOutcome
    console.log("[appendNarrative] AFTER rollOutcome", { newNarrative });
  } catch (err) {
    console.error("[resolvePlayerRollResult] Error generating roll outcome:", err);
  }

  // 5. Use analyzeAndApplyDiceRoll to update healthPercent/status if needed
  const diceRoll = {
    rollType,
    baseRoll,
    modifier,
    result: totalResult,
    difficulty,
    character: character.name,
    success,
  };
  await wait(500)
  const updatedTurn = await analyzeAndApplyDiceRoll({
    turn: { 
      ...turn,
      id: turn._id,
      characters: turn.characters.map(c => ({
        ...c,
        healthPercent: typeof c.healthPercent === "number" ? c.healthPercent : 100,
      }) as TurnCharacter),
    },
    diceRoll,
    narrative: newNarrative,
  });

  // Ensure the rolling character is marked complete and roll fields are set
  const updatedCharacters = updatedTurn.characters.map(c =>
    c.id === characterId
      ? {
          ...c,
          rollRequired: undefined,
          rollResult: totalResult,
          isComplete: true,
          hasReplied: true,
        }
      : c
  );

  // 6. Patch the turn with the new narrative and character state
  await convex.mutation(api.turns.updateTurn, {
    turnId,
    patch: {
      narrative: newNarrative,
      characters: updatedCharacters,
      updatedAt: Date.now(),
    },
  });

  // After marking player complete, process NPCs
  await processNpcTurnsAfterCurrent(turnId);

  // 7. Return the updated turn
  return await convex.query(api.adventure.getTurnById, { turnId });
} 

/*
  File: app/_actions/ban-user.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/ban-user.ts
  Directory: app/_actions
*/

--- File: app/_actions/ban-user.ts ---

'use server'

import { auth, clerkClient } from "@clerk/nextjs/server"
import { revalidatePath } from "next/cache"
import { isAdmin } from "@/lib/auth-utils"

export async function banUser(userId: string, reason?: string) {
  try {
    // Get the current user's ID
    const { userId: adminId } = await auth()
    
    if (!adminId) {
      throw new Error("Not authenticated")
    }

    // Verify the user is an admin
    const isUserAdmin = await isAdmin()
    if (!isUserAdmin) {
      throw new Error("Not authorized")
    }

    // Initialize Clerk client
    const client = await clerkClient()

    // Get current user to check if they're banned
    const user = await client.users.getUser(userId)
    const isBanned = user.banned

    if (isBanned) {
      // Unban the user
      await client.users.unbanUser(userId)
    } else {
      // Ban the user and store reason in metadata
      await client.users.banUser(userId)
      
      // Store the ban reason in metadata if provided
      if (reason) {
        await client.users.updateUser(userId, {
          publicMetadata: {
            ...user.publicMetadata,
            banReason: reason
          }
        })
      }
    }

    // Revalidate the admin users page
    revalidatePath("/admin/users")

    return { success: true }
  } catch (error) {
    console.error("Error managing user ban status:", error)
    return { success: false, error: (error as Error).message }
  }
} 

/*
  File: app/_actions/check-encounter-final.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/check-encounter-final.ts
  Directory: app/_actions
*/

--- File: app/_actions/check-encounter-final.ts ---

"use server"

import { convex } from "@/lib/convex/server"
import { api } from "@/convex/_generated/api"
import { readJsonFromS3 } from "@/lib/s3-utils"
import type { Id } from "@/convex/_generated/dataModel"
import type { AdventurePlan } from "@/types/adventure-plan"

export async function checkIsEncounterFinal(turnId: Id<"turns">): Promise<boolean> {
  // 1. Fetch the turn from Convex
  const turn = await convex.query(api.adventure.getTurnById, { turnId })
  if (!turn) throw new Error("Turn not found")

  // 2. Fetch the adventure to get settingId and planId
  const adventure = await convex.query(api.adventure.getAdventureById, { adventureId: turn.adventureId })
  if (!adventure) throw new Error("Adventure not found")

  // 3. Load the plan from S3
  const plan = (await readJsonFromS3(`settings/${adventure.settingId}/${adventure.planId}.json`)) as AdventurePlan
  if (!plan || !plan.sections) throw new Error("Adventure plan not found")

  // 4. Find current encounter
  const currentEncounter = plan.sections
    .flatMap(section => section.scenes)
    .flatMap(scene => scene.encounters)
    .find(encounter => encounter.id === turn.encounterId)

  if (!currentEncounter) throw new Error("Current encounter not found in plan")

  // 5. Check if encounter has no transitions (indicating it's the final encounter)
  return !currentEncounter.transitions || currentEncounter.transitions.length === 0
} 

/*
  File: app/_actions/contact.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/contact.ts
  Directory: app/_actions
*/

--- File: app/_actions/contact.ts ---

"use server"

import { z } from "zod"
import sgMail from "@sendgrid/mail"
import { verifyCaptcha } from "./verifyCaptcha"

const contactFormSchema = z.object({
  name: z.string().min(1, "Name is required"),
  email: z.string().email("Invalid email address"),
  message: z.string().min(1, "Message is required"),
  subject: z.string().default("Contact Form Submission"),
  captchaToken: z.string().optional(),
})

type ContactFormData = z.infer<typeof contactFormSchema>

export async function sendContactEmail(data: ContactFormData) {
  try {
    // Validate the input data
    const validatedData = contactFormSchema.parse(data)

    // Verify captcha if token is provided
    if (validatedData.captchaToken) {
      try {
        await verifyCaptcha(validatedData.captchaToken)
      } catch (error) {
        console.error("Error verifying captcha:", error)
        return {
          success: false as const,
          error: "reCAPTCHA verification failed. Please try again.",
        }
      }
    }

    // Configure SendGrid
    sgMail.setApiKey(process.env.SENDGRID_API_KEY!)

    // Prepare the email
    const msg = {
      to: process.env.CONTACT_EMAIL!,
      from: process.env.SENDGRID_SENDER!, // Must be verified sender in SendGrid
      replyTo: validatedData.email,
      subject: validatedData.subject,
      text: `Name: ${validatedData.name}\nEmail: ${validatedData.email}\n\nMessage:\n${validatedData.message}`,
      html: `
        <h2>New Contact Form Submission</h2>
        <p><strong>Name:</strong> ${validatedData.name}</p>
        <p><strong>Email:</strong> ${validatedData.email}</p>
        <p><strong>Message:</strong></p>
        <p>${validatedData.message.replace(/\n/g, "<br>")}</p>
      `,
    }

    // Send the email
    await sgMail.send(msg)

    return {
      success: true as const,
    }
  } catch (error) {
    console.error("Error sending contact email:", error)
    return {
      success: false as const,
      error: error instanceof Error ? error.message : "Failed to send email",
    }
  }
} 

/*
  File: app/_actions/create-adventure.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/create-adventure.ts
  Directory: app/_actions
*/

--- File: app/_actions/create-adventure.ts ---

'use server'

import { api } from "@/convex/_generated/api"
import { convex } from "@/lib/convex/server"
import { auth } from "@clerk/nextjs/server"
import { redirect } from "next/navigation"
import type { CharacterChoiceMode } from "@/components/adventure/character-selection"
import { readJsonFromS3 } from "@/lib/s3-utils"
import type { AdventurePlan } from "@/types/adventure-plan"

interface CreateAdventureInput {
  settingId: string
  adventurePlanId: string
  characterChoices: CharacterChoiceMode[]
}

export async function createAdventure(input: CreateAdventureInput) {
  const { userId } = await auth()
  if (!userId) {
    throw new Error("Unauthorized")
  }

  const { settingId, adventurePlanId } = input
  // TODO: Use characterChoices in later stages for lobby state

  // Read the adventure plan to get the proper title
  const planPath = `settings/${settingId}/${adventurePlanId}.json`
  const plan = (await readJsonFromS3(planPath)) as AdventurePlan
  if (!plan || !plan.title) {
    throw new Error("Adventure plan not found or is invalid")
  }

  // Extract character choices and create the players array
  const { characterChoices } = input
  const players = characterChoices
    .filter(choice => choice.mode === "player") // Only include characters selected as "player"
    .map(choice => ({
      userId: userId,
      characterId: choice.characterId,
    }))

  // Create adventure in waiting state
  const now = Date.now()
  
  // Create the adventure using the existing Convex mutation
  const adventureId = await convex.mutation(api.adventure.createAdventure, {
    planId: adventurePlanId,
    settingId,
    ownerId: userId,
    playerIds: [userId], // Keep for backwards compatibility
    players,
    status: "waitingForPlayers", // Start in lobby state
    title: plan.title, // Use the actual adventure title from the plan
    startedAt: now,
  })

  // For MVP, we'll redirect to the adventure page immediately
  // The adventure page will handle the "no current turn" state
  redirect(`/settings/${settingId}/${adventurePlanId}/${adventureId}`)
} 

/*
  File: app/_actions/ensure-npc-processed.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/ensure-npc-processed.ts
  Directory: app/_actions
*/

--- File: app/_actions/ensure-npc-processed.ts ---

'use server';

import { auth } from "@clerk/nextjs/server";
import { convex } from "@/lib/convex/server";
import { api } from "@/convex/_generated/api";
import type { Id } from "@/convex/_generated/dataModel";
import { processNpcTurnsAfterCurrent } from "@/lib/services/npc-turn-service";

export async function ensureNpcProcessed(turnId: Id<"turns">): Promise<{ status: string }> {
  const { userId } = await auth();
  if (!userId) {
    console.error('[ensureNpcProcessed] Unauthorized access attempt.');
    throw new Error("Unauthorized");
  }

  console.log(`[ensureNpcProcessed] Checking turn ${turnId} for pending NPC actions.`);
  const turn = await convex.query(api.adventure.getTurnById, { turnId });

  if (!turn) {
    console.error(`[ensureNpcProcessed] Turn ${turnId} not found.`);
    return { status: "error_turn_not_found" };
  }

  const characters = turn.characters || [];
  // Sort by initiative (highest first) to find the current actor
  const sortedCharacters = [...characters].sort((a, b) => (b.initiative ?? 0) - (a.initiative ?? 0));
  const currentActor = sortedCharacters.find(c => !c.isComplete);

  if (currentActor && currentActor.type === "npc" && !currentActor.hasReplied) {
    console.log(`[ensureNpcProcessed] Pending NPC ${currentActor.id} found in turn ${turnId}. Processing...`);
    try {
      await processNpcTurnsAfterCurrent(turnId);
      console.log(`[ensureNpcProcessed] Finished processing NPCs for turn ${turnId}.`);
      return { status: "npc_processing_triggered" };
    } catch (error) {
      console.error(`[ensureNpcProcessed] Error during processNpcTurnsAfterCurrent for turn ${turnId}:`, error);
      return { status: "error_processing_npc" };
    }
  } else {
    console.log(`[ensureNpcProcessed] No pending NPC actions found for turn ${turnId}, or current actor is not an NPC awaiting reply.`);
    return { status: "no_pending_npc" };
  }
} 

/*
  File: app/_actions/generate-character-action.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/generate-character-action.ts
  Directory: app/_actions
*/

--- File: app/_actions/generate-character-action.ts ---

'use server'

import { generateObject } from "@/lib/ai"
import { 
  npcGenerationSchema, 
  pcTemplateGenerationSchema,
  type NPC, 
  type PCTemplate 
} from "@/types/character"

interface GenerateCharacterInput {
  prompt: string
  characterType: "npc" | "pc"
}

interface GenerateCharacterResult {
  success: boolean
  character?: NPC | PCTemplate
  error?: string
}

export async function generateCharacterAction({ 
  prompt, 
  characterType 
}: GenerateCharacterInput): Promise<GenerateCharacterResult> {
  try {
    if (!prompt.trim()) {
      return {
        success: false,
        error: "Prompt is required"
      }
    }

    // Use the appropriate schema based on character type
    const schema = characterType === "npc" ? npcGenerationSchema : pcTemplateGenerationSchema

    // Enhance the prompt with character type context
    const enhancedPrompt = `Generate a ${characterType === "npc" ? "non-player character (NPC)" : "player character"} based on this description: ${prompt}. 
    
    Please include:
    - Physical appearance and personality traits
    - Background story and motivation
    - Appropriate skills and equipment based on their archetype/class
    - Race-specific traits and abilities that would be natural for their race
    - Class/archetype-specific spells (if they are a spellcaster like wizard, cleric, druid, sorcerer, bard, etc.)
    - Special abilities that align with their race, class, and background (e.g., a ranger's tracking abilities, a rogue's sneak attack, a dwarf's resistance to magic, an elf's keen senses)
    ${characterType === "pc" ? "- Balanced but generous attributes (strength, dexterity, constitution, intelligence, wisdom, charisma) suitable for the character concept" : "- Attributes if relevant to the character's role"}
    `

    const result = await generateObject({
      prompt: enhancedPrompt,
      schema
    })

    if (!result.object) {
      return {
        success: false,
        error: "Failed to generate character"
      }
    }

    // Override the status to always be empty
    const character = {
      ...result.object,
      status: ""
    } as (typeof characterType extends "npc" ? NPC : PCTemplate)

    return {
      success: true,
      character
    }

  } catch (error) {
    console.error("Error generating character:", error)
    
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred"
    
    return {
      success: false,
      error: errorMessage
    }
  }
} 

/*
  File: app/_actions/get-encounter-image.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/get-encounter-image.ts
  Directory: app/_actions
*/

--- File: app/_actions/get-encounter-image.ts ---

"use server"

import type { AdventurePlan } from "@/types/adventure-plan"

export async function getEncounterImage(adventurePlanId: string, encounterId: string): Promise<string | null> {
  try {
    // Dynamically import the adventure plan JSON file
    const adventurePlan = (await import(`@/data/${adventurePlanId}.json`)).default as AdventurePlan
    
    if (!adventurePlan) {
      console.error(`[getEncounterImage] Adventure plan not found: ${adventurePlanId}`)
      return null
    }

    // Find the encounter in the plan
    for (const section of adventurePlan.sections) {
      for (const scene of section.scenes) {
        for (const encounter of scene.encounters) {
          if (encounter.id === encounterId) {
            return encounter.image || null
          }
        }
      }
    }

    console.error(`[getEncounterImage] Encounter not found: ${encounterId} in ${adventurePlanId}`)
    return null
  } catch (error) {
    console.error(`[getEncounterImage] Error loading adventure plan ${adventurePlanId}:`, error)
    return null
  }
} 

/*
  File: app/_actions/get-roll-requirement.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/get-roll-requirement.ts
  Directory: app/_actions
*/

--- File: app/_actions/get-roll-requirement.ts ---

import { getRollRequirementForAction } from "@/lib/services/roll-requirement-service";
import type { Character } from "@/types/character";

export async function getRollRequirement(reply: string, character: Character) {
  return getRollRequirementForAction(reply, character);
} 

/*
  File: app/_actions/join-adventure.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/join-adventure.ts
  Directory: app/_actions
*/

--- File: app/_actions/join-adventure.ts ---

'use server'

import { auth } from "@clerk/nextjs/server"
import { redirect } from "next/navigation"
import { convex } from "@/lib/convex/server"
import { api } from "@/convex/_generated/api"
import type { Id } from "@/convex/_generated/dataModel"

interface JoinAdventureArgs {
  settingId: string
  adventurePlanId: string
  adventureId: string
  characterId: string
}

export async function joinAdventure({ settingId, adventurePlanId, adventureId, characterId }: JoinAdventureArgs) {
  console.log("🎲 Server Action: joinAdventure called", { settingId, adventurePlanId, adventureId, characterId })

  const { userId } = await auth()
  if (!userId) {
    throw new Error("Unauthorized: User must be signed in")
  }

  try {
    // Add the player to the adventure
    await convex.mutation(api.adventure.joinAdventure, {
      adventureId: adventureId as Id<"adventures">,
      userId,
      characterId,
    })

    console.log("🎲 Successfully joined adventure, redirecting...")

    // Redirect to the adventure page
    redirect(`/settings/${settingId}/${adventurePlanId}/${adventureId}`)
  } catch (error) {
    console.error("🎲 Failed to join adventure:", error)
    throw error
  }
} 

/*
  File: app/_actions/load-adventure.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/load-adventure.ts
  Directory: app/_actions
*/

--- File: app/_actions/load-adventure.ts ---

'use server'
import { api } from "@/convex/_generated/api";
import { convex } from "@/lib/convex/server";
import { auth } from "@clerk/nextjs/server";
import type { Id } from "@/convex/_generated/dataModel";

export async function loadAdventureWithNpc(adventureId: Id<"adventures">) {
  return convex.mutation(api.adventure.getCurrentAdventureWithNpcProcessing, { adventureId, refreshKey: Date.now() });
}

export async function loadAdventureWithTurnByOrder(adventureId: Id<"adventures">, turnOrder: number) {
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");
  
  const adventure = await convex.query(api.adventure.getAdventureById, { adventureId });
  const turn = await convex.query(api.adventure.getTurnByOrder, { adventureId, order: turnOrder });
  return { adventure, currentTurn: turn };
}

export async function getAdventureTurns(adventureId: Id<"adventures">) {
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");
  return convex.query(api.adventure.getTurnsByAdventure, { adventureId });
}

export async function getTurnNavigationInfo(adventureId: Id<"adventures">) {
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");
  return convex.query(api.adventure.getTurnNavigationInfo, { adventureId });
} 

/*
  File: app/_actions/mailing-list.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/mailing-list.ts
  Directory: app/_actions
*/

--- File: app/_actions/mailing-list.ts ---

"use server"

import { auth } from "@clerk/nextjs/server"
import sgMail from "@sendgrid/mail"
import { revalidatePath } from "next/cache"
import {
  addMailingListSubscription,
  removeMailingListSubscription,
  getMailingListSubscriptions
} from "@/lib/services/mailing-list"

// Configure SendGrid and track availability
let isEmailServiceConfigured = false

if (process.env.SENDGRID_API_KEY) {
  sgMail.setApiKey(process.env.SENDGRID_API_KEY)
  isEmailServiceConfigured = true
} else {
  console.warn("SENDGRID_API_KEY not found. Email service will be disabled.")
}

// Helper to check if email service is available
function isEmailServiceAvailable() {
  return isEmailServiceConfigured
}

export async function subscribe(data: {
  userId: string
  email: string
  name: string | null
}) {
  try {
    const result = await addMailingListSubscription({
      userId: data.userId,
      email: data.email,
      name: data.name ?? undefined,
      // Preferences are no longer passed for waitlist
    })
    revalidatePath("/mailing-list") // Consider if this path is still relevant or needs to be /waitlist
    return {
      success: !!result,
      emailServiceAvailable: isEmailServiceAvailable()
    }
  } catch (error) {
    console.error("Error in subscribe:", error)
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to subscribe",
      emailServiceAvailable: isEmailServiceAvailable()
    }
  }
}

export async function unsubscribe(email: string) {
  try {
    const result = await removeMailingListSubscription(email)
    revalidatePath("/mailing-list") // Consider if this path is still relevant
    return {
      success: result,
      emailServiceAvailable: isEmailServiceAvailable()
    }
  } catch (error) {
    console.error("Error in unsubscribe:", error)
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to unsubscribe",
      emailServiceAvailable: isEmailServiceAvailable()
    }
  }
}

export async function getSubscription() {
  try {
    const { userId } = await auth()
    if (!userId) {
      return {
        success: true as const,
        data: null,
      }
    }
    const subscriptions = await getMailingListSubscriptions()
    // Assuming the shape of subscription object and how to find the relevant one might need adjustment
    // if `unsubscribedAt` or other fields were tied to preferences.
    const sub = subscriptions.find(s => s.userId === userId && s.unsubscribedAt === null)
    return {
      success: true as const,
      data: sub || null,
    }
  } catch (error) {
    console.error("Error in getSubscription:", error)
    return {
      success: false as const,
      error: error instanceof Error ? error.message : "Failed to get subscription",
    }
  }
} 

/*
  File: app/_actions/profile.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/profile.ts
  Directory: app/_actions
*/

--- File: app/_actions/profile.ts ---

"use server"

import { clerkClient } from "@clerk/nextjs/server"
import { revalidatePath } from "next/cache"

interface Link {
  label: string
  url: string
}

interface UpdateProfileData {
  firstName: string
  lastName: string
  bio: string
  website?: string
  twitter?: string
  github?: string
  customLinks?: Link[]
}

export async function updateProfile(userId: string, data: UpdateProfileData) {
  try {
    const client = await clerkClient()
    await client.users.updateUser(userId, {
      firstName: data.firstName || "",
      lastName: data.lastName || "",
      unsafeMetadata: {
        bio: data.bio || "",
        website: data.website || "",
        twitter: data.twitter || "",
        github: data.github || "",
        customLinks: data.customLinks || [],
      },
    })

    return { success: true }
  } catch (error) {
    console.error("Error updating profile:", error)
    return { success: false, error: "Failed to update profile" }
  }
}

export async function refreshProfile(path: string) {
  revalidatePath(path)
} 

/*
  File: app/_actions/setting-actions.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/setting-actions.ts
  Directory: app/_actions
*/

--- File: app/_actions/setting-actions.ts ---

'use server'

import { auth } from "@clerk/nextjs/server"
import { updateJsonOnS3, readJsonFromS3, copyS3Object } from "@/lib/s3-utils"
import { Setting } from "@/types/setting"

interface UpdateSettingParams {
  setting: Setting
  settingId: string
}

export async function updateSettingAction(
  params: UpdateSettingParams
): Promise<{ success: boolean; message?: string; error?: string }> {
  console.log("updateSettingAction: Received params:", JSON.stringify(params, null, 2))

  const { userId } = await auth()
  if (!userId) {
    console.error("updateSettingAction: Unauthorized access attempt.")
    return { success: false, error: "Unauthorized" }
  }

  const { setting, settingId } = params
  console.log("updateSettingAction: Extracted setting object:", JSON.stringify(setting, null, 2))

  if (!setting || !settingId) {
    console.error("updateSettingAction: Invalid setting data provided:", setting)
    return { success: false, error: "Invalid setting data provided." }
  }

  const originalKey = `settings/${settingId}/setting-data.json`
  const timestamp = Date.now()
  const backupKey = `settings/${settingId}/backups/setting-data-${timestamp}.json`

  try {
    // Try to create a backup of the existing setting
    try {
      await readJsonFromS3(originalKey)
      await copyS3Object(originalKey, backupKey)
      console.log(`updateSettingAction: Backup created for ${originalKey} at ${backupKey}`)
    } catch (readError: unknown) {
      let errorMessage = "An unknown error occurred during pre-backup check."
      if (readError instanceof Error) {
        errorMessage = readError.message
      }
      if (errorMessage.includes("No file body returned from S3") || errorMessage.includes("NoSuchKey")) {
        console.log(`updateSettingAction: Original file ${originalKey} not found, skipping backup.`)
      } else {
        console.warn(`updateSettingAction: Could not back up ${originalKey} due to an unexpected error during pre-backup check: ${errorMessage}`, readError)
      }
    }
    
    // Log setting data before calling updateJsonOnS3
    console.log("updateSettingAction: setting.locations before S3 update:", JSON.stringify(setting.locations, null, 2))
    console.log("updateSettingAction: Full setting object before S3 update:", JSON.stringify(setting, null, 2))

    await updateJsonOnS3(originalKey, setting)
    return { success: true, message: "Setting updated successfully." }
  } catch (error) {
    console.error(`updateSettingAction: Error during S3 operations for ${originalKey}:`, error)
    console.error("updateSettingAction: Failed setting object structure:", JSON.stringify(setting, null, 2))
    const errorMessage = error instanceof Error ? error.message : "An unknown error occurred"
    return { success: false, error: `Failed to update setting: ${errorMessage}` }
  }
} 

/*
  File: app/_actions/start-adventure.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/start-adventure.ts
  Directory: app/_actions
*/

--- File: app/_actions/start-adventure.ts ---

'use server'

import { auth } from "@clerk/nextjs/server"
import { redirect } from "next/navigation"
import { convex } from "@/lib/convex/server"
import { api } from "@/convex/_generated/api"
import type { Id } from "@/convex/_generated/dataModel"
import { readJsonFromS3 } from "@/lib/s3-utils"
import type { AdventurePlan } from "@/types/adventure-plan"

interface StartAdventureArgs {
  settingId: string
  adventurePlanId: string
  adventureId: string
}

export async function startAdventure({ settingId, adventurePlanId, adventureId }: StartAdventureArgs) {
  console.log("🎲 Server Action: startAdventure called", { settingId, adventurePlanId, adventureId })

  const { userId } = await auth()
  if (!userId) {
    throw new Error("Unauthorized: User must be signed in")
  }

  try {
    // Load adventure plan
    const planPath = `settings/${settingId}/${adventurePlanId}.json`
    const adventurePlan = (await readJsonFromS3(planPath)) as AdventurePlan
    if (!adventurePlan) {
      throw new Error("Adventure plan not found")
    }

    console.log("🎲 Adventure plan loaded:", JSON.stringify({
      title: adventurePlan.title,
      party: adventurePlan.party,
      premadeCharacterCount: adventurePlan.premadePlayerCharacters?.length || 0
    }, null, 2))

    // Get the current adventure to access player data
    const adventure = await convex.query(api.adventure.getAdventureById, {
      adventureId: adventureId as Id<"adventures">
    })

    if (!adventure) {
      throw new Error("Adventure not found")
    }

    console.log("🎲 Current adventure data:", JSON.stringify({
      id: adventure._id,
      title: adventure.title,
      status: adventure.status,
      players: adventure.players,
      playerIds: adventure.playerIds
    }, null, 2))

    // Get the first encounter from the adventure plan
    const firstSection = adventurePlan.sections[0]
    const firstScene = firstSection.scenes[0]
    const firstEncounter = firstScene.encounters[0]

    if (!firstEncounter) {
      throw new Error("No encounters found in adventure plan")
    }

    console.log("🎲 First encounter:", JSON.stringify({
      id: firstEncounter.id,
      title: firstEncounter.title,
      skipInitialNpcTurns: firstEncounter.skipInitialNpcTurns
    }, null, 2))

    // Build the characters array from adventure players + NPCs
    const characters = []

    // Add player characters
    if (adventure.players) {
      for (const player of adventure.players) {
        const characterTemplate = adventurePlan.premadePlayerCharacters.find(pc => pc.id === player.characterId)
        if (characterTemplate) {
          const pcCharacter = {
            ...characterTemplate,
            type: "pc" as const,
            userId: player.userId,
            initiative: Math.floor(Math.random() * 20) + 1, // Random initiative for now
            hasReplied: false,
            isComplete: false
          }
          characters.push(pcCharacter)
        }
      }
    }

    // Add NPC characters from the encounter
    if (firstEncounter.npc) {
      for (const npcRef of firstEncounter.npc) {
        const npcTemplate = adventurePlan.npcs[npcRef.id]
        if (npcTemplate) {
          const npcCharacter = {
            ...npcTemplate,
            type: "npc" as const,
            initiative: npcRef.initialInitiative || Math.floor(Math.random() * 20) + 1,
            hasReplied: false,
            isComplete: false,
            behavior: npcRef.behavior
          }
          characters.push(npcCharacter)
        }
      }
    }

    console.log("🎲 Turn characters being created:", JSON.stringify(characters.map(c => ({
      id: c.id,
      name: c.name,
      type: c.type,
      initiative: c.initiative,
      userId: c.type === "pc" ? c.userId : undefined
    })), null, 2))

    // Create the first turn
    const turnId = await convex.mutation(api.adventure.createTurn, {
      adventureId: adventureId as Id<"adventures">,
      encounterId: firstEncounter.id,
      title: firstEncounter.title,
      narrative: firstEncounter.intro,
      characters: characters,
      order: 1,
    })

    console.log("🎲 Successfully started adventure with first turn:", turnId)
    console.log("🎲 Turn created with", characters.length, "characters")

    // Redirect to the adventure page (which will show the first turn)
    redirect(`/settings/${settingId}/${adventurePlanId}/${adventureId}`)
  } catch (error) {
    console.error("🎲 Failed to start adventure:", error)
    throw error
  }
} 

/*
  File: app/_actions/tokens.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/tokens.ts
  Directory: app/_actions
*/

--- File: app/_actions/tokens.ts ---

'use server'

import { auth } from "@clerk/nextjs/server";
import { convex } from "@/lib/convex/server"; // Assuming you have a server client setup
import { api } from "@/convex/_generated/api";

interface DecrementTokensArgs {
  tokensUsed: number;
  transactionType: "usage_generate_text" | "usage_generate_object" | "usage_image_upload";
  description?: string;
  modelId?: string;
}

export async function decrementUserTokensAction(args: DecrementTokensArgs) {
  const { userId } = await auth(); 

  if (!userId) {
    console.error("decrementUserTokensAction: User not authenticated. Cannot decrement tokens.");
    // Depending on strictness, you might throw an error or return a specific failure response
    return { success: false, error: "User not authenticated" };
  }

  if (args.tokensUsed <= 0) {
    console.log("decrementUserTokensAction: No tokens to decrement or invalid amount.", args);
    return { success: true, message: "No tokens to decrement or invalid amount." };
  }

  try {
    const description = args.description || `Token usage for ${args.transactionType}${args.modelId ? ' (' + args.modelId + ')' : ''}`;
    
    // Different token calculations for different transaction types
    let tokensUsed: number;
    if (args.transactionType === "usage_image_upload") {
      // Image uploads are a flat rate, no multiplier needed
      tokensUsed = args.tokensUsed;
    } else {
      // AI generation uses a multiplier: 100 tokens of gemini usage = 1 token of D20 usage
      const TOKEN_DECREMENT_MULTIPLIER = 0.01;
      tokensUsed = args.tokensUsed * TOKEN_DECREMENT_MULTIPLIER;
    }
    const result = await convex.mutation(api.userTokenManagement.decrementTokens, {
      userId,
      tokensUsed,
      transactionType: args.transactionType,
      description: description,
    });
    return { success: true, data: result };
  } catch (error) {
    console.error(
      "decrementUserTokensAction: Failed to decrement tokens for user:",
      userId,
      "Error:",
      error
    );
    // Handle specific errors from decrementTokens if needed, e.g., insufficient tokens
    return { success: false, error: "Failed to decrement tokens", details: error };
  }
} 

/*
  File: app/_actions/track-visit.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/track-visit.ts
  Directory: app/_actions
*/

--- File: app/_actions/track-visit.ts ---

'use server'

import { auth } from "@clerk/nextjs/server"
import { headers } from "next/headers"
import { validRoutes } from "@/lib/generated/routes"
import { ConvexHttpClient } from "convex/browser"
import { api } from "@/convex/_generated/api"

// Initialize Convex HTTP client
const convex = new ConvexHttpClient(process.env.NEXT_PUBLIC_CONVEX_URL!)

// Check if the user agent is from a common legitimate browser
function isValidBrowser(userAgent: string | null): boolean {
  if (!userAgent) return false
  
  const commonBrowsers = [
    'Chrome',
    'Firefox',
    'Safari',
    'Edge',
    'Opera',
    'Edg',  // Edge's newer user agent
    'OPR',  // Opera's newer user agent
  ]
  
  const lowerUA = userAgent.toLowerCase()
  return commonBrowsers.some(browser => 
    lowerUA.includes(browser.toLowerCase())
  )
}

// Check if a path exists in our app
function isValidPath(path: string): boolean {
  // Special case for root path
  if (path === '/') {
    return true
  }

  // Normalize the path by removing leading slash
  const normalizedPath = path.startsWith('/') ? path.slice(1) : path
  
  // Check exact match first
  if (validRoutes.has(normalizedPath)) {
    return true
  }

  // Check if the path matches any dynamic routes
  // Split the path into segments
  const segments = normalizedPath.split('/')
  
  // Try matching each segment level
  let currentPath = ''
  for (const segment of segments) {
    currentPath = currentPath + (currentPath === '' ? segment : '/' + segment)
    // Check if there's a wildcard route at this level
    if (validRoutes.has(currentPath + '/*')) {
      return true
    }
  }

  return false
}

export async function trackVisit(path: string) {
  try {
    // Get the current user's ID if they're authenticated
    const { userId } = await auth()
    
    // Get headers for user agent and referrer
    const headersList = await headers()
    const userAgent = headersList.get('user-agent')
    const referrer = headersList.get('referer') // Note: 'referer' is the standard header name
    
    // Skip recording visits from non-browser user agents
    if (!isValidBrowser(userAgent)) {
      return { success: true }
    }

    // Skip recording visits to invalid paths
    if (!isValidPath(path)) {
      return { success: true }
    }

    // Record the visit using Convex
    await convex.mutation(api.visits.recordVisit, {
      path,
      userId: userId || null,
      metadata: {
        userAgent: userAgent || null,
        referrer: referrer || null,
      }
    })

    return { success: true }
  } catch (error) {
    console.error('Error tracking visit:', error)
    return { success: false, error: (error as Error).message }
  }
} 

/*
  File: app/_actions/user-token-actions.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/user-token-actions.ts
  Directory: app/_actions
*/

--- File: app/_actions/user-token-actions.ts ---

'use server';

import { auth } from "@clerk/nextjs/server";
import { convex } from "@/lib/convex/server";
import { api } from "@/convex/_generated/api";

export type TokenBalanceResponse = {
  tokensRemaining: number | null;
  alltimeTokens: number | null;
  error: string | null;
};

export async function fetchUserTokenBalance(): Promise<TokenBalanceResponse> {
  const { userId } = await auth();
  if (!userId) {
    // Return a specific error object instead of throwing
    return {
      tokensRemaining: null,
      alltimeTokens: null,
      error: "USER_NOT_AUTHENTICATED"
    };
  }

  try {
    // Step 1: Ensure the user token record exists (and grant initial tokens if new)
    await convex.mutation(api.userTokenManagement.ensureUserTokenRecord, { userId });

    // Step 2: Fetch the latest token balance
    const balance = await convex.query(api.userTokenManagement.getTokenBalance, { userId });
    
    return {
      tokensRemaining: balance.tokensRemaining,
      alltimeTokens: balance.alltimeTokens,
      error: null
      // You could also return balance.needsInitialization if the client needs to know
    };
  } catch (error) {
    console.error(`Error fetching token balance for user ${userId}:`, error);
    // Return error object instead of throwing
    return {
      tokensRemaining: null,
      alltimeTokens: null,
      error: `Failed to fetch token balance: ${error instanceof Error ? error.message : String(error)}`
    };
  }
} 

/*
  File: app/_actions/verifyCaptcha.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_actions/verifyCaptcha.ts
  Directory: app/_actions
*/

--- File: app/_actions/verifyCaptcha.ts ---

export async function verifyCaptcha(captchaToken: string) {
  "use server";

  const RECAPTCHA_SECRET_KEY = process.env.RECAPTCHA_SECRET_KEY;

  const response = await fetch(`https://www.google.com/recaptcha/api/siteverify`, {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
    },
    body: `secret=${RECAPTCHA_SECRET_KEY}&response=${captchaToken}`,
  });

  const captchaValidation = await response.json();
  if (captchaValidation.success) {
    return true;
  } else {
    throw new Error("reCAPTCHA validation failed");
  }
}

/*
  File: app/_hooks/useGenerateImage.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_hooks/useGenerateImage.ts
  Directory: app/_hooks
*/

--- File: app/_hooks/useGenerateImage.ts ---

import { useState } from "react"

interface ImageResponse {
  imageUrl: string
  success: boolean
  error?: string
}

export function useGenerateImage() {
  const [error, setError] = useState<string>("")
  const [isLoading, setIsLoading] = useState(false)
  const [imageUrl, setImageUrl] = useState<string>("")

  const generate = async (prompt: string) => {
    setError("")
    setIsLoading(true)
    try {
      const response = await fetch("/api/ai/generate/image", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          input: prompt,
          userId: "demo", // Using a demo folder for the AI demo
          deckId: "ai-demo" // Using a fixed demo deck ID
        }),
      })

      const data: ImageResponse = await response.json()

      if (!data.success) {
        throw new Error(data.error || "Failed to generate image")
      }

      setImageUrl(data.imageUrl)
    } catch (err) {
      console.error("Error generating image:", err)
      setError(err instanceof Error ? err.message : "Failed to generate image")
    } finally {
      setIsLoading(false)
    }
  }

  return {
    imageUrl,
    isLoading,
    error,
    generate,
  }
} 

/*
  File: app/_hooks/useGenerateObject.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_hooks/useGenerateObject.ts
  Directory: app/_hooks
*/

--- File: app/_hooks/useGenerateObject.ts ---

import { experimental_useObject as useObject } from "@ai-sdk/react"
import { z } from "zod"
import { useState } from "react"
import { zodToJsonSchema } from "zod-to-json-schema"

export function useGenerateObject<T extends z.ZodTypeAny>(schema: T) {
  const [error, setError] = useState<string>("")
  
  type InferredType = z.infer<T>
  
  const { object, isLoading, submit } = useObject<InferredType>({
    api: "/api/ai/generate/object",
    schema,
  })

  const generate = async (prompt: string) => {
    setError("")
    try {
      // Convert Zod schema to JSON schema
      const jsonSchema = zodToJsonSchema(schema)
      
      await submit({
        schema: jsonSchema,
        prompt,
      })
    } catch (err) {
      console.error("Error generating object:", err)
      setError("Failed to generate structured data")
    }
  }

  return {
    object,
    isLoading,
    error,
    generate,
  }
}

// Example usage:
// const { object, isLoading, error, generate } = useGenerateObject(personSchema)


/*
  File: app/_hooks/useGenerateStrings.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_hooks/useGenerateStrings.ts
  Directory: app/_hooks
*/

--- File: app/_hooks/useGenerateStrings.ts ---

import { experimental_useObject as useObject } from '@ai-sdk/react';
import { z } from "zod"
import { useState, useEffect, useRef } from "react"

const responseSchema = z.object({
  strings: z.array(z.string()),
})

type ResponseType = z.infer<typeof responseSchema>

export function useGenerateStrings() {
  const [strings, setStrings] = useState<string[]>([])
  const [error, setError] = useState<string>("")
  const promiseRef = useRef<{
    resolve: (value: string[]) => void;
    reject: (reason?: Error | unknown) => void;
  } | null>(null);

  const {
    object: response,
    isLoading,
    submit,
    error: objectError,
  } = useObject<ResponseType>({
    api: "/api/ai/generate/strings",
    schema: responseSchema,
  })

  useEffect(() => {
    if (objectError) {
      console.error("useGenerateStrings error:", objectError)
      setError("An error occurred while generating strings.")
      if (promiseRef.current) {
        promiseRef.current.reject(objectError);
        promiseRef.current = null;
      }
    }
  }, [objectError])

  useEffect(() => {
    if (response?.strings) {
      const validStrings = response.strings.filter((s): s is string => typeof s === "string")
      setStrings(validStrings)
    }
  }, [response])

  // Effect to resolve the promise when loading completes
  useEffect(() => {
    // If we were loading and now we're not, and we have a promise to resolve
    if (!isLoading && promiseRef.current && response?.strings) {
      const validStrings = response.strings.filter((s): s is string => typeof s === "string")
      promiseRef.current.resolve(validStrings);
      promiseRef.current = null;
    }
  }, [isLoading, response]);

  const generate = async (prompt: string, count: number = 6) => {
    setError("")
    setStrings([])
    
    return new Promise<string[]>((resolve, reject) => {
      try {
        // Store the promise callbacks
        promiseRef.current = { resolve, reject };
        
        // Submit the request
        submit({
          prompt,
          count,
        })
        
        // Set a timeout of 30 seconds
        const timeoutId = setTimeout(() => {
          if (promiseRef.current) {
            promiseRef.current.reject(new Error("Timed out waiting for string generation"));
            promiseRef.current = null;
          }
        }, 30000);
        
        // Clean up timeout if component unmounts
        return () => clearTimeout(timeoutId);
      } catch (error) {
        console.error("Error submitting string generation:", error)
        setError("An error occurred while generating strings.")
        reject(error);
        promiseRef.current = null;
      }
    })
  }

  return {
    strings,
    isLoading,
    error,
    generate,
  }
}


/*
  File: app/_hooks/useGenerateText.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/_hooks/useGenerateText.ts
  Directory: app/_hooks
*/

--- File: app/_hooks/useGenerateText.ts ---

"use client"
import { useChat } from "@ai-sdk/react"

export function useGenerateText() {
  const { messages, input, handleInputChange, handleSubmit } = useChat({
    api: "/api/ai/generate/text",
  })

  const streamText = async (prompt: string, onUpdate: (output: string) => void) => {
    
    const response = await fetch("/api/ai/generate/text", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ input: prompt + " - Use smart quotes and avoid using backslashes" }),
    })

    if (!response.ok) {
      throw new Error(response.statusText)
    }

    const data = response.body
    if (!data) {
      return
    }

    const reader = data.getReader()
    const decoder = new TextDecoder()
    let done = false
    let accumulatedResponse = ""

    while (!done) {
      const { value, done: doneReading } = await reader.read()
      done = doneReading
      const chunkValue = decoder.decode(value)

      // Handle chunks with "0:" prefix
      const chunks = chunkValue.split(/(?=\d+:"|[ed]:"|f:)/).filter(Boolean)

      for (const chunk of chunks) {
        // Skip metadata chunks (including messageId)
        if (chunk.startsWith("f:") || chunk.startsWith("e:") || chunk.startsWith("d:")) {
          continue
        }

        if (chunk.startsWith('0:"')) {
          // Extract content between quotes for "0:" prefixed chunks
          const content = chunk.match(/0:"([^"]*)"/)
          if (content) {
            // Replace literal \n\n with actual newlines and clean up backslashed quotes
            accumulatedResponse += content[1]
              .replace(/\\n\\n/g, "\n\n")
              .replace(/\\"/g, '"')
              .replace(/\\\\/g, "\\")
          }
        } else {
          // Fallback: try to extract any quoted content
          const content = chunk.match(/"([^"]*)"/)
          if (content) {
            // Replace literal \n\n with actual newlines and clean up backslashed quotes
            accumulatedResponse += content[1]
              .replace(/\\n\\n/g, "\n\n")
              .replace(/\\"/g, '"')
              .replace(/\\\\/g, "\\")
          } else {
            // Replace literal \n\n with actual newlines and clean up backslashed quotes
            accumulatedResponse += chunk
              .replace(/\\n\\n/g, "\n\n")
              .replace(/\\"/g, '"')
              .replace(/\\\\/g, "\\")
          }
        }
      }
      onUpdate(accumulatedResponse)
    }

    return accumulatedResponse
  }

  return {
    messages,
    input,
    handleInputChange,
    handleSubmit,
    streamText,
  }
}

/*
  File: app/about/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/about/page.tsx
  Directory: app/about
*/

--- File: app/about/page.tsx ---

import { Heading } from "@/components/typography/heading"
export default function AboutPage() {
  return (
    <div className="container py-12">
      <div className="mx-auto max-w-4xl">
        <div className="mb-12 text-center">
          <Heading variant="h2" as="h1">
            About
          </Heading>
        </div>

        <div className="mb-8 space-y-6">
          <p>Replace this with your about page content...</p>
        </div>
      </div>
    </div>
  )
}


/*
  File: app/account/[[...rest]]/components/account-profile.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/account/[[...rest]]/components/account-profile.tsx
  Directory: app/account/[[...rest]]/components
*/

--- File: app/account/[[...rest]]/components/account-profile.tsx ---

"use client"

import { UserProfile, useUser } from "@clerk/nextjs"
import { BookText } from "lucide-react"
import { BioSection } from "./bio-section"

export function AccountProfile() {
  const { isLoaded, isSignedIn } = useUser()

  if (!isLoaded) {
    return null // or a loading spinner
  }

  if (!isSignedIn) {
    return null // we already handle this case in the parent
  }

  return (
    <UserProfile
      appearance={{
        elements: {
          rootBox: "mx-auto max-w-3xl",
          card: "shadow-none",
        },
      }}
      path="/account"
    >
      <UserProfile.Page label="Bio" url="bio" labelIcon={<BookText className="h-4 w-4" />}>
        <BioSection />
      </UserProfile.Page>
    </UserProfile>
  )
}


/*
  File: app/account/[[...rest]]/components/bio-section.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/account/[[...rest]]/components/bio-section.tsx
  Directory: app/account/[[...rest]]/components
*/

--- File: app/account/[[...rest]]/components/bio-section.tsx ---

"use client"

import { useUser } from "@clerk/nextjs"
import { useState } from "react"
import { Button } from "@/components/ui/button"
import { Textarea } from "@/components/ui/textarea"

export function BioSection() {
  const { user } = useUser()
  const [bio, setBio] = useState((user?.unsafeMetadata?.bio as string) || "")
  const [isSaving, setIsSaving] = useState(false)

  const saveBio = async () => {
    if (!user) return
    setIsSaving(true)
    try {
      await user.update({
        unsafeMetadata: {
          ...user.unsafeMetadata,
          bio,
        },
      })
    } catch (error) {
      console.error("Error saving bio:", error)
    }
    setIsSaving(false)
  }

  return (
    <div className="rounded-lg border p-4">
      <h2 className="text-lg font-semibold mb-4">Your Bio</h2>
      <Textarea placeholder="Tell us about yourself..." value={bio} onChange={(e) => setBio(e.target.value)} className="mb-4" rows={4} />
      <Button onClick={saveBio} disabled={isSaving}>
        {isSaving ? "Saving..." : "Save Bio"}
      </Button>
    </div>
  )
}


/*
  File: app/account/[[...rest]]/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/account/[[...rest]]/page.tsx
  Directory: app/account/[[...rest]]
*/

--- File: app/account/[[...rest]]/page.tsx ---

import { auth } from "@clerk/nextjs/server"
import { Container } from "@/components/ui/container"
import { Card, CardContent } from "@/components/ui/card"
import { SignInButton } from "@clerk/nextjs"
import { Button } from "@/components/ui/button"
import { AccountProfile } from "./components/account-profile"

export default async function AccountPage() {
  const { userId } = await auth()

  if (!userId) {
    return (
      <Container>
        <div className="py-16">
          <Card className="max-w-xl mx-auto">
            <CardContent className="flex flex-col items-center gap-6 py-16">
              <div className="text-center space-y-2">
                <h2 className="text-2xl font-semibold">Sign in to Access Your Account</h2>
                <p className="text-muted-foreground">Create an account or sign in to manage your profile</p>
              </div>
              <SignInButton mode="modal">
                <Button size="lg">Sign in to Continue</Button>
              </SignInButton>
            </CardContent>
          </Card>
        </div>
      </Container>
    )
  }

  return (
    <Container>
      <div className="py-16">
        <AccountProfile />
      </div>
    </Container>
  )
}


/*
  File: app/admin/mailing-list/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/admin/mailing-list/page.tsx
  Directory: app/admin/mailing-list
*/

--- File: app/admin/mailing-list/page.tsx ---

import { requireAdmin } from "@/lib/auth-utils"
import { AdminBreadcrumb } from "@/components/nav/admin-breadcrumb"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { MailingListSubscriberTable } from "@/components/admin/mailing-list/mailing-list-subscriber-table"
import { getMailingListSubscriptions } from "@/lib/services/mailing-list"
import { Doc } from "@/convex/_generated/dataModel"

type ConvexSubscription = Doc<"mailing_list_subscriptions">

function serializeForClient(subscriber: ConvexSubscription) {
  return {
    id: subscriber._id,
    userId: subscriber.userId,
    email: subscriber.email,
    name: subscriber.name ?? null,
    preferences: subscriber.preferences,
    subscribedAt: new Date(subscriber.subscribedAt).toISOString(),
    unsubscribedAt: subscriber.unsubscribedAt ? new Date(subscriber.unsubscribedAt).toISOString() : null,
    createdAt: new Date(subscriber.createdAt).toISOString(),
    updatedAt: new Date(subscriber.updatedAt).toISOString(),
  }
}

export default async function AdminMailingListPage() {
  // Check if the user is an admin
  await requireAdmin()

  // Fetch subscribers through the service layer
  const subscribers = await getMailingListSubscriptions()

  // Serialize the data for client components
  const serializedSubscribers = subscribers.map(serializeForClient)

  return (
    <div className="container py-8">
      <AdminBreadcrumb items={[{ label: "Mailing List" }]} />

      <div className="mb-8">
        <h1 className="text-4xl font-bold">Mailing List Subscribers</h1>
        <p className="text-muted-foreground">View and manage newsletter subscribers</p>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>All Subscribers</CardTitle>
        </CardHeader>
        <CardContent className="pb-6">
          <MailingListSubscriberTable subscribers={serializedSubscribers} />
        </CardContent>
      </Card>
    </div>
  )
}


/*
  File: app/admin/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/admin/page.tsx
  Directory: app/admin
*/

--- File: app/admin/page.tsx ---

import { Metadata } from "next"
import Link from "next/link"
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { requireAdmin } from "@/lib/auth-utils"
import { AdminConfigMessage } from "@/components/admin/admin-config-message"
import { DevEnvNotice } from "@/components/admin/dev-env-notice"
import { Heading } from "@/components/typography/heading"

export const metadata: Metadata = {
  title: "Admin Dashboard",
  description: "D20 Admin Dashboard",
}

export default async function AdminPage() {
  const { isAdmin, requiresSetup } = await requireAdmin()

  if (requiresSetup) {
    return (
      <div className="container max-w-2xl py-8 md:py-12">
        <AdminConfigMessage />
      </div>
    )
  }

  if (!isAdmin) {
    return (
      <div className="container py-8 md:py-12">
        <div className="mx-auto max-w-2xl text-center">
          <Heading variant="h1" className="mb-4">
            Access Denied
          </Heading>
          <p className="text-muted-foreground text-balance mb-8">You don&apos;t have permission to access this page. Please contact an administrator if you believe this is an error.</p>
        </div>
      </div>
    )
  }

  return (
    <div className="container py-8 md:py-12">
      <div className="mx-auto max-w-6xl">
        <Heading variant="h3" className="mb-8 text-center text-primary">
          Admin Dashboard
        </Heading>
        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          <Card>
            <CardHeader>
              <CardTitle>Users</CardTitle>
              <CardDescription>Manage user accounts</CardDescription>
            </CardHeader>
            <CardContent>
              <p className="text-sm text-muted-foreground">View user information and manage admin access.</p>
            </CardContent>
            <CardFooter>
              <Link href="/admin/users" className="w-full">
                <Button className="w-full">Manage Users</Button>
              </Link>
            </CardFooter>
          </Card>
          <Card>
            <CardHeader>
              <CardTitle>Mailing List</CardTitle>
              <CardDescription>Manage subscribers</CardDescription>
            </CardHeader>
            <CardContent>
              <p className="text-sm text-muted-foreground">View and manage newsletter subscribers and preferences.</p>
            </CardContent>
            <CardFooter>
              <Link href="/admin/mailing-list" className="w-full">
                <Button className="w-full">Manage Subscribers</Button>
              </Link>
            </CardFooter>
          </Card>
        </div>
      </div>
    </div>
  )
}


/*
  File: app/admin/users/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/admin/users/page.tsx
  Directory: app/admin/users
*/

--- File: app/admin/users/page.tsx ---

import { requireAdmin } from "@/lib/auth-utils"
import { AdminBreadcrumb } from "@/components/nav/admin-breadcrumb"
import { AdminUserList } from "@/components/admin/user-list"
import { clerkClient } from "@clerk/nextjs/server"
import type { User } from "@clerk/nextjs/server"

async function getInitialUsers() {
  const client = await clerkClient()
  const { data: users } = await client.users.getUserList()
  const adminUserIds = process.env.ADMIN_USER_IDS?.split(",") || []

  return users.map((user: User) => ({
    id: user.id,
    email: user.emailAddresses[0]?.emailAddress,
    username: user.username,
    firstName: user.firstName,
    lastName: user.lastName,
    imageUrl: user.imageUrl,
    createdAt: new Date(user.createdAt).toLocaleDateString(),
    isAdmin: adminUserIds.includes(user.id),
    banned: user.banned,
    publicMetadata: user.publicMetadata,
  }))
}

export default async function AdminUsersPage() {
  // Check if the user is an admin
  await requireAdmin()

  // Fetch initial users data
  const initialUsers = await getInitialUsers()

  return (
    <div className="container py-8">
      <AdminBreadcrumb items={[{ label: "Users" }]} />

      <div className="mb-8">
        <h1 className="text-4xl font-bold">Users</h1>
        <p className="text-muted-foreground">Manage and view user information</p>
      </div>

      <AdminUserList initialUsers={initialUsers} />
    </div>
  )
}


/*
  File: app/api/adventure/stream/[adventureId]/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/adventure/stream/[adventureId]/route.ts
  Directory: app/api/adventure/stream/[adventureId]
*/

--- File: app/api/adventure/stream/[adventureId]/route.ts ---

import { auth } from "@clerk/nextjs/server";
import { api } from "@/convex/_generated/api";
import type { Id } from "@/convex/_generated/dataModel";
import { ConvexClient } from "convex/browser";

export async function GET(
  _: Request,
  { params }: { params: Promise<{ adventureId: string }> }
) {
  const convex = new ConvexClient(process.env.CONVEX_URL!);
  const { adventureId } = await params;
  console.log("[SSE API] adventureId:", adventureId);
  const { userId } = await auth();
  if (!userId) {
    console.warn("[SSE API] Unauthorized access attempt");
    return new Response("Unauthorized", { status: 401 });
  }

  if (!adventureId || typeof adventureId !== "string" || adventureId.length < 10) {
    console.error("[SSE API] Invalid adventureId:", adventureId);
    return new Response("Invalid adventureId", { status: 400 });
  }

  let interval: NodeJS.Timeout;
  const stream = new ReadableStream({
    async start(controller) {
      let lastTurnId: string | null = null;
      let lastTurn: unknown = null;
      // Send initial data immediately
      try {
        const adventure = await convex.query(api.adventure.getAdventureById, { adventureId: adventureId as Id<"adventures"> });
        let turn = null;
        if (adventure && adventure.currentTurnId) {
          turn = await convex.query(api.adventure.getTurnById, { turnId: adventure.currentTurnId });
        }
        controller.enqueue(`data: ${JSON.stringify(turn)}\n\n`);
        lastTurnId = adventure?.currentTurnId ?? null;
        lastTurn = turn;
      } catch (err) {
        console.error("[SSE API] Error fetching initial adventure/turn:", err);
        controller.enqueue(`event: error\ndata: ${JSON.stringify({ error: 'Failed to fetch adventure/turn' })}\n\n`);
      }
      interval = setInterval(async () => {
        try {
          const adventure = await convex.query(api.adventure.getAdventureById, { adventureId: adventureId as Id<"adventures"> });
          let turn = null;
          if (adventure && adventure.currentTurnId) {
            turn = await convex.query(api.adventure.getTurnById, { turnId: adventure.currentTurnId });
          }
          if (adventure?.currentTurnId !== lastTurnId || JSON.stringify(turn) !== JSON.stringify(lastTurn)) {
            controller.enqueue(`data: ${JSON.stringify(turn)}\n\n`);
            lastTurnId = adventure?.currentTurnId ?? null;
            lastTurn = turn;
          }
        } catch (err) {
          console.error("[SSE API] Error fetching adventure/turn in interval:", err);
          controller.enqueue(`event: error\ndata: ${JSON.stringify({ error: 'Failed to fetch adventure/turn' })}\n\n`);
        }
      }, 2000);
    },
    cancel() {
      clearInterval(interval);
      console.log("[SSE API] Stream cancelled for adventureId:", adventureId);
    },
  });

  return new Response(stream, {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      Connection: "keep-alive",
    },
  });
} 

/*
  File: app/api/ai/_auth.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/ai/_auth.ts
  Directory: app/api/ai
*/

--- File: app/api/ai/_auth.ts ---

import { auth } from "@clerk/nextjs/server"
import { NextResponse } from "next/server"

export async function requireAuthMiddleware() {
  const { userId } = await auth()

  if (!userId) {
    return NextResponse.json(
      { error: "Authentication required" },
      { status: 401 }
    )
  }

  return null // Continue to route handler
} 

/*
  File: app/api/ai/generate/image/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/ai/generate/image/route.ts
  Directory: app/api/ai/generate/image
*/

--- File: app/api/ai/generate/image/route.ts ---

import { replicate } from '@ai-sdk/replicate';
import { experimental_generateImage as generateImage } from 'ai';
import { NextRequest } from 'next/server';
import { PutObjectCommand } from '@aws-sdk/client-s3';
import { s3Client, AWS_BUCKET_PUBLIC } from '@/lib/aws';
import { requireAuthMiddleware } from "../../_auth"

export async function POST(request: NextRequest) {
  // Check authentication
  const authError = await requireAuthMiddleware()
  if (authError) return authError

  try {
    const { input, userId, deckId, aspectRatio } = await request.json();
    const userFolder = userId || 'guest';

    // Check if placeholder images should be used
    if (process.env.NEXT_PUBLIC_USE_PLACEHOLDER_IMAGES === 'true') {
      return Response.json({
        imageUrl: 'https://placehold.co/600x900',
        success: true
      });
    }

    if (!s3Client) {
      return Response.json({ error: 'S3 client not initialized', success: false }, { status: 500 });
    }

    const { image } = await generateImage({
      model: replicate.image(process.env.REPLICATE_MODEL || "black-forest-labs/flux-schnell"),
      prompt: input,
      aspectRatio: aspectRatio || '1:1',
    });

    // Upload to S3
    const key = `decks/${userFolder}/${deckId}/${Date.now()}.webp`;
    await s3Client.send(
      new PutObjectCommand({
        Bucket: AWS_BUCKET_PUBLIC,
        Key: key,
        Body: image.uint8Array,
        ContentType: 'image/webp',
      })
    );

    // Return both the image and the S3 URL
    return Response.json({
      imageUrl: `https://${AWS_BUCKET_PUBLIC}.s3.${process.env.AWS_REGION || 'us-east-1'}.amazonaws.com/${key}`,
      success: true
    });
  } catch (error) {
    console.error('Error generating or uploading image:', error);
    return Response.json({ error: 'Failed to generate or upload image', success: false }, { status: 500 });
  }
}


/*
  File: app/api/ai/generate/object/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/ai/generate/object/route.ts
  Directory: app/api/ai/generate/object
*/

--- File: app/api/ai/generate/object/route.ts ---

import { streamObject } from "@/lib/ai/"
import { z } from "zod"
import { requireAuthMiddleware } from "../../_auth"

// Allow streaming responses up to 30 seconds
export const maxDuration = 30

// Helper function to get a readable schema description
// function describeSchema(schema: z.ZodTypeAny): any {
//   if (schema instanceof z.ZodObject) {
//     const shape: Record<string, any> = {}
//     for (const [key, value] of Object.entries(schema.shape)) {
//       shape[key] = describeSchema(value as z.ZodTypeAny)
//     }
//     return { type: "object", shape }
//   } else if (schema instanceof z.ZodArray) {
//     return { type: "array", items: describeSchema(schema.element) }
//   } else if (schema instanceof z.ZodString) {
//     return { type: "string" }
//   } else if (schema instanceof z.ZodNumber) {
//     return { type: "number" }
//   } else if (schema instanceof z.ZodBoolean) {
//     return { type: "boolean" }
//   }
//   return { type: "unknown" }
// }

// Define schema field type interface
interface SchemaField {
  type: "string" | "number" | "boolean" | "array" | "object"
  optional?: boolean
  items?: SchemaField
  properties?: Record<string, SchemaField>
}

// Define the schema for field definitions
const fieldSchema: z.ZodType<SchemaField> = z.object({
  type: z.enum(["string", "number", "boolean", "array", "object"]),
  optional: z.boolean().optional(),
  properties: z.record(z.lazy(() => fieldSchema)).optional(),
  items: z.lazy(() => fieldSchema).optional(),
})

// Define the schema for the request body
const requestSchema = z.object({
  schema: fieldSchema,
  prompt: z.string(),
})

function createZodSchema(shape: SchemaField | Record<string, SchemaField>): z.ZodTypeAny {
  // If it's a record of fields (root schema), create an object schema
  if (!("type" in shape)) {
    const schema: Record<string, z.ZodTypeAny> = {}
    for (const [key, def] of Object.entries(shape)) {
      schema[key] = createZodSchema(def)
    }
    return z.object(schema)
  }

  // Handle individual field schemas
  if (shape.type === "object" && shape.properties) {
    const schema: Record<string, z.ZodTypeAny> = {}
    for (const [key, def] of Object.entries(shape.properties)) {
      schema[key] = createZodSchema(def)
    }
    return z.object(schema)
  }

  let fieldSchema: z.ZodTypeAny

  switch (shape.type) {
    case "string":
      fieldSchema = z.string()
      break
    case "number":
      fieldSchema = z.number()
      break
    case "boolean":
      fieldSchema = z.boolean()
      break
    case "array":
      fieldSchema = z.array(shape.items ? createZodSchema(shape.items) : z.any())
      break
    default:
      fieldSchema = z.any()
  }

  if (shape.optional) {
    fieldSchema = fieldSchema.optional()
  }

  return fieldSchema
}

export async function POST(req: Request) {
  // Check authentication
  const authError = await requireAuthMiddleware()
  if (authError) return authError

  try {
    const body = await req.json()
    const { schema: schemaShape, prompt } = requestSchema.parse(body)

    // Create a new schema from the shape
    const schema = createZodSchema(schemaShape)
    
    const result = await streamObject({
      schema,
      prompt,
    })
    
    return result.toTextStreamResponse()
  } catch (error) {
    console.error("Error in generate object route:", error)
    return new Response(JSON.stringify({ error: "Invalid request" }), { status: 400 })
  }
}


/*
  File: app/api/ai/generate/strings/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/ai/generate/strings/route.ts
  Directory: app/api/ai/generate/strings
*/

--- File: app/api/ai/generate/strings/route.ts ---

import { streamObject } from "@/lib/ai/"
import { z } from "zod"
import { requireAuthMiddleware } from "../../_auth"

// Allow streaming responses up to 30 seconds
export const maxDuration = 30

export async function POST(req: Request) {
  // Check authentication
  const authError = await requireAuthMiddleware()
  if (authError) return authError

  try {
    const body = await req.json()
    const { prompt, count = 6 } = body

    const result = await streamObject({
      schema: z.object({
        strings: z.array(z.string()).describe("Array of generated strings based on the prompt"),
      }),
      prompt: `${prompt}\n\nGenerate exactly ${count} responses. Return them in a JSON object with a "strings" array property.`,
    })
    
    return result.toTextStreamResponse()
  } catch (error) {
    console.error("Error in generate strings route:", error)
    return new Response(JSON.stringify({ error: "Failed to generate strings" }), { status: 500 })
  }
}


/*
  File: app/api/ai/generate/text/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/ai/generate/text/route.ts
  Directory: app/api/ai/generate/text
*/

--- File: app/api/ai/generate/text/route.ts ---

import { generateText } from "@/lib/ai/"
import { NextRequest } from "next/server"
import { requireAuthMiddleware } from "../../_auth"

type Message = { content: string }

export async function POST(request: NextRequest) {
  // Check authentication
  const authError = await requireAuthMiddleware()
  if (authError) return authError

  const body = await request.json()

  const { input, messages, system } = body

  let prompt = input
  if (messages) {
    // If you want to support chat-style messages, concatenate them
    prompt = (messages as Message[]).map((m) => m.content).join("\n")
  }
  if (system) {
    prompt = `${system}\n${prompt}`
  }

  const result = await generateText({
    prompt,
  })

  // Return as JSON for backend use
  return Response.json({ result: result.text })
}


/*
  File: app/api/ai/get-encounter-context/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/ai/get-encounter-context/route.ts
  Directory: app/api/ai/get-encounter-context
*/

--- File: app/api/ai/get-encounter-context/route.ts ---

import { NextRequest, NextResponse } from "next/server";
import adventureData from "@/data/the-midnight-summons.json";

export async function POST(req: NextRequest) {
  const { encounterId } = await req.json();
  console.log("[get-encounter-context] Request for encounterId:", encounterId);
  // Traverse the adventure structure to find the encounter
  let found = null;
  for (const section of adventureData.sections) {
    for (const scene of section.scenes) {
      for (const encounter of scene.encounters) {
        if (encounter.id === encounterId) {
          found = encounter;
          break;
        }
      }
      if (found) break;
    }
    if (found) break;
  }
  if (!found) {
    console.log("[get-encounter-context] Encounter not found for id:", encounterId);
    return NextResponse.json({ error: "Not found" }, { status: 404 });
  }
  console.log("[get-encounter-context] Found encounter:", found.id);
  return NextResponse.json({
    intro: found.intro,
    instructions: found.instructions,
    transitions: found.transitions ?? [],
  });
} 

/*
  File: app/api/ai/get-roll-requirement/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/ai/get-roll-requirement/route.ts
  Directory: app/api/ai/get-roll-requirement
*/

--- File: app/api/ai/get-roll-requirement/route.ts ---

import { NextRequest } from "next/server";
import { getRollRequirement } from "@/app/_actions/get-roll-requirement";

export async function POST(req: NextRequest) {
  const { reply, character } = await req.json();
  const rollRequirement = await getRollRequirement(reply, character);
  return Response.json({ rollRequirement });
} 

/*
  File: app/api/check-admin/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/check-admin/route.ts
  Directory: app/api/check-admin
*/

--- File: app/api/check-admin/route.ts ---

import { NextResponse } from 'next/server';
import { auth } from '@clerk/nextjs/server';

export async function GET() {
  try {
    const { userId } = await auth();
    
    // If no user is authenticated, they're not an admin
    if (!userId) {
      return NextResponse.json({ isAdmin: false });
    }
    
    // Get the list of admin user IDs from environment variables
    const adminUserIds = process.env.ADMIN_USER_IDS?.split(",") || [];
    
    // Check if the current user's ID is in the admin list
    const isAdmin = adminUserIds.includes(userId);
    
    return NextResponse.json({ isAdmin });
  } catch (error) {
    console.error("Error checking admin status:", error);
    return NextResponse.json({ isAdmin: false }, { status: 500 });
  }
} 

/*
  File: app/api/convex-status/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/convex-status/route.ts
  Directory: app/api/convex-status
*/

--- File: app/api/convex-status/route.ts ---

import { NextResponse } from "next/server"

export async function GET() {
  try {
    // Check if Convex URL is configured
    const isConfigured = Boolean(process.env.NEXT_PUBLIC_CONVEX_URL)

    if (!isConfigured) {
      return NextResponse.json(
        {
          status: "not_configured",
          message: "Convex is not configured. Please set NEXT_PUBLIC_CONVEX_URL in your .env file.",
        },
        { status: 400 }
      )
    }

    return NextResponse.json(
      {
        status: "ready",
        message: "Convex is configured and ready to use.",
        url: process.env.NEXT_PUBLIC_CONVEX_URL,
      },
      { status: 200 }
    )
  } catch (error) {
    console.error("Error checking Convex status:", error)
    return NextResponse.json(
      {
        status: "error",
        message: "Failed to check Convex status",
        error: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    )
  }
} 

/*
  File: app/api/pay/intent/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/pay/intent/route.ts
  Directory: app/api/pay/intent
*/

--- File: app/api/pay/intent/route.ts ---

import { auth } from "@clerk/nextjs/server"
import { NextResponse } from "next/server"
import { stripe, isStripeConfigured } from "@/lib/stripe"

export async function POST(request: Request) {
  try {
    // Check if Stripe is configured
    if (!isStripeConfigured()) {
      return NextResponse.json(
        { error: "Payment system not configured" },
        { status: 503 }
      )
    }

    // Check authentication
    const authResult = await auth()
    if (!authResult.userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    const { amount } = await request.json()

    // We can safely use stripe here because we checked isStripeConfigured()
    const paymentIntent = await stripe!.paymentIntents.create({
      amount,
      currency: "usd",
      metadata: {
        userId: authResult.userId,
        type: "donation"
      }
    })

    return NextResponse.json({
      clientSecret: paymentIntent.client_secret,
    })
  } catch (error) {
    console.error("Error creating payment intent:", error)
    return NextResponse.json(
      { error: "Error creating payment intent" },
      { status: 500 }
    )
  }
} 

/*
  File: app/api/sendgrid/inbound/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/sendgrid/inbound/route.ts
  Directory: app/api/sendgrid/inbound
*/

--- File: app/api/sendgrid/inbound/route.ts ---

import { NextRequest, NextResponse } from "next/server"
import sgMail from "@sendgrid/mail"

export async function POST(request: NextRequest) {
  try {
    // Parse the multipart form data from SendGrid
    const formData = await request.formData()
    const from = formData.get("from") as string
    const subject = formData.get("subject") as string
    const text = formData.get("text") as string
    const html = formData.get("html") as string

    // Configure SendGrid
    sgMail.setApiKey(process.env.SENDGRID_API_KEY!)

    // Forward the email to the contact email
    const msg = {
      to: process.env.CONTACT_EMAIL!,
      from: process.env.SENDGRID_SENDER!,
      replyTo: from,
      subject: `[Forwarded] ${subject}`,
      text: `Original From: ${from}\n\n${text}`,
      html: `
        <p><strong>Original From:</strong> ${from}</p>
        <hr/>
        ${html}
      `,
    }

    await sgMail.send(msg)

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error("Error processing inbound email:", error)
    return NextResponse.json(
      { error: "Failed to process inbound email" },
      { status: 500 }
    )
  }
} 

/*
  File: app/api/upload/route.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/api/upload/route.ts
  Directory: app/api/upload
*/

--- File: app/api/upload/route.ts ---

import { NextRequest, NextResponse } from "next/server"
import { uploadFileToS3 } from "@/lib/s3-utils"
import { isAwsConfigured } from "@/lib/aws"
import { v4 as uuidv4 } from "uuid"
import { auth } from "@clerk/nextjs/server"
import { decrementUserTokensAction } from "@/app/_actions/tokens"
import { fetchUserTokenBalance } from "@/app/_actions/user-token-actions"

export async function POST(request: NextRequest) {
  try {
    // Check if AWS is configured
    if (!isAwsConfigured()) {
      return NextResponse.json(
        { error: "File upload system not configured" },
        { status: 503 }
      )
    }

    const IMAGE_UPLOAD_TOKEN_COST = 200;

    const { userId } = await auth()

    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    const formData = await request.formData()
    const file = formData.get("file") as File
    const folder = formData.get("folder") as string || "images"
    
    if (!file) {
      return NextResponse.json({ error: "No file provided" }, { status: 400 })
    }
    
    // Validate file type
    const allowedTypes = ["image/jpeg", "image/png", "image/webp", "image/gif", "image/svg+xml"]
    if (!allowedTypes.includes(file.type)) {
      return NextResponse.json({ error: "File type not allowed. Please upload an image (JPEG, PNG, WebP, SVG, or GIF)." }, { status: 400 })
    }
    
    // Validate file size (max 10MB)
    const maxSize = 10 * 1024 * 1024 // 10MB
    if (file.size > maxSize) {
      return NextResponse.json({ error: "File size exceeds 10MB limit" }, { status: 400 })
    }
    
    // Check if user has enough tokens for upload
    const tokenBalance = await fetchUserTokenBalance()
    
    // Handle authentication error
    if (tokenBalance.error === "USER_NOT_AUTHENTICATED") {
      return NextResponse.json({ error: "User authentication failed" }, { status: 401 })
    }
    
    // Handle other errors
    if (tokenBalance.error) {
      console.error("Failed to check token balance:", tokenBalance.error)
      return NextResponse.json({ 
        error: "Unable to verify token balance" 
      }, { status: 500 })
    }
    
    // Check token sufficiency
    if ((tokenBalance.tokensRemaining ?? 0) < IMAGE_UPLOAD_TOKEN_COST) {
      return NextResponse.json({ 
        error: `Insufficient tokens for image upload. ${IMAGE_UPLOAD_TOKEN_COST} tokens required.` 
      }, { status: 402 }) // Payment Required
    }
    
    // Generate a unique filename
    const fileExtension = file.name.split(".").pop()
    const fileName = `${folder}/${uuidv4()}.${fileExtension}`
    
    // Upload to S3
    const fileUrl = await uploadFileToS3(file, fileName)
    
    // Deduct tokens for the upload
    try {
      await decrementUserTokensAction({
        tokensUsed: IMAGE_UPLOAD_TOKEN_COST,
        transactionType: "usage_image_upload",
        description: `Image upload: ${file.name} (${Math.round(file.size / 1024)}KB)`
      })
    } catch (tokenError) {
      console.error("Failed to deduct tokens for image upload:", tokenError)
      // Continue with the upload even if token deduction fails - we don't want to break the upload
      // In a production system, you might want to handle this differently
    }
    
    return NextResponse.json({ url: fileUrl })
  } catch (error) {
    console.error("Error uploading file:", error)
    if (error instanceof Error && error.message === "AWS S3 is not configured") {
      return NextResponse.json(
        { error: "File upload system not configured" },
        { status: 503 }
      )
    }
    return NextResponse.json({ error: "Failed to upload file" }, { status: 500 })
  }
} 

/*
  File: app/contact/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/contact/page.tsx
  Directory: app/contact
*/

--- File: app/contact/page.tsx ---

import { Metadata } from "next"
import { ContactForm } from "@/components/contact/contact-form"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { ConfigCard } from "@/components/admin/config-card"
import { Heading } from "@/components/typography/heading"

export const metadata: Metadata = {
  title: "Contact Us",
  description: "Get in touch with us. We'd love to hear from you!",
}

async function checkEnvironmentVariables() {
  // Define required environment variables
  const requiredEnvVars = {
    NEXT_PUBLIC_RECAPTCHA_SITE_KEY: process.env.NEXT_PUBLIC_RECAPTCHA_SITE_KEY,
    RECAPTCHA_SECRET_KEY: process.env.RECAPTCHA_SECRET_KEY,
    SENDGRID_API_KEY: process.env.SENDGRID_API_KEY,
    SENDGRID_SENDER: process.env.SENDGRID_SENDER,
    CONTACT_EMAIL: process.env.CONTACT_EMAIL,
  } as const

  // Check which variables are missing
  const missingEnvVars = Object.entries(requiredEnvVars)
    .filter(([, value]) => !value)
    .map(([key]) => key)

  // Log missing variables in development
  if (process.env.NODE_ENV === "development" && missingEnvVars.length > 0) {
    console.warn("⚠️ Missing environment variables for contact form:")
    missingEnvVars.forEach((key) => {
      console.warn(`  - ${key}`)
    })
  }

  return {
    isConfigured: missingEnvVars.length === 0,
    missingVars: missingEnvVars,
  }
}

export default async function ContactPage() {
  const { isConfigured, missingVars } = await checkEnvironmentVariables()

  if (!isConfigured) {
    return (
      <div className="container max-w-2xl py-8 md:py-12">
        <ConfigCard
          title="Contact Form Setup Required"
          description="The contact form needs configuration before it can be used."
          configItems={[
            {
              key: "NEXT_PUBLIC_RECAPTCHA_SITE_KEY",
              description: "From Google ReCAPTCHA",
              isMissing: missingVars.includes("NEXT_PUBLIC_RECAPTCHA_SITE_KEY"),
            },
            {
              key: "RECAPTCHA_SECRET_KEY",
              description: "From Google ReCAPTCHA",
              isMissing: missingVars.includes("RECAPTCHA_SECRET_KEY"),
            },
            {
              key: "SENDGRID_API_KEY",
              description: "Your SendGrid API key",
              isMissing: missingVars.includes("SENDGRID_API_KEY"),
            },
            {
              key: "SENDGRID_SENDER",
              description: "Verified sender email in SendGrid",
              isMissing: missingVars.includes("SENDGRID_SENDER"),
            },
            {
              key: "CONTACT_EMAIL",
              description: "Where to receive contact messages",
              isMissing: missingVars.includes("CONTACT_EMAIL"),
            },
          ]}
          filesToRemove={[{ path: "app/contact/page.tsx" }, { path: "components/contact/contact-form.tsx" }, { path: "app/_actions/contact.ts" }]}
        />
      </div>
    )
  }

  return <ContactPageContent />
}

function ContactPageContent() {
  return (
    <div className="container max-w-2xl py-8 md:py-12">
      <Card>
        <CardHeader>
          <CardTitle>
            <Heading variant="h4">Contact Us</Heading>
          </CardTitle>
          <CardDescription>Have a question or want to get in touch? Fill out the form and we&apos;ll get back to you.</CardDescription>
        </CardHeader>
        <CardContent>
          <ContactForm requireCaptcha={true} />
        </CardContent>
      </Card>
      {process.env.NODE_ENV === "development" && (
        <div className="mt-8 text-sm text-muted-foreground">
          <p>
            Get your API keys from{" "}
            <a className="underline" href="http://www.google.com/recaptcha/admin" target="_blank" rel="noopener noreferrer">
              http://www.google.com/recaptcha/admin
            </a>
          </p>
        </div>
      )}
    </div>
  )
}


/*
  File: app/demo/ai/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/demo/ai/page.tsx
  Directory: app/demo/ai
*/

--- File: app/demo/ai/page.tsx ---

import { Heading } from "@/components/typography/heading"
import { ConfigCard } from "@/components/admin/config-card"
import { AIDemoClient } from "@/components/demo/ai-demo-client"
import { checkAuth } from "@/lib/auth-utils"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { SignInButton } from "@clerk/nextjs"
import { Button } from "@/components/ui/button"

export default async function AIDemo() {
  // Check authentication
  const { isAuthenticated } = await checkAuth()
  const hasAllEnvVars = true

  const isMissingReplicateToken = !process.env.REPLICATE_API_TOKEN

  return (
    <div className="container py-8 md:py-12">
      <div className="mx-auto flex max-w-[58rem] flex-col items-center space-y-4 text-center">
        <span className="inline-block rounded-full bg-primary/10 px-3 py-1 text-sm text-primary">AI SDK Integration</span>
        <Heading variant="h2" className="font-heading text-3xl leading-[1.1] sm:text-3xl md:text-6xl font-bold">
          AI <span className="text-primary">Demo</span>
        </Heading>
        <p className="max-w-[85%] leading-normal text-muted-foreground sm:text-lg sm:leading-7">Try out generating text, images and structured data with AI.</p>
      </div>

      <div className="mx-auto max-w-2xl mt-12">
        {!isAuthenticated ? (
          <Card>
            <CardHeader>
              <CardTitle>Sign in Required</CardTitle>
              <CardDescription>Please sign in to access the AI demo features.</CardDescription>
            </CardHeader>
            <CardContent className="flex justify-center">
              <SignInButton mode="modal">
                <Button size="lg">Sign in to Continue</Button>
              </SignInButton>
            </CardContent>
          </Card>
        ) : !hasAllEnvVars ? (
          <ConfigCard
            title="OpenAI Configuration Required"
            description="To enable AI text or structured data generation, you need to configure OpenAI API key."
            configItems={[]}
            filesToRemove={[
              { path: "api/ai/*", description: "AI API routes" },
              { path: "_hooks/*", description: "AI hooks" },
            ]}
            alternativeTitle="Remove AI Feature"
            alternativeDescription="If you don't plan to use AI features, you can remove these files:"
          />
        ) : (
          <AIDemoClient isMissingReplicateToken={isMissingReplicateToken} />
        )}
      </div>
    </div>
  )
}


/*
  File: app/demo/upload/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/demo/upload/page.tsx
  Directory: app/demo/upload
*/

--- File: app/demo/upload/page.tsx ---

import { Heading } from "@/components/typography/heading"
import { UploadDemoClient } from "@/components/demo/upload-demo-client"
import { ConfigCard } from "@/components/admin/config-card"

const requiredEnvVars = {
  AWS_KEY: "Your AWS access key ID for S3 access",
  AWS_SECRET: "Your AWS secret access key for S3 access",
  AWS_REGION: "The AWS region where your S3 bucket is located (e.g., us-east-1)",
  AWS_BUCKET_PUBLIC: "The name of your public S3 bucket for file uploads",
}

export default async function UploadDemo() {
  // Check for missing environment variables
  const missingEnvVars = Object.entries(requiredEnvVars).map(([key, description]) => ({
    key,
    description,
    isMissing: !process.env[key],
  }))

  const hasAllEnvVars = missingEnvVars.every((item) => !item.isMissing)

  return (
    <div className="container py-8 md:py-12">
      <div className="mx-auto flex max-w-[58rem] flex-col items-center space-y-4 text-center">
        <span className="inline-block rounded-full bg-primary/10 px-3 py-1 text-sm text-primary">Upload Demo</span>
        <Heading variant="h2" className="font-heading text-3xl leading-[1.1] sm:text-3xl md:text-6xl font-bold">
          File Upload <span className="text-primary">System</span>
        </Heading>
        <p className="max-w-[85%] leading-normal text-muted-foreground sm:text-lg sm:leading-7">Try out our drag-and-drop file upload system with AWS S3 integration and image optimization.</p>
      </div>

      <div className="mx-auto max-w-2xl mt-12">
        {!hasAllEnvVars ? (
          <ConfigCard
            title="AWS S3 Configuration Required"
            description="To enable file uploads, you need to configure AWS S3 credentials and settings."
            configItems={missingEnvVars}
            filesToRemove={[
              { path: "components/ui/image-upload.tsx", description: "Image upload component" },
              { path: "lib/s3-utils.ts", description: "S3 utility functions" },
            ]}
            alternativeTitle="Remove File Upload Feature"
            alternativeDescription="If you don't plan to use AWS S3 for file uploads, you can remove these files:"
          />
        ) : (
          <UploadDemoClient />
        )}
      </div>
    </div>
  )
}


/*
  File: app/globals.css
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/globals.css
  Directory: app
*/

--- File: app/globals.css ---

@import 'tailwindcss';
@plugin "@tailwindcss/typography";

@custom-variant dark (&:is(.dark *));

@theme {
  --color-border: hsl(var(--border));
  --color-input: hsl(var(--input));
  --color-ring: hsl(var(--ring));
  --color-background: hsl(var(--background));
  --color-foreground: hsl(var(--foreground));

  --color-primary: hsl(var(--primary));
  --color-primary-foreground: hsl(var(--primary-foreground));

  --color-secondary: hsl(var(--secondary));
  --color-secondary-foreground: hsl(var(--secondary-foreground));

  --color-destructive: hsl(var(--destructive));
  --color-destructive-foreground: hsl(var(--destructive-foreground));

  --color-muted: hsl(var(--muted));
  --color-muted-foreground: hsl(var(--muted-foreground));

  --color-accent: hsl(var(--accent));
  --color-accent-foreground: hsl(var(--accent-foreground));

  --color-popover: hsl(var(--popover));
  --color-popover-foreground: hsl(var(--popover-foreground));

  --color-card: hsl(var(--card));
  --color-card-foreground: hsl(var(--card-foreground));

  --color-sidebar: hsl(var(--sidebar));
  --color-sidebar-foreground: hsl(var(--sidebar-foreground));
  --color-sidebar-border: hsl(var(--sidebar-border));
  --color-sidebar-primary: hsl(var(--sidebar-primary));
  --color-sidebar-primary-foreground: hsl(var(--sidebar-primary-foreground));

  --radius-lg: var(--radius);
  --radius-md: calc(var(--radius) - 2px);
  --radius-sm: calc(var(--radius) - 4px);

  --animate-accordion-down: accordion-down 0.2s ease-out;
  --animate-accordion-up: accordion-up 0.2s ease-out;
  --animate-float: float 15s ease-in-out infinite;

  --font-body: ['var(--font-rethink-sans)'];
  --font-sans: ['var(--font-rethink-sans)'];
  --font-display: ['var(--font-display)'];
  --font-mono: ['var(--font-mono)'];
  --font-serif: ui-serif, Georgia, Cambria, "Times New Roman", Times, serif;

  --text-xxxs: 0.5rem;
  --text-xxs: 0.625rem;

  --color-primary-50: #CBC8E5;
  --color-primary-100: #BEBADE;
  --color-primary-200: #A49ED1;
  --color-primary-300: #8A83C4;
  --color-primary-400: #7067B7;
  --color-primary-500: #594FA6;
  --color-primary-600: #453D80;
  --color-primary-700: #302B5A;
  --color-primary-800: #1C1934;
  --color-primary-900: #07070E;
  --color-primary-950: #000000;

  @keyframes accordion-down {
    from {
      height: 0;
    }
    to {
      height: var(--radix-accordion-content-height);
    }
  }
  @keyframes accordion-up {
    from {
      height: var(--radix-accordion-content-height);
    }
    to {
      height: 0;
    }
  }
  @keyframes float {
    0%,
    100% {
      transform: translateY(0);
    }
    50% {
      transform: translateY(-20px);
    }
  }
}

@utility container {
  margin-inline: auto;
  padding-inline: 1rem;
  @media (width >= --theme(--breakpoint-sm)) {
    max-width: none;
  }
  @media (width >= 1400px) {
    max-width: 1400px;
  }
}

/*
  The default border color has changed to `currentColor` in Tailwind CSS v4,
  so we've added these compatibility styles to make sure everything still
  looks the same as it did with Tailwind CSS v3.

  If we ever want to remove these styles, we need to add an explicit border
  color utility to any element that depends on these defaults.
*/
@layer base {
  *,
  ::after,
  ::before,
  ::backdrop,
  ::file-selector-button {
    border-color: var(--color-gray-200, currentColor);
  }
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 240 10% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 240 10% 3.9%;
    --primary: 246 80% 60%;
    --primary-foreground: 0 0% 98%;
    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;
    --muted: 240 4.8% 95.9%;
    --muted-foreground: 240 3.8% 46.1%;
    --accent: 240 4.8% 95.9%;
    --accent-foreground: 240 5.9% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 5.9% 90%;
    --input: 240 5.9% 90%;
    --ring: 246 80% 60%;
    --radius: 0.5rem;
    --sidebar: 0 0% 100%;
    --sidebar-foreground: 240 10% 3.9%;
    --sidebar-border: 240 5.9% 90%;
    --sidebar-primary: 246 80% 60%;
    --sidebar-primary-foreground: 0 0% 98%;
  }

  .dark {
    --background: 240 10% 3.9%;
    --foreground: 0 0% 98%;
    --card: 240 10% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 240 10% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 246 100% 70%;
    --primary-foreground: 0 0% 98%;
    --secondary: 240 3.7% 15.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 240 3.7% 15.9%;
    --muted-foreground: 240 5% 64.9%;
    --accent: 240 3.7% 15.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 3.7% 15.9%;
    --input: 240 3.7% 15.9%;
    --ring: 246 80% 60%;
    --sidebar: 240 10% 3.9%;
    --sidebar-foreground: 0 0% 98%;
    --sidebar-border: 240 3.7% 15.9%;
    --sidebar-primary: 246 80% 60%;
    --sidebar-primary-foreground: 0 0% 98%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

html {
  font-size: 18px;
}

html,
body {
  overscroll-behavior: none;
}

div,
p,
textarea {
  text-wrap: pretty;
}

button {
  cursor: pointer;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }

  to {
    opacity: 1;
  }
}

@keyframes fadeOut {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
  }
}

.fade-in {
  @apply opacity-100 transition-opacity duration-1000 ease-in-out;
  @starting-style {
    opacity: 0;
  }
}


/*
  File: app/layout.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/layout.tsx
  Directory: app
*/

--- File: app/layout.tsx ---

import Link from "next/link"
import type { Metadata } from "next"
import { Rethink_Sans, Cinzel_Decorative, Syne_Mono } from "next/font/google"
import { ThemeProvider } from "@/components/layout/theme-provider"
import { cn } from "@/lib/utils"
import { Toaster } from "sonner"
import { headers } from "next/headers"
import { trackVisit } from "@/app/_actions/track-visit"
import { siteConfig } from "@/lib/config"
import "./globals.css"
import { Providers } from "./providers"
import Header from "@/components/layout/header"

const rethinkSans = Rethink_Sans({
  subsets: ["latin"],
  variable: "--font-rethink-sans",
})

const cinzel = Cinzel_Decorative({
  subsets: ["latin"],
  variable: "--font-display",
  display: "swap",
  weight: "400",
})

const syne = Syne_Mono({
  subsets: ["latin"],
  variable: "--font-mono",
  display: "swap",
  weight: "400",
})

export const metadata: Metadata = {
  title: siteConfig.title,
  description: siteConfig.description,
  icons: {
    icon: "/images/favicon.svg",
  },
  openGraph: {
    title: siteConfig.title,
    description: siteConfig.description,
    images: [
      {
        url: siteConfig.shareImage,
        width: 1200,
        height: 630,
        alt: `${siteConfig.title} screenshot`,
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: siteConfig.title,
    description: siteConfig.description,
    images: [siteConfig.shareImage],
  },
}

export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode
}>) {
  // Track the visit
  const headersList = await headers()
  const path = headersList.get("x-pathname") || "/"
  await trackVisit(path)

  const currentYear = new Date().getFullYear()

  return (
    <html lang="en" suppressHydrationWarning className={`${rethinkSans.variable} ${cinzel.variable} ${syne.variable}`}>
      <body className={cn("min-h-screen bg-black text-white font-serif antialiased")}>
        <Providers>
          <ThemeProvider attribute="class" defaultTheme="system" enableSystem disableTransitionOnChange>
            <div className="relative flex min-h-screen flex-col">
              <Header path={path} />
              <main className="flex-1">{children}</main>
              <footer className="border-t border-white/20 py-6">
                <div className="container px-4 md:px-6">
                  <div className="flex flex-col md:flex-row justify-between items-center gap-4 text-center md:text-left text-sm">
                    <p>
                      © {currentYear} {siteConfig.title}. All rights reserved.
                    </p>
                    <nav className="flex gap-4">
                      <Link href="/terms" className="hover:underline underline-offset-4">
                        Terms
                      </Link>
                      <Link href="/privacy" className="hover:underline underline-offset-4">
                        Privacy
                      </Link>
                      <Link href="#" className="hover:underline underline-offset-4">
                        Contact
                      </Link>
                    </nav>
                  </div>
                </div>
              </footer>
            </div>
            <Toaster position="top-center" />
          </ThemeProvider>
        </Providers>
      </body>
    </html>
  )
}


/*
  File: app/mailing-list/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/mailing-list/page.tsx
  Directory: app/mailing-list
*/

--- File: app/mailing-list/page.tsx ---

import { MailingListForm } from "@/components/forms/mailing-list-form"
import { Heading } from "@/components/typography/heading"
import { getSubscription, unsubscribe } from "@/app/_actions/mailing-list"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { ConfigCard } from "@/components/admin/config-card"

async function handleLeaveWaitlist() {
  "use server"
  const result = await getSubscription()
  const subscription = result.success ? result.data : null
  if (!subscription?.email) return
  await unsubscribe(subscription.email) // Internally, unsubscribe still correctly removes them
}

export default async function WaitlistPage() {
  // Check if required environment variables are configured
  const missingEnvVars = [
    {
      key: "SENDGRID_API_KEY",
      description: "Your SendGrid API key (for waitlist notifications)",
      isMissing: !process.env.SENDGRID_API_KEY,
    },
  ].filter((item) => item.isMissing)

  if (missingEnvVars.length > 0) {
    return (
      <div className="container max-w-2xl py-8 md:py-12">
        <ConfigCard title="Waitlist Setup Required" description="The waitlist feature needs configuration before it can be used for notifications." configItems={missingEnvVars} />
      </div>
    )
  }

  const result = await getSubscription()
  const subscription = result.success ? result.data : null

  return (
    <div className="container relative">
      <div className="mx-auto flex max-w-[980px] flex-col items-center gap-8 py-8 md:py-12">
        <Heading variant="h2" className="text-center leading-tight">
          {subscription ? (
            <>
              {subscription.unsubscribedAt ? (
                <>
                  You&apos;ve left the <span className="text-primary">Waitlist.</span>
                </>
              ) : (
                <>
                  You&apos;re on the <span className="text-primary">Waitlist!</span>
                </>
              )}
            </>
          ) : (
            <>
              Join the <span className="text-primary">Waitlist</span>
            </>
          )}
        </Heading>

        {subscription ? (
          <Card className="w-full max-w-[500px] p-4 md:p-8 md:mt-4">
            <CardHeader className="md:pt-4">
              <CardTitle>Waitlist Status</CardTitle>
            </CardHeader>
            <CardContent className="md:pb-4">
              {subscription.unsubscribedAt ? (
                <div className="space-y-4">
                  <p>You previously joined the waitlist with {subscription.email}, but have since left. You can rejoin below.</p>
                  <MailingListForm initialEmail={subscription.email} />
                </div>
              ) : (
                <div className="space-y-4">
                  <p>You&apos;re on the waitlist with {subscription.email}. We&apos;ll notify you when access is available!</p>
                  <form action={handleLeaveWaitlist}>
                    <Button variant="destructive" type="submit">
                      Leave Waitlist
                    </Button>
                  </form>
                </div>
              )}
            </CardContent>
          </Card>
        ) : (
          <MailingListForm />
        )}
      </div>
    </div>
  )
}


/*
  File: app/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/page.tsx
  Directory: app
*/

--- File: app/page.tsx ---

import { textShadowSpread } from "@/components/typography/styles"
import Image from "next/image"
import { Button } from "@/components/ui/button"
import Link from "next/link"

export default async function HomePage() {
  return (
    <div className="flex min-h-[max(100vh,100vw)] lg:min-h-screen flex-col relative">
      <h2 className="text-4xl sm:text-6xl font-display text-center w-full mt-20 sm:mt-36 fade-in delay-[2s] relative z-10" style={textShadowSpread}>
        <span className="block sm:inline">EXpeRienCe</span> <span className="inline-block scale-75 sm:scale-90 -mx-2 sm:mx-0">tHe</span> Thrill
      </h2>
      <div className="flex flex-col items-center justify-center absolute bottom-[6vh] sm:bottom-[10vh] w-full flex justify-center z-10">
        <h2 className="text-lg sm:text-2xl font-bold font-display text-center w-full fade-in delay-[2200ms] relative z-10" style={textShadowSpread}>
          Of tHe
        </h2>
        <h2 className="text-6xl sm:text-9xl font-display text-center w-full fade-in delay-[2400ms] relative z-10 -mt-1 sm:-mt-4 mb-2 sm:mb-0" style={textShadowSpread}>
          D20
        </h2>

        <Link className="fade-in delay-[2600ms]" href="/settings/realm-of-myr/play">
          <Button asChild variant="epic" size="lg" className="mt-2 relative z-10">
            Quick Start
          </Button>
        </Link>
      </div>
      <Image className="object-cover fade-in" fill={true} src="/images/app/backgrounds/d20-hero.png" alt="D20" />
    </div>
  )
}


/*
  File: app/pay/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/pay/page.tsx
  Directory: app/pay
*/

--- File: app/pay/page.tsx ---

"use client"

import { useState } from "react"
import { Card } from "@/components/ui/card"
import { Heading } from "@/components/typography/heading"
import { SignInButton, useUser } from "@clerk/nextjs"
import { Button } from "@/components/ui/button"
import { LogIn, Coffee } from "lucide-react"
import { StripePaymentForm } from "@/components/checkout/stripe-payment-form"

export default function DonatePage() {
  const { isSignedIn, isLoaded, user } = useUser()
  const [clientSecret, setClientSecret] = useState<string>("")
  const [isLoading, setIsLoading] = useState(false)
  const [showSuccess, setShowSuccess] = useState(false)

  const handleDonate = async () => {
    try {
      setIsLoading(true)
      const response = await fetch("/api/pay/intent", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          amount: 500, // $5.00
        }),
      })
      const data = await response.json()
      setClientSecret(data.clientSecret)
    } catch (error) {
      console.error("Error creating payment intent:", error)
    } finally {
      setIsLoading(false)
    }
  }

  const handleSuccess = () => {
    setShowSuccess(true)
    setClientSecret("")
  }

  if (!isLoaded) {
    return null
  }

  return (
    <div className="container py-8 md:py-12">
      <div className="mx-auto flex max-w-[58rem] flex-col items-center space-y-4 text-center">
        <span className="inline-block rounded-full bg-primary/10 px-3 py-1 text-sm text-primary">Support the Project</span>
        <Heading variant="h2" className="font-heading text-3xl leading-[1.1] sm:text-3xl md:text-6xl font-bold">
          Buy me a <span className="text-primary">Coffee</span>
        </Heading>
        <p className="max-w-[85%] leading-normal text-muted-foreground sm:text-lg sm:leading-7">If you find this project helpful, consider supporting its development with a small donation.</p>
      </div>

      <div className="mx-auto max-w-md mt-12">
        <Card className="p-6">
          {!isSignedIn ? (
            <div className="py-12 text-center space-y-4">
              <div className="flex justify-center mb-4">
                <div className="p-3 rounded-full bg-primary/10">
                  <LogIn className="w-6 h-6 text-primary" />
                </div>
              </div>
              <h3 className="text-lg font-medium">Sign in to Donate</h3>
              <p className="text-sm text-muted-foreground mb-6">You need to be signed in to make a donation.</p>
              <SignInButton mode="modal">
                <Button size="lg">Sign in to Continue</Button>
              </SignInButton>
            </div>
          ) : showSuccess ? (
            <div className="py-12 text-center space-y-4">
              <div className="flex justify-center mb-4">
                <div className="p-3 rounded-full bg-green-500/10">
                  <Coffee className="w-6 h-6 text-green-500" />
                </div>
              </div>
              <h3 className="text-lg font-medium">Thank You!</h3>
              <p className="text-sm text-muted-foreground text-balance">Your support is greatly appreciated. Thank you for your donation!</p>
            </div>
          ) : clientSecret ? (
            <div className="space-y-6">
              <StripePaymentForm clientSecret={clientSecret} quantity={1} userId={user.id} onSuccess={handleSuccess} discountCode="" />
            </div>
          ) : (
            <div className="space-y-6">
              <div className="flex justify-center mb-8">
                <div className="p-4 rounded-full bg-primary/10">
                  <Coffee className="w-8 h-8 text-primary" />
                </div>
              </div>
              <div className="text-center space-y-2 mb-6">
                <h3 className="text-lg font-medium">Buy me a coffee</h3>
                <p className="text-sm text-muted-foreground">Support this project with a $5 donation</p>
              </div>
              <Button onClick={handleDonate} disabled={isLoading} className="w-full" size="lg">
                {isLoading ? "Loading..." : "Donate $5"}
              </Button>
            </div>
          )}
        </Card>
      </div>
    </div>
  )
}


/*
  File: app/privacy/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/privacy/page.tsx
  Directory: app/privacy
*/

--- File: app/privacy/page.tsx ---

import { Heading } from "@/components/typography/heading"

export default function PrivacyPage() {
  return (
    <div className="container py-12">
      <div className="mx-auto max-w-4xl">
        <div className="mb-12 text-center">
          <Heading variant="h1" className="mb-8">
            Privacy Policy
          </Heading>
        </div>

        <p className="text-gray-700 mb-6">Put your privacy policy here.</p>
      </div>
    </div>
  )
}


/*
  File: app/providers.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/providers.tsx
  Directory: app
*/

--- File: app/providers.tsx ---

"use client"

import { ClerkProvider } from "@clerk/nextjs"
import { ConvexProvider, ConvexReactClient } from "convex/react"
import { PropsWithChildren } from "react"
import { dark } from "@clerk/themes"
import { TokenProvider } from "@/lib/context/TokenContext"

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!)

export function Providers({ children }: PropsWithChildren) {
  return (
    <ClerkProvider
      appearance={{
        baseTheme: dark,
        variables: {
          fontFamily: "var(--font-rethink-sans)",
          colorBackground: "#1C1934",
        },
      }}
      afterSignOutUrl="/"
    >
      <ConvexProvider client={convex}>
        <TokenProvider>{children}</TokenProvider>
      </ConvexProvider>
    </ClerkProvider>
  )
}


/*
  File: app/roadmap/data/featureRequests.json
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/roadmap/data/featureRequests.json
  Directory: app/roadmap/data
*/

--- File: app/roadmap/data/featureRequests.json ---

[]


/*
  File: app/roadmap/data/features.json
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/roadmap/data/features.json
  Directory: app/roadmap/data
*/

--- File: app/roadmap/data/features.json ---

[
  {
    "id": "1",
    "title": "Feature Roadmap",
    "votes": 42,
    "status": "completed",
    "description": "Add a feature roadmap page"
  },
  {
    "id": "3",
    "title": "API integration",
    "votes": 28,
    "status": "planned",
    "description": "Support for third-party API integrations"
  },
  {
    "id": "4",
    "title": "User authentication",
    "votes": 24,
    "status": "completed",
    "description": "Secure login and authentication system"
  },
  {
    "id": "5",
    "title": "Better analytics",
    "votes": 18,
    "status": "planned",
    "description": "Improve the analytics dashboard to provide more insights"
  },
  {
    "id": "6",
    "title": "Mailing List",
    "votes": 15,
    "status": "completed",
    "description": "Allow users to create and manage mailing lists"
  },
  {
    "id": "7",
    "title": "Switch to Convex",
    "votes": 32,
    "status": "completed",
    "description": "Switch to Convex for better DX and support for more projects on the free tier"
  },
  {
    "id": "8",
    "title": "Realtime updates",
    "votes": 19,
    "status": "backlog",
    "description": "Integrate with realtime service"
  },
  {
    "id": "9",
    "title": "Custom themes",
    "votes": 22,
    "status": "backlog",
    "description": "Allow users to more easily customize the application theme"
  },
  {
    "id": "10",
    "title": "Better documentation",
    "votes": 12,
    "status": "in-progress",
    "description": "Improve the documentation getting started quickly on new projects"
  }
]


/*
  File: app/roadmap/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/roadmap/page.tsx
  Directory: app/roadmap
*/

--- File: app/roadmap/page.tsx ---

import { RoadmapView, type Feature, type FeatureRequest } from "@/components/admin/roadmap-view"
import initialFeatures from "./data/features.json"
import initialRequests from "./data/featureRequests.json"

export default function RoadmapPage() {
  const features = initialFeatures as Feature[]
  const featureRequests = initialRequests as FeatureRequest[]

  return <RoadmapView features={features} featureRequests={featureRequests} />
}


/*
  File: app/settings/[settingId]/[adventurePlanId]/[adventureId]/[turnOrder]/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/settings/[settingId]/[adventurePlanId]/[adventureId]/[turnOrder]/page.tsx
  Directory: app/settings/[settingId]/[adventurePlanId]/[adventureId]/[turnOrder]
*/

--- File: app/settings/[settingId]/[adventurePlanId]/[adventureId]/[turnOrder]/page.tsx ---

import { notFound } from "next/navigation"
import type { Metadata } from "next"
import AdventureHome from "@/components/views/adventure-home"
import { loadAdventureWithTurnByOrder, getTurnNavigationInfo } from "@/app/_actions/load-adventure"
import type { Id } from "@/convex/_generated/dataModel"
import type { Adventure } from "@/types/adventure"
import { mapConvexTurnToTurn } from "@/lib/utils"
import { AdventurePlan } from "@/types/adventure-plan"
import TurnNavigation from "@/components/adventure/turn-navigation"
import { reverseSlugify } from "@/lib/utils"
import { isDev } from "@/lib/auth-utils"
import Link from "next/link"
import { Button } from "@/components/ui/button"

export const dynamic = "force-dynamic"

// Helper to map Convex adventure to frontend Adventure type
function mapConvexAdventureToAdventure(raw: unknown): Adventure | null {
  if (!raw || typeof raw !== "object" || !("_id" in raw)) return null
  const a = raw as { _id: string; title: string; planId: string; startedAt: number; endedAt?: number; settingId?: string }
  return {
    id: a._id,
    title: a.title,
    adventurePlanId: a.planId,
    settingId: a.settingId ?? "",
    party: [],
    turns: [],
    startedAt: a.startedAt ? new Date(a.startedAt).toISOString() : "",
    endedAt: a.endedAt ? new Date(a.endedAt).toISOString() : undefined,
    pausedAt: undefined,
  }
}

interface PageProps {
  params: Promise<{
    settingId: string
    adventurePlanId: string
    adventureId: string
    turnOrder: string
  }>
}

export async function generateMetadata({ params }: PageProps): Promise<Metadata> {
  const { adventurePlanId } = await params
  return {
    title: `D20 Adventures | ${reverseSlugify(adventurePlanId)}`,
  }
}

function findEncounter(adventurePlan: AdventurePlan, encounterIdToFind: string | undefined) {
  if (!encounterIdToFind) return null
  for (const section of adventurePlan.sections) {
    for (const scene of section.scenes) {
      for (const encounter of scene.encounters) {
        if (encounter.id === encounterIdToFind) {
          return encounter
        }
      }
    }
  }
  return null
}

export default async function TurnPage({ params }: PageProps) {
  const { adventurePlanId, adventureId, settingId, turnOrder } = await params

  // Parse turn order as number
  const turnOrderNum = parseInt(turnOrder, 10)
  if (isNaN(turnOrderNum) || turnOrderNum < 1) {
    return notFound()
  }

  // Load adventure plan
  let adventurePlan = null
  try {
    adventurePlan = (await import(`@/data/${adventurePlanId}.json`)).default
  } catch {
    return notFound()
  }
  if (!adventurePlan) return notFound()

  // Use 1-based URL parameter directly since database stores 1-based order values
  const turnOrderForDb = turnOrderNum

  // Load adventure and specific turn + navigation info in parallel
  const [adventureData, navInfo] = await Promise.all([loadAdventureWithTurnByOrder(adventureId as Id<"adventures">, turnOrderForDb), getTurnNavigationInfo(adventureId as Id<"adventures">)])

  const adventure = mapConvexAdventureToAdventure(adventureData?.adventure)
  const currentTurn = mapConvexTurnToTurn(adventureData?.currentTurn)

  if (!adventure) return notFound()
  if (!currentTurn) return notFound()

  const encounter = findEncounter(adventurePlan, currentTurn?.encounterId)
  const isLatestTurn = turnOrderNum === (navInfo?.totalTurns ?? 0)

  const canEdit = isDev()

  return (
    <div className="min-h-screen relative">
      <div className="max-w-6xl mx-auto p-4 absolute top-12 right-0 z-10">
        <TurnNavigation currentTurnOrder={turnOrderNum} totalTurns={navInfo?.totalTurns || 1} isLatestTurn={isLatestTurn} />
      </div>
      <AdventureHome
        settingId={settingId}
        adventurePlanId={adventurePlanId}
        adventure={adventure}
        encounterImage={encounter?.image || adventurePlan.image}
        currentTurn={currentTurn}
        disableSSE={!isLatestTurn}
      />
      {canEdit && (
        <Link className="fixed top-[90vh] right-8 z-10" href={`/settings/${settingId}/${adventurePlanId}/edit`}>
          <Button className="text-sm bg-primary-600 hover:bg-primary-700">Edit</Button>
        </Link>
      )}
    </div>
  )
}


/*
  File: app/settings/[settingId]/[adventurePlanId]/[adventureId]/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/settings/[settingId]/[adventurePlanId]/[adventureId]/page.tsx
  Directory: app/settings/[settingId]/[adventurePlanId]/[adventureId]
*/

--- File: app/settings/[settingId]/[adventurePlanId]/[adventureId]/page.tsx ---

import { notFound, redirect } from "next/navigation"
import type { Metadata } from "next"
import AdventureHome from "@/components/views/adventure-home"
import { loadAdventureWithNpc } from "@/app/_actions/load-adventure"
import type { Id } from "@/convex/_generated/dataModel"
import type { Adventure } from "@/types/adventure"
import type { PC } from "@/types/character"
import { mapConvexTurnToTurn, reverseSlugify } from "@/lib/utils"
import { AdventurePlan } from "@/types/adventure-plan"
import { readJsonFromS3 } from "@/lib/s3-utils"

// Helper to map Convex adventure to frontend Adventure type
function mapConvexAdventureToAdventure(raw: unknown, adventurePlan: AdventurePlan): Adventure | null {
  if (!raw || typeof raw !== "object" || !("_id" in raw)) return null
  const a = raw as {
    _id: string
    title: string
    planId: string
    startedAt: number
    endedAt?: number
    settingId?: string
    status?: "waitingForPlayers" | "active" | "completed"
    players?: Array<{ userId: string; characterId: string }>
    playerIds?: string[]
  }

  // Map players to full PC objects from adventure plan
  const party: PC[] =
    a.players
      ?.map((player) => {
        const character = adventurePlan.premadePlayerCharacters.find((pc) => pc.id === player.characterId)
        if (character) {
          return {
            ...character,
            userId: player.userId, // Add userId to the character
          } as PC
        }
        return null
      })
      .filter((char): char is PC => char !== null) || []

  return {
    id: a._id,
    title: a.title,
    adventurePlanId: a.planId,
    settingId: a.settingId ?? "",
    status: a.status || "active", // Default to active for backwards compatibility
    party,
    turns: [],
    startedAt: a.startedAt ? new Date(a.startedAt).toISOString() : "",
    endedAt: a.endedAt ? new Date(a.endedAt).toISOString() : undefined,
    pausedAt: undefined,
  }
}

export async function generateMetadata({ params }: { params: Promise<{ settingId: string; adventurePlanId: string; adventureId: string }> }): Promise<Metadata> {
  const { adventurePlanId } = await params
  return {
    title: `D20 Adventures | ${reverseSlugify(adventurePlanId)}`,
  }
}

function findEncounter(adventurePlan: AdventurePlan, encounterIdToFind: string | undefined) {
  if (!encounterIdToFind) return null
  for (const section of adventurePlan.sections) {
    for (const scene of section.scenes) {
      for (const encounter of scene.encounters) {
        if (encounter.id === encounterIdToFind) {
          return encounter
        }
      }
    }
  }
  return null
}

export default async function AdventurePage(props: { params: Promise<{ settingId: string; adventurePlanId: string; adventureId: string }> }) {
  const { adventurePlanId, adventureId, settingId } = await props.params
  const adventurePlan = (await readJsonFromS3(`settings/${settingId}/${adventurePlanId}.json`)) as AdventurePlan
  if (!adventurePlan) return notFound()
  const adventureData = await loadAdventureWithNpc(adventureId as Id<"adventures">)
  const adventure = mapConvexAdventureToAdventure(adventureData?.adventure, adventurePlan)
  const currentTurn = mapConvexTurnToTurn(adventureData?.currentTurn)

  if (!adventure) return notFound()

  // If there's a current turn, redirect to the turn-specific URL
  if (currentTurn) {
    const turnOrder = (adventureData?.currentTurn as { order?: number })?.order
    if (turnOrder) {
      redirect(`/settings/${settingId}/${adventurePlanId}/${adventureId}/${turnOrder}`)
    }
  }

  const encounter = findEncounter(adventurePlan, currentTurn?.encounterId)

  return (
    <AdventureHome
      settingId={settingId}
      adventurePlanId={adventurePlanId}
      adventure={adventure}
      encounterImage={encounter?.image || adventurePlan.image}
      currentTurn={currentTurn}
      adventurePlan={adventurePlan}
    />
  )
}


/*
  File: app/settings/[settingId]/[adventurePlanId]/character-selection/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/settings/[settingId]/[adventurePlanId]/character-selection/page.tsx
  Directory: app/settings/[settingId]/[adventurePlanId]/character-selection
*/

--- File: app/settings/[settingId]/[adventurePlanId]/character-selection/page.tsx ---

import { readJsonFromS3 } from "@/lib/s3-utils"
import type { AdventurePlan } from "@/types/adventure-plan"
import CharacterSelection from "@/components/adventure/character-selection"
import { isDev } from "@/lib/auth-utils"
import { Button } from "@/components/ui/button"
import Link from "next/link"

export default async function CharacterSelectionPage(props: { params: Promise<{ settingId: string; adventurePlanId: string }> }) {
  const { settingId, adventurePlanId } = await props.params
  const key = `settings/${settingId}/${adventurePlanId}.json`
  let adventurePlan: AdventurePlan | null = null

  try {
    adventurePlan = (await readJsonFromS3(key)) as AdventurePlan
  } catch (err) {
    console.error("Error fetching JSON from S3:", err)
    return <div>Error loading adventure data.</div>
  }

  const canEdit = isDev()

  return (
    <div className="flex min-h-screen flex-col relative">
      <CharacterSelection adventurePlan={adventurePlan} settingId={settingId} adventurePlanId={adventurePlanId} />
      {canEdit && (
        <Link className="fixed top-[90vh] right-8 z-10" href={`/settings/${settingId}/${adventurePlanId}/edit`}>
          <Button className="text-sm bg-primary-600 hover:bg-primary-700">Edit</Button>
        </Link>
      )}
    </div>
  )
}


/*
  File: app/settings/[settingId]/[adventurePlanId]/edit/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/settings/[settingId]/[adventurePlanId]/edit/page.tsx
  Directory: app/settings/[settingId]/[adventurePlanId]/edit
*/

--- File: app/settings/[settingId]/[adventurePlanId]/edit/page.tsx ---

import { auth } from "@clerk/nextjs/server"
import { SignInButton } from "@clerk/nextjs"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card"
import { readJsonFromS3 } from "@/lib/s3-utils"
import type { AdventurePlan } from "@/types/adventure-plan"
import { AdventurePlanEditForm } from "@/components/adventure-plans/adventure-plan-edit-form"
import { getAssetUrl } from "@/lib/aws"

export default async function AdventurePlanEditPage(props: { params: Promise<{ settingId: string; adventurePlanId: string }> }) {
  const { userId } = await auth()

  if (!userId) {
    return (
      <div className="flex min-h-screen flex-col items-center justify-center p-8 md:p-16">
        <Card className="w-full max-w-md bg-primary-800 border-primary-700 border-2 py-8">
          <CardHeader className="text-center">
            <CardTitle className="text-2xl font-display text-white">Sign In Required</CardTitle>
            <CardDescription className="text-white/70">You need to be signed in to edit an adventure plan.</CardDescription>
          </CardHeader>
          <CardContent className="flex flex-col items-center gap-4">
            <SignInButton mode="modal">
              <Button variant="epic" size="sm">
                Sign In
              </Button>
            </SignInButton>
          </CardContent>
        </Card>
      </div>
    )
  }

  const { settingId, adventurePlanId } = await props.params
  const key = `settings/${settingId}/${adventurePlanId}.json`
  let adventurePlan: AdventurePlan | null = null
  try {
    adventurePlan = (await readJsonFromS3(key)) as AdventurePlan
    if (adventurePlan) {
      // Resolve main adventure plan image
      if (adventurePlan.image && !adventurePlan.image.startsWith("http")) {
        adventurePlan.image = getAssetUrl(adventurePlan.image) || adventurePlan.image
        console.log("AdventurePlanEditPage: Resolved main image URL on server:", adventurePlan.image)
      }

      // Resolve encounter images
      if (adventurePlan.sections) {
        for (const section of adventurePlan.sections) {
          if (section.scenes) {
            for (const scene of section.scenes) {
              if (scene.encounters) {
                for (const encounter of scene.encounters) {
                  if (encounter.image && !encounter.image.startsWith("http")) {
                    encounter.image = getAssetUrl(encounter.image) || encounter.image
                    console.log(`AdventurePlanEditPage: Resolved encounter image URL for ${encounter.id || "unknown encounter"}:`, encounter.image)
                  }
                }
              }
            }
          }
        }
      }
    }
  } catch (err) {
    console.error("Error fetching JSON from S3 or resolving image URLs:", err)
    // adventurePlan will remain null or partially processed
  }

  if (!adventurePlan) {
    return (
      <div className="flex min-h-screen flex-col items-center justify-center p-16">
        <div className="text-2xl font-bold py-8 text-red-500">Error Loading Adventure Data</div>
        <p>Could not load the adventure plan. Please check the console for more details or try again later.</p>
      </div>
    )
  }

  return (
    <div className="flex min-h-screen flex-col relative p-8 md:p-16 max-w-7xl mx-auto">
      <AdventurePlanEditForm adventurePlan={adventurePlan} />
    </div>
  )
}


/*
  File: app/settings/[settingId]/[adventurePlanId]/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/settings/[settingId]/[adventurePlanId]/page.tsx
  Directory: app/settings/[settingId]/[adventurePlanId]
*/

--- File: app/settings/[settingId]/[adventurePlanId]/page.tsx ---

import { readJsonFromS3 } from "@/lib/s3-utils"
import AdventureHome from "@/components/views/adventure-home"
import type { AdventurePlan } from "@/types/adventure-plan"
import { TurnCharacter } from "@/types/adventure"
import { redirect } from "next/navigation"

export default async function AdventureHomePage(props: { params: Promise<{ settingId: string; adventurePlanId: string }>; searchParams?: Promise<{ selectedCharacter?: string }> }) {
  const { settingId, adventurePlanId } = await props.params
  const searchParams = await props.searchParams
  const selectedCharacterId = searchParams?.selectedCharacter
  const key = `settings/${settingId}/${adventurePlanId}.json`
  let adventurePlan: AdventurePlan | null = null
  try {
    adventurePlan = (await readJsonFromS3(key)) as AdventurePlan
  } catch (err) {
    console.error("Error fetching JSON from S3:", err)
    return <div>Error loading adventure data.</div>
  }

  // Check if we have multiple premade characters and no selection - redirect to character selection
  if (adventurePlan.premadePlayerCharacters.length > 1 && !selectedCharacterId) {
    redirect(`/settings/${settingId}/${adventurePlanId}/character-selection`)
  }

  // Find the selected character or use the first one
  const selectedCharacter = selectedCharacterId ? adventurePlan.premadePlayerCharacters.find((char) => char.id === selectedCharacterId) : adventurePlan.premadePlayerCharacters[0]

  // If we only have one character or none, proceed with demo setup
  const demoAdventure = {
    id: "demo-adventure",
    title: adventurePlan.title,
    adventurePlanId: adventurePlan.id,
    settingId: settingId,
    party: [],
    turns: [],
    startedAt: new Date().toISOString(),
  }

  const demoTurn = {
    id: "demo-turn",
    adventureId: "demo-adventure",
    encounterId: adventurePlan.sections[0].scenes[0].encounters[0].id,
    title: adventurePlan.sections[0].scenes[0].encounters[0].title,
    subtitle: adventurePlan.sections[0].scenes[0].encounters[0].title,
    narrative: adventurePlan.sections[0].scenes[0].encounters[0].intro,
    characters: selectedCharacter
      ? [
          {
            ...selectedCharacter,
            initiative: 10,
          } as TurnCharacter,
        ]
      : [],
  }

  return (
    <div className="flex min-h-screen flex-col relative">
      <AdventureHome adventure={demoAdventure} adventurePlanId={adventurePlanId} settingId={settingId} encounterImage={adventurePlan.image} currentTurn={demoTurn} />
    </div>
  )
}


/*
  File: app/settings/[settingId]/edit/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/settings/[settingId]/edit/page.tsx
  Directory: app/settings/[settingId]/edit
*/

--- File: app/settings/[settingId]/edit/page.tsx ---

import { readJsonFromS3 } from "@/lib/s3-utils"
import { Setting } from "@/types/setting"
import { SettingEditForm } from "@/components/settings/setting-edit-form"

export default async function SettingEditPage(props: { params: Promise<{ settingId: string }> }) {
  const { settingId } = await props.params
  console.log("[SettingEditPage] Loading setting edit page for ID:", settingId)

  const key = `settings/${settingId}/setting-data.json`
  console.log("[SettingEditPage] Loading setting from S3 key:", key)

  let setting: Setting | null = null
  try {
    setting = (await readJsonFromS3(key)) as Setting
    console.log("[SettingEditPage] Successfully loaded setting:", {
      name: setting.name,
      hasLocations: setting.locations?.length > 0,
      settingKeys: Object.keys(setting),
    })
  } catch (err) {
    console.error("[SettingEditPage] Error fetching JSON from S3:", err)
    return <div>Error loading setting data.</div>
  }

  if (!setting) {
    console.error("[SettingEditPage] Setting is null after loading")
    return <div>Setting data is empty.</div>
  }

  console.log("[SettingEditPage] Rendering SettingEditForm component")
  return (
    <div className="flex flex-col relative bg-gray-900 text-white mt-4">
      <SettingEditForm setting={setting} settingId={settingId} />
    </div>
  )
}


/*
  File: app/settings/[settingId]/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/settings/[settingId]/page.tsx
  Directory: app/settings/[settingId]
*/

--- File: app/settings/[settingId]/page.tsx ---

import { readJsonFromS3 } from "@/lib/s3-utils"
import { Setting } from "@/types/setting"
import ImageHeader from "@/components/ui/image-header"
import { Button } from "@/components/ui/button"
import { isDev } from "@/lib/auth-utils"
import Link from "next/link"
import { getImageUrl } from "@/lib/utils"

export default async function SettingHome(props: { params: Promise<{ settingId: string }> }) {
  const { settingId } = await props.params

  const key = `settings/${settingId}/setting-data.json`

  let setting: Setting | null = null
  try {
    setting = (await readJsonFromS3(key)) as Setting
  } catch (err) {
    console.error("Error fetching JSON from S3:", err)
    return <div>Error loading setting data.</div>
  }

  const canEdit = isDev()

  console.log("[SettingHome] canEdit:", canEdit)

  return (
    <div className="flex min-h-screen flex-col relative">
      <div className="fade-in delay-[2s] relative z-10">
        <ImageHeader variant="semicompact" imageUrl={getImageUrl(setting.image)} title={setting.name} imageAlt={setting.name} />
        {canEdit && (
          <Link className="fixed top-[90vh] right-8 z-10" href={`/settings/${settingId}/edit`}>
            <Button className="text-sm bg-primary-600 hover:bg-primary-700">Edit</Button>
          </Link>
        )}
        <div className="max-w-3xl mx-auto -mt-32 relative z-10 whitespace-pre-line">
          <div className="flex justify-center mb-8">
            <Link href={`/settings/${settingId}/play`}>
              <Button asChild variant="epic">
                Go to Adventures
              </Button>
            </Link>
          </div>
          <p>{setting.description}</p>
          {setting.technology && (
            <>
              <h4 className="text-xl font-display font-bold text-primary-200 mt-6 mb-1">Technology</h4>
              <p>{setting.technology}</p>
            </>
          )}
          {setting.magic && (
            <>
              <h4 className="text-xl font-display font-bold text-primary-200 mt-6 mb-1">Magic</h4>
              <p>{setting.magic}</p>
            </>
          )}
        </div>
        <div id="locations" className="pb-16">
          {setting.locations.map((location, index) => (
            <div key={index} className="w-full relative">
              <div className="flex flex-col pt-16">
                <h4 className="text-xl font-display font-bold text-primary-200">{location.name}</h4>

                <ImageHeader topBorder variant="semicompact" imageUrl={getImageUrl(location.image)} title={location.name} imageAlt={location.name} />

                <div className="max-w-3xl mx-auto -mt-32 relative z-10 whitespace-pre-line">
                  <div className="whitespace-pre-line">
                    <p>{location.description}</p>
                  </div>

                  {location.history && (
                    <>
                      <h5 className="text-lg font-display font-bold text-primary-200 mt-4 mb-1">History</h5>
                      <div className="whitespace-pre-line">
                        <p>{location.history}</p>
                      </div>
                    </>
                  )}

                  {location.inhabitants && (
                    <>
                      <h5 className="text-lg font-display font-bold text-primary-200 mt-4 mb-1">Inhabitants</h5>
                      <div className="whitespace-pre-line">
                        <p>{location.inhabitants}</p>
                      </div>
                    </>
                  )}
                </div>

                {location.organizations.map((org) => (
                  <div key={org.name} className="relative mt-16">
                    <ImageHeader topBorder variant="semicompact" imageUrl={getImageUrl(org.image)} title={org.name} imageAlt={org.name} />
                    <div className="max-w-3xl mx-auto -mt-32 relative z-10 whitespace-pre-line">
                      <p>{org.description}</p>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  )
}


/*
  File: app/settings/[settingId]/play/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/settings/[settingId]/play/page.tsx
  Directory: app/settings/[settingId]/play
*/

--- File: app/settings/[settingId]/play/page.tsx ---

import { readJsonFromS3, listAndReadJsonFilesInS3Directory } from "@/lib/s3-utils"
import { Setting } from "@/types/setting"
import ImageHeader from "@/components/ui/image-header"
import { Button } from "@/components/ui/button"
import { Card, CardContent } from "@/components/ui/card"
import Link from "next/link"
import { AdventurePlan } from "@/types/adventure-plan"
import Image from "next/image"
import { textShadow } from "@/components/typography/styles"
import { getImageUrl } from "@/lib/utils"
// @ts-expect-error: no types for number-to-words
import { toWords } from "number-to-words"

export default async function SettingAdventures(props: { params: Promise<{ settingId: string }> }) {
  const { settingId } = await props.params

  const key = `settings/${settingId}/setting-data.json`

  let setting: Setting | null = null
  try {
    setting = (await readJsonFromS3(key)) as Setting
  } catch (err) {
    console.error("Error fetching JSON from S3:", err)
    return <div>Error loading setting data.</div>
  }

  // Read all adventure plan JSON files (excluding setting-data.json)
  let adventures: AdventurePlan[] = []
  try {
    const adventureFiles = await listAndReadJsonFilesInS3Directory(`settings/${settingId}/`, ["setting-data.json"])
    adventures = adventureFiles.map((file) => file.data as AdventurePlan)
    console.log("Adventure files found:", JSON.stringify({ adventures: adventureFiles }, null, 2))
  } catch (err) {
    console.error("Error fetching adventure files from S3:", err)
  }

  return (
    <div className="flex min-h-screen flex-col relative">
      <div className="fade-in delay-[2s] relative z-10">
        <ImageHeader variant="compact" imageUrl={getImageUrl(setting.image)} title={setting.name} subtitle="Adventures" imageAlt={setting.name} />
        <div className="max-w-4xl mx-auto -mt-32 relative z-10 whitespace-pre-line">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-8 relative z-10 py-8 auto-rows-fr">
            {adventures.map((adventure) => (
              <Link key={adventure.id} href={`/settings/${settingId}/${adventure.id}`} className="block h-full">
                <Card className="w-full h-full bg-black/80 border-white/20 scale-95 hover:scale-100 hover:bg-black/90 ring-[6px] ring-black hover:ring-8 hover:ring-primary-500 transition-colors cursor-pointer transition-all duration-500 ease-in-out p-0 overflow-hidden flex flex-col">
                  <div className="pb-2 relative aspect-video w-full">
                    <div className="absolute top-1 right-3 z-10">
                      <span className="bg-black/80 text-white text-xxs font-mono px-2 py-1 rounded">
                        {adventure.party[0] === 1 && adventure.party[1] === 1
                          ? "Single Player"
                          : adventure.party[0] === 2 && adventure.party[1] === 2
                            ? `${toWords(2)[0].toUpperCase() + toWords(2).slice(1)} Players`
                            : `${adventure.party[0]}-${adventure.party[1]} Players`}
                      </span>
                    </div>
                    <div style={textShadow} className="absolute bottom-2 left-0 right-0 text-white w-full text-center font-display text-xl z-10">
                      {adventure.title}
                    </div>
                    <div className="absolute bottom-0 left-0 right-0 h-1/2 bg-gradient-to-t from-black to-transparent z-[9]" />
                    <Image src={getImageUrl(adventure.image)} alt={adventure.title} fill className="object-cover" />
                  </div>
                  <CardContent className="flex-1 flex flex-col">
                    <div className="relative z-10 flex-1 flex flex-col">
                      <div className="text-gray-300 text-base -mt-2 flex-1">{adventure.teaser || adventure.overview}</div>
                      <div className="mt-4 mb-6 w-full flex justify-center">
                        <Button variant="epic" size="sm" className="text-sm">
                          Play
                        </Button>
                      </div>
                    </div>
                    <div className="absolute bottom-0 left-0 right-0 h-1/4 bg-gradient-to-tl from-black/50 to-transparent" />
                  </CardContent>
                </Card>
              </Link>
            ))}
          </div>
          <div className="px-8">
            <p>{setting.description}</p>
          </div>
          <div className="flex justify-center pt-8 pb-24">
            <Link href={`/settings/${settingId}`}>
              <Button variant="epic" asChild>
                Go To Setting
              </Button>
            </Link>
          </div>
        </div>
      </div>
    </div>
  )
}


/*
  File: app/terms/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/terms/page.tsx
  Directory: app/terms
*/

--- File: app/terms/page.tsx ---

import { Heading } from "@/components/typography/heading"

export default function TermsPage() {
  return (
    <div className="container py-12">
      <div className="mx-auto max-w-4xl">
        <div className="mb-12 text-center">
          <Heading variant="h1" className="mb-8">
            Terms of Service
          </Heading>
        </div>

        <p className="text-gray-700 mb-6">Put your terms of service here.</p>
      </div>
    </div>
  )
}


/*
  File: app/unsubscribe/page.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/unsubscribe/page.tsx
  Directory: app/unsubscribe
*/

--- File: app/unsubscribe/page.tsx ---

import { Heading } from "@/components/typography/heading"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import UnsubscribeForm from "./unsubscribe-form"

export default function UnsubscribePage() {
  return (
    <div className="container max-w-md py-12 flex flex-col items-center justify-center min-h-[60vh]">
      <Card className="w-full">
        <CardHeader>
          <CardTitle>
            <Heading variant="h2" className="text-center">
              Unsubscribe from Mailing List
            </Heading>
          </CardTitle>
        </CardHeader>
        <CardContent>
          <UnsubscribeForm />
        </CardContent>
      </Card>
    </div>
  )
}


/*
  File: app/unsubscribe/unsubscribe-form.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/app/unsubscribe/unsubscribe-form.tsx
  Directory: app/unsubscribe
*/

--- File: app/unsubscribe/unsubscribe-form.tsx ---

"use client"

import { useState } from "react"
import { unsubscribe } from "@/app/_actions/mailing-list"
import { Button } from "@/components/ui/button"

export default function UnsubscribeForm() {
  const [email, setEmail] = useState("")
  const [status, setStatus] = useState<"idle" | "success" | "error">("idle")
  const [error, setError] = useState<string | null>(null)

  async function handleUnsubscribe(e: React.FormEvent) {
    e.preventDefault()
    setStatus("idle")
    setError(null)
    try {
      const result = await unsubscribe(email)
      if (result.success) {
        setStatus("success")
      } else {
        setStatus("error")
        setError(result.error || "Could not unsubscribe. Please check your email.")
      }
    } catch (err: unknown) {
      setStatus("error")
      setError(err instanceof Error ? err.message : "Could not unsubscribe. Please try again.")
    }
  }

  return (
    <>
      {status === "success" ? (
        <div className="text-center text-green-600 font-semibold py-6">You have been unsubscribed from our mailing list.</div>
      ) : (
        <form onSubmit={handleUnsubscribe} className="space-y-6">
          <div>
            <label htmlFor="email" className="block mb-2 font-medium">
              Email address
            </label>
            <input id="email" type="email" className="w-full border rounded px-3 py-2" value={email} onChange={(e) => setEmail(e.target.value)} required autoFocus />
          </div>
          <Button type="submit" className="w-full" size="lg" variant="destructive">
            Unsubscribe
          </Button>
          {status === "error" && <div className="text-red-600 text-sm text-center mt-2">{error}</div>}
        </form>
      )}
    </>
  )
}


/*
  File: components/admin/admin-config-message.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/admin/admin-config-message.tsx
  Directory: components/admin
*/

--- File: components/admin/admin-config-message.tsx ---

"use client"

import { Card } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { useUser } from "@clerk/nextjs"
import { Copy, ShieldUser } from "lucide-react"
import { toast } from "sonner"

export function AdminConfigMessage() {
  const { user } = useUser()

  const handleCopyId = () => {
    if (user?.id) {
      navigator.clipboard.writeText(user.id)
      toast.success("User ID copied to clipboard!")
    }
  }

  return (
    <Card className="p-6">
      <div className="space-y-4">
        <div className="flex justify-center mb-4">
          <div className="p-2 rounded-full bg-amber-500/10">
            <ShieldUser className="w-8 h-8 text-amber-600" />
          </div>
        </div>
        <h3 className="text-lg font-medium text-center">Configure Admin Access</h3>
        <p className="text-sm text-muted-foreground text-center text-balance">
          To access admin features, you need to add your Clerk User ID to the <code className="px-1.5 py-0.5 rounded-md bg-muted">ADMIN_USER_IDS</code> environment variable.
        </p>
        <div className="p-4 rounded-lg bg-muted space-y-4">
          <div className="space-y-2">
            <p className="text-sm font-medium">Your Clerk User ID:</p>
            <div className="flex items-center gap-2">
              <code className="flex-1 px-3 py-2 rounded bg-background">{user?.id || "Not signed in"}</code>
              <Button size="icon" variant="outline" onClick={handleCopyId} disabled={!user?.id}>
                <Copy className="h-4 w-4" />
              </Button>
            </div>
          </div>
          <div className="space-y-2">
            <p className="text-sm font-medium">Add to your .env file:</p>
            <code className="block px-3 py-2 rounded bg-background text-sm">ADMIN_USER_IDS={user?.id || "your_user_id"}</code>
          </div>
        </div>
        <p className="text-xs text-muted-foreground text-center">After updating your .env file, restart your development server for changes to take effect.</p>
      </div>
    </Card>
  )
}


/*
  File: components/admin/config-card.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/admin/config-card.tsx
  Directory: components/admin
*/

--- File: components/admin/config-card.tsx ---

import { AlertCircle, CheckCircle, XCircle } from "lucide-react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"

interface ConfigItem {
  key: string
  description: string
  isMissing?: boolean
}

interface FileToRemove {
  path: string
  description?: string
}

interface ConfigCardProps {
  title: string
  description: string
  configItems: ConfigItem[]
  filesToRemove?: FileToRemove[]
  alternativeTitle?: string
  alternativeDescription?: string
}

export function ConfigCard({
  title,
  description,
  configItems,
  filesToRemove,
  alternativeTitle = "Alternative option",
  alternativeDescription = "If you don't plan to use this feature, you can remove the following files:",
}: ConfigCardProps) {
  return (
    <Card className="w-full max-w-3xl mx-auto">
      <CardHeader>
        <CardTitle className="text-xl text-primary">{title}</CardTitle>
        <CardDescription className="text-primary/80">{description}</CardDescription>
      </CardHeader>
      <CardContent className="space-y-6">
        <div className="space-y-2">
          <p className="text-sm text-muted-foreground">
            To enable this functionality, you need to configure the following environment variables in your <code className="bg-muted px-1 py-0.5 rounded text-sm font-mono">.env</code> file:
          </p>

          <div className="space-y-3 mt-4">
            {configItems.map((item) => (
              <div key={item.key} className="grid grid-cols-2 gap-2 items-start">
                <div className="flex items-center gap-2">
                  {item.isMissing ? <XCircle className="h-4 w-4 text-destructive" /> : <CheckCircle className="h-4 w-4 text-green-500" />}
                  <code className={`font-semibold py-1 rounded text-xs font-mono ${item.isMissing ? "text-destructive" : "text-green-500"}`}>{item.key}</code>
                </div>
                <p className="text-sm">{item.description}</p>
              </div>
            ))}
          </div>
        </div>

        {filesToRemove && filesToRemove.length > 0 && (
          <Alert className="border-primary/20 bg-primary/5">
            <AlertCircle className="h-4 w-4 text-primary" />
            <AlertTitle className="text-primary">{alternativeTitle}</AlertTitle>
            <AlertDescription className="text-primary/80">
              {alternativeDescription}
              <ul className="list-disc pl-5 mt-2 space-y-1">
                {filesToRemove.map((file) => (
                  <li key={file.path} className="text-sm">
                    <code className="bg-muted px-1 py-0.5 rounded text-xs font-mono">{file.path}</code>
                    {file.description && <span className="text-primary/70 ml-2">- {file.description}</span>}
                  </li>
                ))}
              </ul>
            </AlertDescription>
          </Alert>
        )}
      </CardContent>
    </Card>
  )
}


/*
  File: components/admin/dev-env-notice.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/admin/dev-env-notice.tsx
  Directory: components/admin
*/

--- File: components/admin/dev-env-notice.tsx ---

import { Card, CardContent } from "@/components/ui/card"
import { Heading } from "../typography/heading"

export function DevEnvNotice() {
  return (
    <Card className="mb-8 bg-blue-500/5 border-blue-500/20">
      <CardContent>
        <div className="flex items-start gap-4">
          <div className="space-y-4 text-balance">
            <Heading variant="h5" className="font-medium">
              Development Environment
            </Heading>
            <p className="text-sm text-muted-foreground">
              You are running this application in a local development environment. The <code className="px-1.5 py-0.5 rounded-md bg-muted">ADMIN_USER_IDS</code> environment variable is currently set
              to:
            </p>
            <div className="mt-2">
              <code className="block w-full px-3 py-2 text-sm bg-muted rounded-md">{process.env.ADMIN_USER_IDS || "Not configured"}</code>
            </div>
            <p className="text-sm text-muted-foreground mt-2">
              To add more admin users, update this variable in your <code className="px-1 py-0.5 rounded-md bg-muted">.env</code> file with a comma-separated list of Clerk user IDs.
            </p>
          </div>
        </div>
      </CardContent>
    </Card>
  )
}


/*
  File: components/admin/mailing-list/mailing-list-subscriber-table.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/admin/mailing-list/mailing-list-subscriber-table.tsx
  Directory: components/admin/mailing-list
*/

--- File: components/admin/mailing-list/mailing-list-subscriber-table.tsx ---

"use client"

import { Badge } from "@/components/ui/badge"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Id } from "@/convex/_generated/dataModel"
import { formatDate } from "@/lib/utils"

type Subscriber = {
  id: Id<"mailing_list_subscriptions">
  userId: string
  email: string
  name: string | null
  preferences: {
    marketing: boolean
    updates: boolean
  }
  subscribedAt: string
  unsubscribedAt: string | null
  createdAt: string
  updatedAt: string
}

interface MailingListSubscriberTableProps {
  subscribers: Subscriber[]
}

export function MailingListSubscriberTable({ subscribers }: MailingListSubscriberTableProps) {
  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>Email</TableHead>
          <TableHead>Name</TableHead>
          <TableHead>Subscribed</TableHead>
          <TableHead>Status</TableHead>
          <TableHead>Preferences</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {subscribers.map((subscriber) => {
          return (
            <TableRow key={subscriber.id}>
              <TableCell>{subscriber.email}</TableCell>
              <TableCell>{subscriber.name || "-"}</TableCell>
              <TableCell>{formatDate(subscriber.subscribedAt)}</TableCell>
              <TableCell>{subscriber.unsubscribedAt ? <Badge variant="destructive">Unsubscribed</Badge> : <Badge variant="default">Active</Badge>}</TableCell>
              <TableCell>
                <div className="flex gap-2">
                  {subscriber.preferences.marketing && <Badge variant="outline">Marketing</Badge>}
                  {subscriber.preferences.updates && <Badge variant="outline">Updates</Badge>}
                </div>
              </TableCell>
            </TableRow>
          )
        })}
      </TableBody>
    </Table>
  )
}


/*
  File: components/admin/roadmap-view.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/admin/roadmap-view.tsx
  Directory: components/admin
*/

--- File: components/admin/roadmap-view.tsx ---

"use client"

import { useState } from "react"
import { ChevronDown, ChevronUp, ArrowRight } from "lucide-react"
import Link from "next/link"

import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { Heading } from "@/components/typography/heading"

export type Feature = {
  id: string
  title: string
  votes: number // Keeping this in the type for data compatibility
  status: "backlog" | "planned" | "in-progress" | "completed"
  description?: string
}

export type FeatureRequest = {
  id: string
  title: string
  votes: number // Keeping this in the type for data compatibility
  description?: string
}

interface RoadmapViewProps {
  features: Feature[]
  featureRequests: FeatureRequest[]
}

export function RoadmapView({ features, featureRequests }: RoadmapViewProps) {
  const [expanded, setExpanded] = useState<Record<string, boolean>>({
    backlog: false,
    planned: false,
    "in-progress": false,
    completed: false,
  })

  // Group features by status
  const backlogFeatures = features.filter((f) => f.status === "backlog").sort((a, b) => b.votes - a.votes)
  const plannedFeatures = features.filter((f) => f.status === "planned").sort((a, b) => b.votes - a.votes)
  const inProgressFeatures = features.filter((f) => f.status === "in-progress").sort((a, b) => b.votes - a.votes)
  const completedFeatures = features.filter((f) => f.status === "completed").sort((a, b) => b.votes - a.votes)

  // Sort feature requests by votes
  const sortedRequests = [...featureRequests].sort((a, b) => b.votes - a.votes)

  const toggleExpand = (section: string) => {
    setExpanded((prev) => ({
      ...prev,
      [section]: !prev[section],
    }))
  }

  // Function to limit and display cards
  const renderFeatureCards = (featureList: Feature[], status: string) => {
    const isExpanded = expanded[status]
    const displayedFeatures = isExpanded ? featureList : featureList.slice(0, 4)
    const hasMore = featureList.length > 4

    return (
      <>
        <div className="space-y-3">
          {displayedFeatures.map((feature) => (
            <Card key={feature.id} className="gap-2">
              <CardHeader>
                <CardTitle className="font-bold">{feature.title}</CardTitle>
              </CardHeader>
              <CardContent>{feature.description && <p className="text-xs text-muted-foreground">{feature.description}</p>}</CardContent>
            </Card>
          ))}
        </div>
        {hasMore && (
          <Button variant="ghost" size="sm" className="w-full mt-2 text-xs" onClick={() => toggleExpand(status)}>
            {isExpanded ? (
              <>
                Show Less <ChevronUp className="ml-1 h-3 w-3" />
              </>
            ) : (
              <>
                Show More ({featureList.length - 4} more) <ChevronDown className="ml-1 h-3 w-3" />
              </>
            )}
          </Button>
        )}
      </>
    )
  }

  return (
    <div className="container mx-auto py-8 px-4">
      <div className="container max-w-7xl mx-auto">
        <div className="text-center mb-8 space-y-2">
          <Heading variant="h2">Product Roadmap</Heading>
          <p className="text-muted-foreground">See what features are coming next and share your ideas</p>
        </div>

        <div className="mb-8">
          <div className="grid md:grid-cols-2 lg:grid-cols-4 p-4 gap-6">
            <div>
              <div className="font-medium text-lg mb-2 flex items-center gap-2">
                Backlog{" "}
                <Badge variant="outline" className="bg-gray-100 text-gray-700 hover:bg-gray-100 border-gray-200">
                  {backlogFeatures.length}
                </Badge>
              </div>
              {renderFeatureCards(backlogFeatures, "backlog")}
            </div>

            <div>
              <div className="font-medium text-lg mb-2 flex items-center gap-2">
                Up Next{" "}
                <Badge variant="outline" className="bg-amber-100 text-amber-700 hover:bg-amber-100 border-amber-200">
                  {plannedFeatures.length}
                </Badge>
              </div>
              {renderFeatureCards(plannedFeatures, "planned")}
            </div>

            <div>
              <div className="font-medium text-lg mb-2 flex items-center gap-2">
                In Progress{" "}
                <Badge variant="secondary" className="bg-sky-100 text-sky-700 hover:bg-sky-100 border-sky-200">
                  {inProgressFeatures.length}
                </Badge>
              </div>
              {renderFeatureCards(inProgressFeatures, "in-progress")}
            </div>

            <div>
              <div className="font-medium text-lg mb-2 flex items-center gap-2">
                Completed <Badge className="bg-emerald-100 text-emerald-700 hover:bg-emerald-100 border-emerald-200">{completedFeatures.length}</Badge>
              </div>
              {renderFeatureCards(completedFeatures, "completed")}
            </div>
          </div>
        </div>

        <div className="grid gap-8 md:grid-cols-[2fr_1fr] container border-t-2 border-dashed border-primary/50 pt-12">
          <Card>
            <CardHeader>
              <CardTitle>Feature Ideas</CardTitle>
              <CardDescription>Community suggestions that may be added to the roadmap.</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {sortedRequests.map((request) => (
                  <div key={request.id} className="flex items-start gap-4 p-3 rounded-lg border">
                    <div className="flex-1 space-y-1">
                      <div className="flex items-center gap-2">
                        <span className="font-medium">{request.title}</span>
                        <Badge variant="outline" className="bg-foreground/10 text-foreground">
                          Idea
                        </Badge>
                      </div>
                      {request.description && <p className="text-sm text-muted-foreground">{request.description}</p>}
                    </div>
                  </div>
                ))}
                {featureRequests.length === 0 && (
                  <p className="text-sm text-muted-foreground border border-dashed border-foreground/10 rounded-md px-4 py-12 justify-center items-center flex">
                    No feature requests yet. Be the first to suggest a feature!
                  </p>
                )}
              </div>
            </CardContent>
          </Card>

          <div className="space-y-8">
            <Card>
              <CardHeader>
                <CardTitle>Suggest a Feature</CardTitle>
                <CardDescription>What would you like to see in our product?</CardDescription>
              </CardHeader>
              <CardContent>
                <Button asChild className="w-full">
                  <Link href="/contact/">
                    Suggest a Feature <ArrowRight className="ml-2 h-4 w-4" />
                  </Link>
                </Button>
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <CardTitle>Get Updates</CardTitle>
                <CardDescription>Subscribe to be notified when features are released</CardDescription>
              </CardHeader>
              <CardContent>
                <Button asChild className="w-full">
                  <Link href="/subscribe/">
                    Subscribe to Updates <ArrowRight className="ml-2 h-4 w-4" />
                  </Link>
                </Button>
              </CardContent>
            </Card>
          </div>
        </div>
      </div>
    </div>
  )
}


/*
  File: components/admin/user-list.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/admin/user-list.tsx
  Directory: components/admin
*/

--- File: components/admin/user-list.tsx ---

"use client"

import * as React from "react"
import { useState } from "react"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { banUser } from "@/app/_actions/ban-user"
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from "@/components/ui/alert-dialog"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { toast } from "sonner"

interface User {
  id: string
  email: string | undefined
  username: string | null
  firstName: string | null
  lastName: string | null
  imageUrl: string
  createdAt: string
  isAdmin: boolean
  banned: boolean
  publicMetadata?: {
    banReason?: string
  }
}

interface AdminUserListProps {
  initialUsers: User[]
}

export function AdminUserList({ initialUsers }: AdminUserListProps) {
  const [users, setUsers] = useState<User[]>(initialUsers)
  const [showBanDialog, setShowBanDialog] = useState(false)
  const [selectedUser, setSelectedUser] = useState<User | null>(null)
  const [banReason, setBanReason] = useState("")
  const [isLoading, setIsLoading] = useState(false)

  const handleBanClick = (user: User) => {
    setSelectedUser(user)
    setShowBanDialog(true)
  }

  const handleBanConfirm = async () => {
    if (!selectedUser) return

    setIsLoading(true)
    try {
      const result = await banUser(selectedUser.id, banReason)

      if (result.success) {
        // Update the local users state
        setUsers(
          users.map((user) => {
            if (user.id === selectedUser.id) {
              return {
                ...user,
                banned: !user.banned,
                publicMetadata: {
                  ...user.publicMetadata,
                  banReason: !user.banned ? banReason : undefined,
                },
              }
            }
            return user
          })
        )

        toast.success(selectedUser.banned ? "User unbanned successfully" : "User banned successfully")
        setShowBanDialog(false)
        setBanReason("")
        setSelectedUser(null)
      } else {
        toast.error("Failed to manage user ban status: " + result.error)
      }
    } catch {
      toast.error("An error occurred while managing user ban status")
    } finally {
      setIsLoading(false)
    }
  }

  const formatDate = (date: string | null) => {
    if (!date) return "Never"
    return new Date(date).toLocaleDateString()
  }

  return (
    <>
      <div className="rounded-md border">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead className="w-[30px]"></TableHead>
              <TableHead>User</TableHead>
              <TableHead>Email</TableHead>
              <TableHead>Username</TableHead>
              <TableHead>Joined</TableHead>
              <TableHead>Status</TableHead>
              <TableHead>Actions</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {users.map((user) => (
              <React.Fragment key={user.id}>
                <TableRow>
                  <TableCell>{/* Placeholder for user action button */}</TableCell>
                  <TableCell className="flex items-center gap-2">
                    <Avatar className="h-8 w-8">
                      <AvatarImage src={user.imageUrl} alt={user.username || ""} />
                      <AvatarFallback>
                        {user.firstName?.[0]}
                        {user.lastName?.[0]}
                      </AvatarFallback>
                    </Avatar>
                    <span>
                      {user.firstName} {user.lastName}
                    </span>
                  </TableCell>
                  <TableCell>{user.email}</TableCell>
                  <TableCell>{user.username}</TableCell>
                  <TableCell>{formatDate(user.createdAt)}</TableCell>
                  <TableCell>{user.isAdmin ? <Badge>Admin</Badge> : user.banned ? <Badge variant="destructive">Banned</Badge> : <Badge variant="secondary">User</Badge>}</TableCell>
                  <TableCell>
                    {!user.isAdmin && (
                      <Button variant={user.banned ? "outline" : "destructive"} size="sm" onClick={() => handleBanClick(user)} disabled={isLoading}>
                        {user.banned ? "Unban User" : "Ban User"}
                      </Button>
                    )}
                  </TableCell>
                </TableRow>
              </React.Fragment>
            ))}
          </TableBody>
        </Table>
      </div>

      <AlertDialog open={showBanDialog} onOpenChange={setShowBanDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>{selectedUser?.banned ? "Unban User" : "Ban User"}</AlertDialogTitle>
            <AlertDialogDescription>
              {selectedUser?.banned ? (
                <>
                  Are you sure you want to unban {selectedUser?.firstName} {selectedUser?.lastName}?
                </>
              ) : (
                <>
                  Are you sure you want to ban {selectedUser?.firstName} {selectedUser?.lastName}? This action can be undone later.
                </>
              )}
            </AlertDialogDescription>
          </AlertDialogHeader>
          {!selectedUser?.banned && (
            <div className="py-4">
              <Label htmlFor="reason">Reason for ban (optional)</Label>
              <Input id="reason" value={banReason} onChange={(e) => setBanReason(e.target.value)} placeholder="Enter reason for ban" />
            </div>
          )}
          <AlertDialogFooter>
            <AlertDialogCancel
              onClick={() => {
                setShowBanDialog(false)
                setBanReason("")
                setSelectedUser(null)
              }}
            >
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction onClick={handleBanConfirm} disabled={isLoading}>
              {selectedUser?.banned ? "Unban User" : "Ban User"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  )
}


/*
  File: components/adventure/PartyConfiguration.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/PartyConfiguration.tsx
  Directory: components/adventure
*/

--- File: components/adventure/PartyConfiguration.tsx ---

"use client"

import React, { useEffect, useState } from "react"
import { Button } from "@/components/ui/button"
import type { CharacterChoiceMode } from "./character-selection"
import { useParams } from "next/navigation"
import { scrollToBottom } from "../ui/utils"
import { useUser, SignUpButton } from "@clerk/nextjs"
import { createAdventure } from "@/app/_actions/create-adventure"

interface PartyConfigurationProps {
  characterChoices: CharacterChoiceMode[]
  onModeChange: (characterId: string, mode: "player" | "invite" | "ai") => void
  characterNames: Record<string, string>
}

const PartyConfiguration: React.FC<PartyConfigurationProps> = ({ characterChoices, characterNames }) => {
  const { settingId, adventurePlanId } = useParams()
  const { isSignedIn } = useUser()
  const [isCreating, setIsCreating] = useState(false)

  const handleStartAdventure = async () => {
    if (isCreating) return

    setIsCreating(true)
    try {
      await createAdventure({
        settingId: settingId as string,
        adventurePlanId: adventurePlanId as string,
        characterChoices,
      })
      // The redirect happens in the server action
    } catch (error) {
      console.error("Failed to create adventure:", error)
      setIsCreating(false)
    }
  }

  useEffect(() => {
    scrollToBottom()
  }, [])

  return (
    <div className="bg-black/50 rounded-lg p-4 sm:p-8 space-y-4 divide-y divide-white/20">
      {characterChoices.map((choice) => (
        <div key={choice.characterId} className="character-choice flex justify-between items-center w-full pb-4">
          <span className="font-display text-xl font-semibold relative top-1">{characterNames[choice.characterId]}</span>
          <div className="mode-buttons flex items-center space-x-8">
            {choice.mode === "player" ? <Button variant="epic">Player</Button> : <div className="text-green-300 bg-green-200/10 px-12 mr-2 py-1 border border-green-300 rounded font-mono">Open</div>}
          </div>
        </div>
      ))}

      <div className="text-center py-4">
        {isSignedIn ? (
          <Button variant="epic" size="lg" className="text-2xl py-6 px-12" onClick={handleStartAdventure} disabled={isCreating}>
            {isCreating ? "Creating Adventure..." : "Start Adventure"}
          </Button>
        ) : (
          <SignUpButton mode="modal">
            <Button variant="epic" size="lg" className="text-2xl py-6 px-12">
              Sign Up
            </Button>
          </SignUpButton>
        )}
      </div>
    </div>
  )
}

export default PartyConfiguration


/*
  File: components/adventure/adventure-complete.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/adventure-complete.tsx
  Directory: components/adventure
*/

--- File: components/adventure/adventure-complete.tsx ---

import { Card, CardContent } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { CheckCircle, Trophy, BookOpen } from "lucide-react"
import Link from "next/link"

export default function AdventureComplete() {
  return (
    <Card className="max-w-2xl mx-auto border-2 border-green-200 bg-gradient-to-b from-green-50 to-white">
      <CardContent className="flex flex-col items-center gap-6 py-16">
        <div className="flex items-center gap-3">
          <Trophy className="h-12 w-12 text-yellow-500 animate-bounce" />
          <CheckCircle className="h-12 w-12 text-green-500" />
        </div>

        <div className="text-center space-y-3">
          <h2 className="text-3xl font-bold text-green-800">Adventure Complete!</h2>
          <p className="text-xl text-muted-foreground">Congratulations! You have successfully completed this adventure.</p>
          <p className="text-sm text-muted-foreground max-w-md">
            The story has reached its conclusion. Your journey through the Valkarr forest and the mysteries it holds has come to an end. Well done, adventurer!
          </p>
        </div>

        <div className="flex gap-3 mt-4">
          <Button asChild variant="outline" className="flex items-center gap-2">
            <Link href="/">
              <BookOpen className="h-4 w-4" />
              Explore More Adventures
            </Link>
          </Button>
        </div>
      </CardContent>
    </Card>
  )
}


/*
  File: components/adventure/adventure-lobby.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/adventure-lobby.tsx
  Directory: components/adventure
*/

--- File: components/adventure/adventure-lobby.tsx ---

"use client"

import React, { useState, useEffect } from "react"
import { useUser, SignInButton } from "@clerk/nextjs"
import { Button } from "@/components/ui/button"
import { Card, CardContent } from "@/components/ui/card"
import type { Adventure, TurnCharacter } from "@/types/adventure"
import type { AdventurePlan } from "@/types/adventure-plan"
import type { PCTemplate } from "@/types/character"
import Image from "next/image"
import { getImageUrl } from "@/lib/utils"
import { Copy, Check, Share2, Bot } from "lucide-react"
import { toast } from "sonner"
import { useParams } from "next/navigation"
import { textShadow } from "../typography/styles"
import { joinAdventure } from "@/app/_actions/join-adventure"
import { startAdventure } from "@/app/_actions/start-adventure"
import { CharacterSheetModal } from "./character-sheet-modal"
import { scrollToTop } from "../ui/utils"

interface AdventureLobbyProps {
  adventure: Adventure
  adventurePlan?: AdventurePlan
}

// Convert PC to TurnCharacter format for the modal
function convertPCToTurnCharacter(pc: Adventure["party"][0]): TurnCharacter {
  return {
    ...pc,
    type: "pc" as const,
    initiative: 0, // Default value
    hasReplied: false,
    isComplete: false,
  }
}

// Convert PCTemplate to TurnCharacter format for the modal
function convertPCTemplateToTurnCharacter(pcTemplate: PCTemplate): TurnCharacter {
  return {
    ...pcTemplate,
    type: "pc" as const,
    userId: "", // Empty for template
    initiative: 0, // Default value
    hasReplied: false,
    isComplete: false,
  }
}

export default function AdventureLobby({ adventure, adventurePlan }: AdventureLobbyProps) {
  const { user, isSignedIn, isLoaded } = useUser()
  const params = useParams()
  const [isCopied, setIsCopied] = useState(false)
  const [assigningToAI, setAssigningToAI] = useState<string | null>(null)
  const [isJoining, setIsJoining] = useState(false)
  const [isStarting, setIsStarting] = useState(false)
  const [modalCharacter, setModalCharacter] = useState<TurnCharacter | null>(null)
  const [isModalOpen, setIsModalOpen] = useState(false)

  useEffect(() => {
    if (isLoaded) {
      scrollToTop()
    }
  }, [isLoaded])

  if (!isLoaded) {
    return null
  }

  // Generate the invite link
  const inviteLink = typeof window !== "undefined" ? `${window.location.origin}/settings/${params.settingId}/${params.adventurePlanId}/${adventure.id}` : ""

  // Generate the redirect URL for after sign up/sign in
  const redirectUrl =
    typeof window !== "undefined" ? window.location.href : `${process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000"}/settings/${params.settingId}/${params.adventurePlanId}/${adventure.id}`

  const handleCopyInvite = async () => {
    try {
      await navigator.clipboard.writeText(inviteLink)
      setIsCopied(true)
      toast.success("Invite link copied to clipboard!")
      setTimeout(() => setIsCopied(false), 2000)
    } catch (error) {
      toast.error("Failed to copy link")
      console.error("Copy failed:", error)
    }
  }

  const handleAssignToAI = async (characterId: string) => {
    setAssigningToAI(characterId)
    try {
      // TODO: Implement assignCharacterToAI server action
      await new Promise((resolve) => setTimeout(resolve, 1000)) // Placeholder delay
      toast.success("Character assigned to AI!")
    } catch {
      toast.error("Failed to assign character to AI")
    } finally {
      setAssigningToAI(null)
    }
  }

  const handleJoinAdventure = async (characterId: string) => {
    if (isJoining) return

    setIsJoining(true)
    await joinAdventure({
      settingId: params.settingId as string,
      adventurePlanId: params.adventurePlanId as string,
      adventureId: adventure.id,
      characterId,
    })
    // The redirect happens in the server action
    // Note: redirect() throws NEXT_REDIRECT which is expected behavior, not an error
  }

  const handleStartAdventure = async () => {
    if (isStarting) return

    setIsStarting(true)
    await startAdventure({
      settingId: params.settingId as string,
      adventurePlanId: params.adventurePlanId as string,
      adventureId: adventure.id,
    })
    // The redirect happens in the server action
    // Note: redirect() throws NEXT_REDIRECT which is expected behavior, not an error
  }

  const handleViewCharacterSheet = (character: Adventure["party"][0]) => {
    const turnCharacter = convertPCToTurnCharacter(character)
    setModalCharacter(turnCharacter)
    setIsModalOpen(true)
  }

  const handleViewAvailableCharacterSheet = (character: PCTemplate) => {
    const turnCharacter = convertPCTemplateToTurnCharacter(character)
    setModalCharacter(turnCharacter)
    setIsModalOpen(true)
  }

  // Check if current user has a character in this adventure
  const userCharacter = adventure.party?.find((pc) => pc.userId === user?.id)

  // Get available characters (not claimed by anyone)
  const availableCharacters = adventurePlan?.premadePlayerCharacters?.filter((pc) => !adventure.party?.some((partyMember) => partyMember.id === pc.id)) || []

  // Get AI-controlled characters (placeholder - will be implemented with aiCharacters array)
  const aiCharacters: PCTemplate[] = [] // TODO: Get from adventure.aiCharacters

  // Determine party state based on adventure plan requirements
  const [minParty, maxParty] = adventurePlan?.party || [1, 4] // Default fallback
  const currentPartySize = adventure.party?.length || 0
  const canStartAdventure = currentPartySize >= minParty
  const partyIsFull = currentPartySize >= maxParty
  const shouldShowInvite = !partyIsFull && availableCharacters.length > 0

  console.log("[AdventureLobby] party info", {
    minParty,
    maxParty,
    currentPartySize,
    canStartAdventure,
    partyIsFull,
    shouldShowInvite,
  })

  // Show different UI based on user state
  if (isSignedIn && userCharacter) {
    // User is signed in and has a character - show waiting state
    return (
      <div className="w-full flex flex-col items-center justify-center max-w-5xl fade-in relative z-10 pb-16 -mt-16">
        <div className="absolute -top-4 left-0 w-full flex justify-center z-10 text-xl text-center font-display font-bold">
          <div className="text-sm bg-primary-700 px-4 py-1 ring-[6px] ring-primary-800 rounded border border-white/20 font-display text-amber-300">Your Character</div>
        </div>
        <div
          id="your-character"
          className="relative bg-black/50 rounded-lg overflow-hidden border border-white/30 ring-8 ring-black/50 w-80 cursor-pointer hover:ring-primary-500 transition-all duration-300 hover:scale-[1.01]"
          onClick={() => handleViewCharacterSheet(userCharacter)}
        >
          <div className="relative w-full h-full aspect-square">
            <Image className="w-full h-full object-cover" fill src={getImageUrl(userCharacter.image)} alt={userCharacter.name} />
          </div>
          <div className="text-white absolute bottom-0 left-0 right-0 w-full z-10 text-center">
            <div className="font-display font-bold text-2xl mb-1">{userCharacter.name}</div>
            <div className="text-xs font-medium bg-black/80 px-2 py-1 rounded border border-white/30 inline-block mb-3">View Character Sheet</div>
          </div>
          <div className="absolute bottom-0 left-0 w-full bg-gradient-to-t from-black to-transparent h-1/2" />
        </div>

        <div className="pt-12 mb-4 text-center flex flex-col items-center">
          {adventurePlan?.teaser && (
            <div className="pb-16 max-w-2xl mx-auto">
              <p>{adventurePlan?.teaser}</p>
            </div>
          )}

          {/* Show different messages based on party state */}
          {!canStartAdventure ? (
            <h3 className="font-display mb-6 text-2xl opacity-70">
              Waiting for more players...
              <div className="font-mono text-sm text-primary-200">
                ({currentPartySize}/{minParty} minimum)
              </div>
            </h3>
          ) : partyIsFull ? (
            <div className="space-y-4">
              <h3 className="font-display mb-4 text-2xl text-green-400">Party Complete!</h3>
              <p className="text-lg text-white/80 mb-6">All party slots filled. Ready to begin the adventure?</p>
              <Button variant="epic" size="lg" className="text-xl py-4 px-8" onClick={handleStartAdventure} disabled={isStarting}>
                {isStarting ? "Starting Adventure..." : "Start Adventure"}
              </Button>
            </div>
          ) : (
            <div className="space-y-4">
              <h3 className="font-display mb-4 text-2xl text-green-400">Ready to Start!</h3>
              <p className="text-lg text-white/80 mb-6">
                Minimum party size reached ({currentPartySize}/{maxParty}). You can start now or wait for more players.
              </p>
              <Button variant="epic" size="lg" className="text-xl py-4 px-8" onClick={handleStartAdventure} disabled={isStarting}>
                {isStarting ? "Starting Adventure..." : "Start Adventure"}
              </Button>
            </div>
          )}

          {/* Invite Link - only show if party isn't full */}
          {shouldShowInvite && (
            <div className="mb-6 border border-white/30 bg-primary-800/70 rounded-lg pt-2 pb-6 px-4">
              <p className="text-sm text-amber-400 pt-3 pb-2 font-display text-xl">Invite Players</p>
              <div className="flex items-center gap-2 bg-black rounded-lg p-3 max-w-md mx-auto">
                <Share2 className="w-4 h-4 text-blue-400 flex-shrink-0" />
                <code className="flex-1 text-xs text-gray-300 truncate">{inviteLink}</code>
                <Button size="sm" variant="outline" onClick={handleCopyInvite} className="flex-shrink-0 h-7 px-2">
                  {isCopied ? <Check className="w-3 h-3 text-green-500" /> : <Copy className="w-3 h-3" />}
                </Button>
              </div>
            </div>
          )}

          {/* Available Characters - only show if party isn't full */}
          {shouldShowInvite && (
            <div className="space-y-3 w-full max-w-lg mx-auto">
              <p className="text-sm text-white/70 mt-4 mb-2">Available characters:</p>
              {availableCharacters.map((char) => (
                <div key={char.id} className="w-full flex items-center justify-between bg-black/30 rounded-lg p-3 border border-white/20">
                  <div
                    className="flex items-center gap-3 cursor-pointer hover:bg-white/10 transition-colors duration-500 ease-in-out rounded p-1 -m-1"
                    onClick={() => handleViewAvailableCharacterSheet(char)}
                  >
                    <div className="w-16 h-16 rounded-lg overflow-hidden bg-gray-700">
                      <Image src={getImageUrl(char.image)} alt={char.name} width={40} height={40} className="w-full h-full object-cover" />
                    </div>
                    <div>
                      <p className="text-base font-display text-white pr-8">{char.name}</p>
                    </div>
                  </div>
                  <Button size="sm" variant="outline" onClick={() => handleAssignToAI(char.id)} disabled={assigningToAI === char.id} className="flex items-center gap-2 text-sm">
                    <Bot className="w-4 h-4" />
                    {assigningToAI === char.id ? "Assigning..." : "Assign to AI"}
                  </Button>
                </div>
              ))}
            </div>
          )}

          {/* AI-Controlled Characters */}
          {aiCharacters.length > 0 && (
            <div className="space-y-3 mt-6">
              <p className="text-sm text-gray-500 mb-4">AI-controlled characters:</p>
              {aiCharacters.map((char) => (
                <div key={char.id} className="flex items-center justify-between bg-blue-900/20 rounded-lg p-3 border border-blue-500/30">
                  <div className="flex items-center gap-3 cursor-pointer hover:bg-white/5 transition-colors duration-200 rounded p-1 -m-1" onClick={() => handleViewAvailableCharacterSheet(char)}>
                    <div className="w-10 h-10 rounded-full overflow-hidden bg-gray-700">
                      <Image src={getImageUrl(char.image)} alt={char.name} width={40} height={40} className="w-full h-full object-cover" />
                    </div>
                    <div>
                      <p className="text-sm font-medium text-white">{char.name}</p>
                      <p className="text-xs text-blue-300 flex items-center gap-1">
                        <Bot className="w-3 h-3" />
                        AI-controlled • Click to view details
                      </p>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* Character Sheet Modal */}
        <CharacterSheetModal character={modalCharacter} open={isModalOpen} onOpenChange={setIsModalOpen} />
      </div>
    )
  }

  if (!isSignedIn && availableCharacters.length > 0) {
    // User is not signed in and there are available characters
    const firstAvailable = availableCharacters[0]
    return (
      <div id="join-adventure" className="grow max-w-2xl fade-in relative z-10 -mt-16 pb-12">
        {adventurePlan?.teaser && (
          <div className="pb-8">
            <p style={textShadow}>{adventurePlan?.teaser}</p>
          </div>
        )}
        <Card className="bg-black/50 border-amber-300/30 ring-8 ring-black/30 max-w-md mx-auto">
          <CardContent className="p-6 text-center flex flex-col items-center gap-2">
            <h2 className="text-3xl text-amber-300 font-display mb-4">Join the Adventure</h2>
            <p className="mb-2 text-white/90">
              You can play as <span className="text-white text-xl">{firstAvailable.name}</span>
            </p>

            <div
              id="join-adventure-character"
              className="relative bg-black/50 rounded-lg overflow-hidden border border-white/30 ring-8 ring-black/50 w-80 cursor-pointer hover:ring-primary-500 transition-all duration-300 hover:scale-[1.01]"
              onClick={() => handleViewAvailableCharacterSheet(firstAvailable)}
            >
              <div className="relative w-full h-full aspect-square">
                <Image className="w-full h-full object-cover" fill src={getImageUrl(firstAvailable.image)} alt={firstAvailable.name} />
              </div>
              <div className="text-white absolute bottom-0 left-0 right-0 w-full z-10 text-center">
                <div className="font-display font-bold text-2xl mb-1">{firstAvailable.name}</div>
                <div className="text-xs font-medium bg-black/80 px-2 py-1 rounded border border-white/30 inline-block mb-3">View Character Sheet</div>
              </div>
              <div className="absolute bottom-0 left-0 w-full bg-gradient-to-t from-black to-transparent h-1/2" />
            </div>

            <p className="text-gray-300 mb-6 text-sm">Sign up to claim this character and join the adventure.</p>

            <SignInButton mode="modal" fallbackRedirectUrl={redirectUrl}>
              <Button variant="epic" size="lg" className="text-xl py-4 px-8">
                Sign Up to Play
              </Button>
            </SignInButton>

            {availableCharacters.length > 1 && (
              <div className="mt-6 bg-gray-900/50 rounded-lg p-4">
                <h3 className="text-sm font-semibold text-gray-400 mb-2">Other Available Characters:</h3>
                <div className="space-y-1">
                  {availableCharacters.slice(1).map((char) => (
                    <p key={char.id} className="text-sm text-gray-400">
                      {char.name} - <span className="text-green-300">Open</span>
                    </p>
                  ))}
                </div>
              </div>
            )}
          </CardContent>
        </Card>

        {/* Character Sheet Modal */}
        <CharacterSheetModal character={modalCharacter} open={isModalOpen} onOpenChange={setIsModalOpen} />
      </div>
    )
  }

  if (isSignedIn && !userCharacter && availableCharacters.length > 0) {
    // User is signed in but doesn't have a character yet - let them join
    const firstAvailable = availableCharacters[0]
    return (
      <div id="join-adventure" className="grow max-w-2xl fade-in relative z-10 -mt-16 pb-12">
        {adventurePlan?.teaser && (
          <div className="pb-8">
            <p style={textShadow}>{adventurePlan?.teaser}</p>
          </div>
        )}
        <Card className="bg-black/50 border-amber-300/30 ring-8 ring-black/30 max-w-md mx-auto">
          <CardContent className="p-6 text-center flex flex-col items-center gap-2">
            <h2 className="text-3xl text-amber-300 font-display mb-4">Join the Adventure</h2>
            <p className="mb-2 text-white/80">
              You can play as <span className="text-white">{firstAvailable.name}</span>
            </p>

            <div
              className="relative bg-black/50 rounded-lg overflow-hidden border border-white/30 ring-8 ring-black/50 w-80 cursor-pointer hover:ring-primary-500 transition-all duration-300 hover:scale-[1.01]"
              onClick={() => handleViewAvailableCharacterSheet(firstAvailable)}
            >
              <div className="relative w-full h-full aspect-square">
                <Image className="w-full h-full object-cover" fill src={getImageUrl(firstAvailable.image)} alt={firstAvailable.name} />
              </div>
              <div className="text-white absolute bottom-0 left-0 right-0 w-full z-10 text-center">
                <div className="font-display font-bold text-2xl mb-1">{firstAvailable.name}</div>
                <div className="text-xs font-medium bg-black/80 px-2 py-1 rounded border border-white/30 inline-block mb-3">View Character Sheet</div>
              </div>
              <div className="absolute bottom-0 left-0 w-full bg-gradient-to-t from-black to-transparent h-1/2" />
            </div>

            <Button variant="epic" size="lg" className="text-xl py-4 px-8 mt-4" onClick={() => handleJoinAdventure(firstAvailable.id)} disabled={isJoining}>
              {isJoining ? "Joining..." : `Join Game`}
            </Button>

            {availableCharacters.length > 1 && (
              <div className="mt-6 bg-gray-900/50 rounded-lg p-4">
                <h3 className="text-sm font-semibold text-gray-400 mb-2">Other Available Characters:</h3>
                <div className="space-y-1">
                  {availableCharacters.slice(1).map((char) => (
                    <p key={char.id} className="text-sm text-gray-400">
                      {char.name} - <span className="text-green-300">Open</span>
                    </p>
                  ))}
                </div>
              </div>
            )}
          </CardContent>
        </Card>

        {/* Character Sheet Modal */}
        <CharacterSheetModal character={modalCharacter} open={isModalOpen} onOpenChange={setIsModalOpen} />
      </div>
    )
  }

  // Fallback: show basic waiting message
  return (
    <div className="grow max-w-2xl fade-in">
      <Card className="bg-black/50 border-gray-500/50">
        <CardContent className="p-6 text-center">
          <h2 className="text-2xl font-bold text-gray-400 mb-4">Adventure Lobby</h2>
          <p className="text-gray-300 mb-6">{adventure.status === "waitingForPlayers" ? "Waiting for players to join..." : "Adventure is ready to begin!"}</p>
        </CardContent>
      </Card>
    </div>
  )
}


/*
  File: components/adventure/character-dice-roll-result-display.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/character-dice-roll-result-display.tsx
  Directory: components/adventure
*/

--- File: components/adventure/character-dice-roll-result-display.tsx ---

import Image from "next/image"
import DiceRollResult from "@/components/adventure/dice-roll-result"
import { getImageUrl } from "@/lib/utils"

export default function CharacterDiceRollResultDisplay({
  character,
  rollType,
  difficulty,
  result,
  image,
  modifier,
  baseRoll,
}: {
  character: string
  rollType: string
  difficulty: number
  result: number
  image?: string
  modifier?: number
  baseRoll?: number
}) {
  const imageUrl = image || "/images/app/characters/default.png"
  return (
    <div className="relative aspect-[4/5] sm:aspect-auto font-display font-bold border border-primary-700 rounded-xl overflow-hidden">
      <div className="absolute top-0 left-0 h-2/3 sm:h-full w-full sm:w-2/3 overflow-hidden">
        <Image className="object-cover" src={getImageUrl(imageUrl)} alt={character} fill={true} />
        <div className="absolute bottom-0 left-0 w-3/4 pl-4 py-2 z-10 text-base text-primary-100 bg-gradient-to-r from-black/90 to-transparent">{character}</div>
        <div className="absolute bottom-0 sm:bottom-auto sm:top-0 right-0 w-full sm:w-1/3 h-1/3 sm:h-full bg-gradient-to-t sm:bg-gradient-to-l from-black to-transparent"></div>
      </div>
      <div className="px-4 py-6 flex flex-col gap-2 text-center items-center justify-start w-full sm:w-1/2 absolute bottom-0 sm:relative sm:left-1/2">
        <h4 className="text-xs opacity-70">Dice Roll Result</h4>
        <h3 className="text-2xl">{rollType}</h3>
        <div className="font-mono text-xs text-primary-300 -mt-2 uppercase tracking-wider">
          <span className="scale-90">Target {difficulty}</span>
          {typeof baseRoll === "number" && modifier !== 0 && (
            <>
              <span className="font-bold text-white">
                {" "}
                <span className="text-white/50">|</span> {baseRoll}
              </span>
              {typeof modifier === "number" && modifier !== 0 && (
                <>
                  <span className={modifier > 0 ? "text-green-500" : "text-red-500"}>
                    {" "}
                    {modifier > 0 ? " + " : " - "}
                    {Math.abs(modifier)}
                  </span>
                </>
              )}
              {typeof modifier === "number" && modifier !== 0 ? <> </> : null}
            </>
          )}
        </div>
        <div className="flex flex-col items-center gap-1">
          <DiceRollResult result={result} />
        </div>
      </div>
    </div>
  )
}


/*
  File: components/adventure/character-dice-roll.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/character-dice-roll.tsx
  Directory: components/adventure
*/

--- File: components/adventure/character-dice-roll.tsx ---

import DiceRoll from "@/components/ui/dice-roll"
import { cn } from "@/lib/utils"
import Image from "next/image"
import { TurnCharacter } from "@/types/adventure"
import { getImageUrl } from "@/lib/utils"
import type { RollRequirement } from "@/lib/validations/roll-requirement-schema"

export default function CharacterDiceRoll({
  rollRequired,
  rollResult,
  onRoll,
  className,
  inputKey,
  character,
}: {
  rollRequired: NonNullable<RollRequirement>
  rollResult: number | null
  onRoll: (result: number) => void
  className?: string
  inputKey?: string | number
  character: TurnCharacter
}) {
  const { rollType, difficulty, modifier = 0 } = rollRequired

  console.log("[CharacterDiceRoll] rollRequired:", JSON.stringify(rollRequired, null, 2))

  return (
    <div className={cn("relative aspect-[4/5] sm:aspect-auto md:min-h-[300px] font-display font-bold border border-primary-700 rounded-xl overflow-hidden", className)}>
      <div className="absolute top-0 left-0 h-2/3 sm:h-full w-full sm:w-2/3 overflow-hidden">
        <Image className="object-cover" src={getImageUrl(character.image)} alt={character.name} fill={true} />
        <div className="absolute bottom-0 sm:bottom-auto sm:top-0 right-0 w-full sm:w-1/3 h-1/3 sm:h-full bg-gradient-to-t sm:bg-gradient-to-l from-black to-transparent"></div>
      </div>
      <div className="px-4 py-6 flex flex-col gap-4 text-center items-center justify-start w-full sm:w-1/2 absolute bottom-0 sm:relative sm:left-1/2">
        <h4 className="text-sm">Dice Roll {rollResult === null ? "Needed" : ""}</h4>
        <h3 className="text-2xl">{rollType}</h3>
        <div className="font-mono text-xs text-primary-300 -mt-4 uppercase tracking-wider">
          Target {difficulty}
          {modifier !== 0 && <span className={modifier > 0 ? "text-green-400" : "text-red-400"}>{modifier > 0 ? `  +${modifier} bonus` : `  ${modifier} penalty`}</span>}
        </div>
        <DiceRoll key={inputKey} className="my-2 scale-90 sm:scale-100" iconSize={48} id="d20-roll" {...(rollResult === null ? { onRoll } : {})} />
      </div>
    </div>
  )
}


/*
  File: components/adventure/character-roll-display.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/character-roll-display.tsx
  Directory: components/adventure
*/

--- File: components/adventure/character-roll-display.tsx ---

import Image from "next/image"

export default function CharacterRollDisplay({
  rollType,
  result,
  difficulty,
  character,
  success,
  modifier,
  baseRoll,
}: {
  rollType: string
  result: number
  difficulty: number
  character: string
  success: boolean
  modifier?: number
  baseRoll?: number
}) {
  return (
    <div
      className={`my-6 flex items-center md:min-h-[300px] gap-3 px-4 py-3 rounded-lg font-display text-base shadow-inner border-2 w-fit mx-auto
        ${success ? "bg-green-900/80 text-green-200 border-green-600" : "bg-red-900/80 text-red-200 border-red-600"}
      `}
    >
      <Image src="/images/app/dice/d20.svg" alt="Dice" width={32} height={32} className="inline-block" />
      <span className="font-bold">{character}</span>
      <span className="opacity-70">{rollType}</span>
      <span className="ml-2 font-mono text-lg">
        {typeof baseRoll === "number" ? (
          <>
            {baseRoll}
            {typeof modifier === "number" && modifier !== 0 && (
              <>
                {modifier > 0 ? " + " : " - "}
                <span className={modifier > 0 ? "text-green-400" : "text-red-400"}>{Math.abs(modifier)}</span>
                <> = </>
              </>
            )}
            {typeof modifier === "number" && modifier !== 0 ? result : null}
          </>
        ) : (
          result
        )}
      </span>
      <span className="opacity-60 text-sm">vs DC {difficulty}</span>
      {typeof modifier === "number" && modifier !== 0 && (
        <span className={modifier > 0 ? "text-green-400 ml-2" : "text-red-400 ml-2"}>{modifier > 0 ? `+${modifier} bonus` : `${modifier} penalty`}</span>
      )}
      <span className={`ml-3 px-2 py-1 rounded text-xs font-bold ${success ? "bg-green-700/80 text-green-100" : "bg-red-700/80 text-red-100"}`}>{success ? "Success" : "Failure"}</span>
    </div>
  )
}


/*
  File: components/adventure/character-selection.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/character-selection.tsx
  Directory: components/adventure
*/

--- File: components/adventure/character-selection.tsx ---

"use client"

import React, { useState } from "react"
import { Button } from "@/components/ui/button"
import { Card, CardContent } from "@/components/ui/card"
import type { AdventurePlan } from "@/types/adventure-plan"
import type { TurnCharacter } from "@/types/adventure"
import type { PCTemplate } from "@/types/character"
import Image from "next/image"
import { textShadow, textShadowSpreadLight } from "@/components/typography/styles"
import { Eye } from "lucide-react"

import { getImageUrl } from "@/lib/utils"
import PartyConfiguration from "./PartyConfiguration"
import { CharacterSheetModal } from "./character-sheet-modal"

interface CharacterSelectionProps {
  adventurePlan: AdventurePlan
  settingId: string
  adventurePlanId: string
}

export type CharacterChoiceMode = {
  characterId: string
  mode: "player" | "invite" | "ai"
}

// Convert PCTemplate to TurnCharacter format for the modal
function convertToTurnCharacter(pcTemplate: PCTemplate): TurnCharacter {
  return {
    ...pcTemplate,
    type: "pc" as const,
    userId: "", // Empty for template
    initiative: 0, // Default value
    hasReplied: false,
    isComplete: false,
  }
}

export default function CharacterSelection({ adventurePlan }: CharacterSelectionProps) {
  const [selectedCharacterId, setSelectedCharacterId] = useState<string | null>(null)
  const [characterChoices, setCharacterChoices] = useState<CharacterChoiceMode[]>([])
  const [modalCharacter, setModalCharacter] = useState<TurnCharacter | null>(null)
  const [isModalOpen, setIsModalOpen] = useState(false)

  const characterNames = Object.fromEntries(adventurePlan.premadePlayerCharacters.map((char) => [char.id, char.name]))

  // Initialize character choices when a character is selected
  React.useEffect(() => {
    if (selectedCharacterId && characterChoices.length === 0) {
      const choices: CharacterChoiceMode[] = adventurePlan.premadePlayerCharacters.map((char, index) => ({
        characterId: char.id,
        mode: index === 0 && char.id === selectedCharacterId ? "player" : "ai",
      }))
      setCharacterChoices(choices)
    }
  }, [selectedCharacterId, characterChoices.length, adventurePlan.premadePlayerCharacters])

  const handleCharacterSelect = (characterId: string) => {
    setSelectedCharacterId(characterId)
    // Reset choices and set the selected character as player, others as AI
    const choices: CharacterChoiceMode[] = adventurePlan.premadePlayerCharacters.map((char) => ({
      characterId: char.id,
      mode: char.id === characterId ? "player" : "ai",
    }))
    setCharacterChoices(choices)
  }

  const handleViewCharacterSheet = (character: PCTemplate, e: React.MouseEvent) => {
    e.stopPropagation() // Prevent character selection when clicking view details
    setModalCharacter(convertToTurnCharacter(character))
    setIsModalOpen(true)
  }

  return (
    <div
      className="min-h-screen relative"
      style={{
        backgroundImage: `url(${getImageUrl(adventurePlan.image)})`,
        backgroundSize: "cover",
        backgroundPosition: "center",
        backgroundRepeat: "no-repeat",
      }}
    >
      {/* Background overlay for better readability */}
      <div className="absolute inset-0 bg-black/60" />

      <div className="container max-w-5xl mx-auto mt-24 p-8 relative z-10">
        <div className="text-center mb-6">
          <h1 style={textShadowSpreadLight} className="text-5xl font-bold font-display mb-2 text-white">
            {adventurePlan.title}
          </h1>
          <p style={textShadow} className="max-w-2xl mx-auto pb-12 relative z-10">
            {adventurePlan.teaser}
          </p>
          <p className="font-display text-xl text-amber-300 font-bold" style={textShadow}>
            ChoosE Your characteR to BegiN
          </p>
        </div>

        <div className="grid grid-cols-1 sm:grid-cols-2 gap-6 mb-8 auto-rows-fr">
          {adventurePlan.premadePlayerCharacters.map((character) => (
            <Card
              key={character.id}
              className={`w-full h-full bg-black/80 border-white/20 scale-95 hover:scale-100 hover:bg-black/90 ring-4 ring-black transition-all duration-500 ease-in-out p-0 overflow-hidden cursor-pointer flex flex-col ${
                selectedCharacterId === character.id ? "ring-8 ring-primary-500 scale-100" : "hover:ring-8 hover:ring-primary-500"
              }`}
              onClick={() => handleCharacterSelect(character.id)}
            >
              <div className="pb-2 relative aspect-[1.25] w-full">
                {/* View Details Button */}
                <Button variant="outline" size="sm" className="absolute top-2 right-2 z-20 font-display text-sm" onClick={(e) => handleViewCharacterSheet(character, e)}>
                  <Eye className="w-4 h-4 mr-1" />
                  Details
                </Button>

                <div style={textShadow} className="absolute bottom-2 left-0 right-0 text-white w-full text-center font-display text-2xl z-10">
                  <div className="font-bold text-amber-300 pb-1">{character.name}</div>
                  <div className="text-base">
                    {character.gender} {character.race} {character.archetype}
                  </div>
                </div>
                <div className="absolute bottom-0 left-0 right-0 h-1/2 bg-gradient-to-t from-black to-transparent z-[9]" />
                {character.image && <Image src={getImageUrl(character.image)} alt={character.name} fill className="object-cover" />}
              </div>
              <CardContent className="flex-1 flex flex-col">
                <div className="relative z-10 flex-1 flex flex-col">
                  {character.background && <div className="text-gray-300 text-sm -mt-2 mb-3 flex-1 whitespace-pre-line">{character.background}</div>}
                  <div className="w-full flex justify-center pt-2 pb-8">
                    <Button variant="outline" size="lg" className="text-lg w-36">
                      {selectedCharacterId === character.id ? "Selected" : "Select"}
                    </Button>
                  </div>
                </div>
                <div className="absolute bottom-0 left-0 right-0 h-1/4 bg-gradient-to-tl from-black/50 to-transparent" />
              </CardContent>
            </Card>
          ))}
        </div>

        {selectedCharacterId && characterChoices.length > 0 && (
          <PartyConfiguration
            characterChoices={characterChoices}
            onModeChange={(characterId, mode) => {
              setCharacterChoices((prev) => prev.map((choice) => (choice.characterId === characterId ? { ...choice, mode } : choice)))
            }}
            characterNames={characterNames}
          />
        )}
      </div>

      <CharacterSheetModal character={modalCharacter} open={isModalOpen} onOpenChange={setIsModalOpen} />
    </div>
  )
}


/*
  File: components/adventure/character-sheet-modal.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/character-sheet-modal.tsx
  Directory: components/adventure
*/

--- File: components/adventure/character-sheet-modal.tsx ---

"use client"

import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog"
import { Button } from "@/components/ui/button"
import { getImageUrl } from "@/lib/utils"
import Image from "next/image"
import { useState } from "react"
import type { TurnCharacter } from "@/types/adventure"

interface CharacterSheetModalProps {
  character: TurnCharacter | null
  open: boolean
  onOpenChange: (open: boolean) => void
}

interface ExpandableTextProps {
  title: string
  text: string
}

function ExpandableText({ title, text }: ExpandableTextProps) {
  const [isExpanded, setIsExpanded] = useState(false)

  // Check if text is long enough to need truncation
  const needsTruncation = text.length > 150 // Rough estimate for when line-clamp-2 would be needed

  return (
    <div>
      <h3 className="text-lg font-display mb-2">{title}</h3>
      <div className={`text-sm text-white/90 ${!isExpanded && needsTruncation ? "line-clamp-2" : ""}`}>{text}</div>
      {needsTruncation && (
        <Button variant="ghost" size="sm" onClick={() => setIsExpanded(!isExpanded)} className="text-sm text-primary-200 hover:text-primary-100 p-0 h-auto mt-1">
          {isExpanded ? "Read less" : "Read more"}
        </Button>
      )}
    </div>
  )
}

export function CharacterSheetModal({ character, open, onOpenChange }: CharacterSheetModalProps) {
  if (!character) return null

  const getModifier = (score: number) => Math.floor((score - 10) / 2)
  const formatModifier = (modifier: number) => (modifier >= 0 ? `+${modifier}` : `${modifier}`)

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="fade-inw-full max-w-4xl sm:max-w-4xl max-h-[90vh] overflow-y-auto bg-gradient-to-br from-primary-900/95 via-primary-800/95 to-primary-900/95 border-primary-600">
        <DialogHeader>
          <DialogTitle className="sr-only">{character.name}</DialogTitle>
        </DialogHeader>

        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* Left Column - Basic Info */}
          <div className="space-y-4">
            {character.image && (
              <div className="w-full aspect-[1.33] rounded-xl bg-black border border-white/30 relative overflow-hidden mx-auto lg:mx-0">
                <Image src={getImageUrl(character.image)} alt={character.name} fill className="absolute inset-0 w-full h-full object-cover rounded-xl" />
              </div>
            )}

            <div className="space-y-2">
              <div className="text-2xl lg:text-3xl font-display text-amber-300 font-bold">{character.name}</div>
              <div className="font-display text-sm">
                {character.race} {character.gender} {character.archetype}
              </div>

              <div>
                <label className="text-xs font-mono text-primary-200 uppercase tracking-wider">Health</label>
                <div className="flex items-center gap-2">
                  <div className="">{character.healthPercent}%</div>
                  <div className="flex-1 bg-gray-700 rounded-full h-2 overflow-hidden">
                    <div className="h-full bg-gradient-to-r from-green-500 to-red-500 transition-all duration-300" style={{ width: `${character.healthPercent}%` }} />
                  </div>
                </div>
              </div>

              {character.effects && character.effects.length > 0 ? (
                <div>
                  <label className="text-xs font-mono text-primary-200 uppercase tracking-wider">Effects</label>
                  <ul>
                    {character.effects.map((effect, idx) => (
                      <li key={idx} className="mb-1">
                        <span className="font-bold">{effect.name}</span>: {effect.description} <span className="text-xs text-gray-400">({effect.duration} turns left)</span>
                      </li>
                    ))}
                  </ul>
                </div>
              ) : (
                <div className="text-sm text-gray-400">No active effects.</div>
              )}
            </div>

            {character.attributes && (
              <div>
                <h3 className="text-lg font-display  mb-3">Attributes</h3>
                <div className="grid grid-cols-3 gap-3">
                  {Object.entries(character.attributes).map(([attr, value]) => {
                    const modifier = getModifier(value)
                    return (
                      <div key={attr} className="text-center p-2 bg-black/30 rounded border border-primary-700">
                        <div className="text-xs font-mono text-primary-200 uppercase">{attr.slice(0, 3)}</div>
                        <div className="text-lg font-bold ">{value}</div>
                        <div className="text-sm text-primary-300">{formatModifier(modifier)}</div>
                      </div>
                    )
                  })}
                </div>
              </div>
            )}
          </div>

          {/* Right Column - Detailed Info */}
          <div className="space-y-4">
            {character.background && <ExpandableText title="Background" text={character.background} />}
            {character.appearance && <ExpandableText title="Appearance" text={character.appearance} />}
            {character.personality && <ExpandableText title="Personality" text={character.personality} />}
            {character.motivation && <ExpandableText title="Motivation" text={character.motivation} />}
            {character.behavior && <ExpandableText title="Behavior" text={character.behavior} />}
          </div>

          <div className="col-span-2 space-y-4">
            {character.skills && character.skills.length > 0 && (
              <div>
                <h3 className="text-lg font-display  mb-2">Skills</h3>
                <div className="flex flex-wrap gap-1">
                  {character.skills.map((skill, index) => (
                    <span key={index} className="text-xs sm:text-sm text-primary-100 px-3 py-1 bg-primary-700/50 rounded ">
                      {skill}
                    </span>
                  ))}
                </div>
              </div>
            )}

            {character.spells && character.spells.length > 0 && (
              <div>
                <h3 className="text-lg font-display  mb-2">Spells</h3>
                <div className="grid grid-cols-2 gap-2 auto-rows-fr">
                  {character.spells.map((spell, index) => (
                    <div key={index} className="h-full flex flex-col p-2 bg-black/30 rounded border border-primary-700">
                      <div className="font-medium">{spell.name}</div>
                      {spell.description && <div className="text-sm text-primary-200 mt-1 flex-1">{spell.description}</div>}
                    </div>
                  ))}
                </div>
              </div>
            )}

            {character.specialAbilities && character.specialAbilities.length > 0 && (
              <div>
                <h3 className="text-lg font-display  mb-2">Special Abilities</h3>
                <div className="grid grid-cols-2 gap-2 auto-rows-fr">
                  {character.specialAbilities.map((ability, index) => (
                    <div key={index} className="h-full flex items-start text-sm text-primary-200 p-2 bg-black/30 rounded border border-primary-700">
                      {ability}
                    </div>
                  ))}
                </div>
              </div>
            )}

            {character.equipment && character.equipment.length > 0 && (
              <div>
                <h3 className="text-lg font-display  mb-2">Equipment</h3>
                <div className="grid grid-cols-2 gap-2 auto-rows-fr">
                  {character.equipment.map((item, index) => (
                    <div key={index} className="h-full flex flex-col p-2 bg-black/30 rounded border border-primary-700">
                      <div className="font-medium">{item.name}</div>
                      {item.description && <div className="text-sm text-primary-200 mt-1 flex-1">{item.description}</div>}
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        </div>
      </DialogContent>
    </Dialog>
  )
}


/*
  File: components/adventure/dice-roll-result.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/dice-roll-result.tsx
  Directory: components/adventure
*/

--- File: components/adventure/dice-roll-result.tsx ---

"use client"
import React, { useState, useEffect } from "react"
import Image from "next/image"
import { textShadow } from "@/components/typography/styles"

export default function DiceRollResult({ result, animate }: { result: number; animate?: boolean }) {
  const [animatedResult, setAnimatedResult] = useState<number | undefined>(animate ? undefined : result)

  useEffect(() => {
    if (result && animate) {
      let timer: NodeJS.Timeout
      let currentStep = 0
      const steps = 8 // Number of steps for the animation
      const interval = 16 // Initial interval in milliseconds

      const animateResult = () => {
        if (currentStep < steps) {
          setAnimatedResult(Math.ceil(Math.random() * 20)) // Generate a random number between 1 and the die value
          currentStep++
          // Gradually increase the interval to slow down the animation
          timer = setTimeout(animateResult, interval + currentStep * 12)
        } else {
          setAnimatedResult(result) // Finally, set to the actual result
        }
      }

      animateResult()

      return () => {
        clearTimeout(timer) // Clear the timeout if the component unmounts
      }
    }
  }, [result, animate])

  const isNat20 = result === 20
  const isNat1 = result === 1

  const diceBorderColor = isNat20 ? "border-yellow-400/50" : isNat1 ? "border-red-500/50" : "border-blue-300/30"

  const diceTextColor = isNat20 ? "text-yellow-300" : isNat1 ? "text-red-400" : "text-white"

  const diceGlow = isNat20 ? "shadow-[0_0_12px_3px_rgba(250,204,21,0.4)]" : isNat1 ? "shadow-[0_0_12px_3px_rgba(220,38,38,0.4)]" : ""

  return (
    <div className="relative flex flex-col items-center justify-center">
      <div className={`w-20 h-20 flex items-center justify-center text-4xl bg-black/70 border-2 ring-8 ring-white/5 rounded-full ${diceBorderColor} ${diceGlow}`}>
        {typeof animatedResult === "number" ? <span className={`font-mono ${diceTextColor}`}>{animatedResult}</span> : <span className="font-display">~</span>}
      </div>
      <div className="-mt-2 flex justify-center w-48">
        {result && (
          <div
            style={{ boxShadow: "inset 0 -4px 16px 0 rgba(0,0,0,.5), 0 0 1px 2px #000" }}
            className={`flex gap-1.5 items-center justify-center w-32 border border-white/30 font-display rounded-full pr-4 text-lg bg-[url('/images/app/backgrounds/buried.png')] brightness-110 contrast-150 saturate-150 shadow-inner bg-blue-500`}
          >
            <div className="w-32 flex gap-1.5 items-center fade-in">
              <div style={{ boxShadow: "inset 0 2px 2px 0 rgba(0,0,0,.85)" }} className="bg-black/20 border border-white/30 h-10 w-10 rounded-full flex items-center justify-center">
                <Image src={`/images/app/dice/d20.svg`} width={36} height={36} alt="Dice Roll" />
              </div>
              <span style={textShadow}>Result</span>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}


/*
  File: components/adventure/npc-character-sheet-modal.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/npc-character-sheet-modal.tsx
  Directory: components/adventure
*/

--- File: components/adventure/npc-character-sheet-modal.tsx ---

"use client"

import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog"
import { getImageUrl } from "@/lib/utils"
import Image from "next/image"
import type { TurnCharacter } from "@/types/adventure"

interface NPCCharacterSheetModalProps {
  character: TurnCharacter | null
  open: boolean
  onOpenChange: (open: boolean) => void
}

export function NPCCharacterSheetModal({ character, open, onOpenChange }: NPCCharacterSheetModalProps) {
  if (!character) return null

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto bg-gradient-to-br from-primary-900/95 via-primary-800/95 to-primary-900/95 border-primary-600">
        <DialogHeader>
          <DialogTitle className="text-2xl font-display text-amber-300">{character.name}</DialogTitle>
        </DialogHeader>

        <div className="space-y-6">
          {/* Character Portrait and Basic Info */}
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
            {character.image && (
              <div className="w-full h-40 rounded-xl bg-black border border-white/30 relative overflow-hidden mx-auto sm:mx-0 flex-shrink-0">
                <Image src={getImageUrl(character.image)} alt={character.name} fill className="absolute inset-0 w-full h-full object-cover rounded-xl" />
              </div>
            )}

            <div className="space-y-3 flex-1">
              <div className="font-display">
                {character.race} {character.gender} {character.archetype}
              </div>

              {/* Health Status - visible condition */}
              <div>
                <label className="text-xs font-mono text-white uppercase tracking-wider">Condition</label>
                <div className="flex items-center gap-2">
                  {character.healthPercent === 0 ? (
                    <span className="text-red-400 font-bold">Dead</span>
                  ) : character.healthPercent <= 25 ? (
                    <span className="text-red-400">Severely Wounded</span>
                  ) : character.healthPercent <= 50 ? (
                    <span className="text-orange-400">Wounded</span>
                  ) : character.healthPercent <= 75 ? (
                    <span className="text-yellow-400">Bloodied</span>
                  ) : (
                    <span className="text-green-400">Healthy</span>
                  )}
                </div>
              </div>

              {character.effects && character.effects.length > 0 ? (
                <div>
                  <label className="text-xs font-mono text-white uppercase tracking-wider">Effects</label>
                  <ul>
                    {character.effects.map((effect, idx) => (
                      <li key={idx} className="mb-1">
                        <span className="font-bold">{effect.name}</span>: {effect.description} <span className="text-xs text-gray-400">({effect.duration} turns left)</span>
                      </li>
                    ))}
                  </ul>
                </div>
              ) : (
                <div className="text-sm text-gray-400">No active effects.</div>
              )}
            </div>
          </div>

          {/* Observable Information */}
          {character.appearance && (
            <div>
              <h3 className="text-lg font-display text-white mb-2">Appearance</h3>
              <p className="text-sm text-white">{character.appearance}</p>
            </div>
          )}

          {/* Visible Equipment Only */}
          {character.equipment && character.equipment.length > 0 && (
            <div>
              <h3 className="text-lg font-display text-white mb-2">Visible Equipment</h3>
              <div className="space-y-2">
                {character.equipment
                  .filter(
                    (item) =>
                      // Only show weapons, armor, and obviously visible items
                      item.name.toLowerCase().includes("sword") ||
                      item.name.toLowerCase().includes("bow") ||
                      item.name.toLowerCase().includes("staff") ||
                      item.name.toLowerCase().includes("armor") ||
                      item.name.toLowerCase().includes("shield") ||
                      item.name.toLowerCase().includes("cloak") ||
                      item.name.toLowerCase().includes("robe") ||
                      item.name.toLowerCase().includes("weapon") ||
                      item.name.toLowerCase().includes("axe") ||
                      item.name.toLowerCase().includes("hammer") ||
                      item.name.toLowerCase().includes("mace") ||
                      item.name.toLowerCase().includes("spear")
                  )
                  .map((item, index) => (
                    <div key={index} className="p-2 bg-black/30 rounded border border-primary-700">
                      <div className="font-semibold text-white">{item.name}</div>
                      {/* Only show basic descriptions for visible items */}
                      {item.description && <div className="text-xs text-primary-200 mt-1">{item.description.split(".")[0]}.</div>}
                    </div>
                  ))}
              </div>
              {character.equipment.filter(
                (item) =>
                  item.name.toLowerCase().includes("sword") ||
                  item.name.toLowerCase().includes("bow") ||
                  item.name.toLowerCase().includes("staff") ||
                  item.name.toLowerCase().includes("armor") ||
                  item.name.toLowerCase().includes("shield") ||
                  item.name.toLowerCase().includes("cloak") ||
                  item.name.toLowerCase().includes("robe") ||
                  item.name.toLowerCase().includes("weapon") ||
                  item.name.toLowerCase().includes("axe") ||
                  item.name.toLowerCase().includes("hammer") ||
                  item.name.toLowerCase().includes("mace") ||
                  item.name.toLowerCase().includes("spear")
              ).length === 0 && <p className="text-sm text-primary-200 italic">No obviously visible equipment.</p>}
            </div>
          )}

          {/* Observable Skills/Abilities */}
          {character.skills && character.skills.length > 0 && (
            <div>
              <h3 className="text-lg font-display text-white mb-2">Observable Traits</h3>
              <div className="flex flex-wrap gap-1">
                {character.skills
                  .filter(
                    (skill) =>
                      // Only show skills that would be obvious from observation
                      skill.toLowerCase().includes("intimidation") ||
                      skill.toLowerCase().includes("athletics") ||
                      skill.toLowerCase().includes("acrobatics") ||
                      skill.toLowerCase().includes("stealth") ||
                      skill.toLowerCase().includes("performance") ||
                      skill.toLowerCase().includes("persuasion") ||
                      skill.toLowerCase().includes("deception")
                  )
                  .map((skill, index) => (
                    <span key={index} className="text-xs px-2 py-1 bg-primary-700/50 rounded text-white">
                      {skill}
                    </span>
                  ))}
              </div>
            </div>
          )}

          {/* Mystery Notice */}
          <div className="p-3 bg-black/50 rounded border border-primary-600/50">
            <p className="text-xs text-primary-200 italic">This shows only what your character can observe. Hidden abilities, true motivations, and detailed statistics remain unknown.</p>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  )
}


/*
  File: components/adventure/turn-advance-button.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/turn-advance-button.tsx
  Directory: components/adventure
*/

--- File: components/adventure/turn-advance-button.tsx ---

"use client"

import React, { useState } from "react"
import { Button } from "@/components/ui/button"

interface TurnAdvanceButtonProps {
  advancing: boolean
  onAdvance: () => void
  navigationMode?: boolean
  navigationLabel?: string
}

const TurnAdvanceButton = ({ advancing, onAdvance, navigationMode = false, navigationLabel }: TurnAdvanceButtonProps) => {
  const [hasClicked, setHasClicked] = useState(false)

  return (
    <Button
      size="lg"
      variant="epic"
      disabled={advancing}
      onClick={() => {
        if (!hasClicked) {
          setHasClicked(true)
          onAdvance()
        }
      }}
    >
      {hasClicked ? (navigationMode ? "Navigating..." : "Advancing...") : navigationLabel || (navigationMode ? "Go to Next Turn" : "Go to Next Turn")}
    </Button>
  )
}

export default TurnAdvanceButton


/*
  File: components/adventure/turn-character-list.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/turn-character-list.tsx
  Directory: components/adventure
*/

--- File: components/adventure/turn-character-list.tsx ---

import { useTurn } from "@/lib/context/TurnContext"
import { cn, getImageUrl } from "@/lib/utils"
import { CircleCheckBig } from "lucide-react"
import { useState } from "react"
import Image from "next/image"
import type { TurnCharacter } from "@/types/adventure"
import { CharacterSheetModal } from "./character-sheet-modal"
import { NPCCharacterSheetModal } from "./npc-character-sheet-modal"

function CharacterImage({ src, alt }: { src: string; alt: string }) {
  const [loaded, setLoaded] = useState(false)
  return (
    <div className="w-8 sm:w-12 h-8 sm:h-12 rounded-xl bg-black border border-white/30 relative overflow-hidden z-10">
      <Image
        src={src}
        alt={alt}
        fill
        className={"absolute inset-0 w-full h-full object-cover rounded-xl transition-opacity duration-300" + (loaded ? " opacity-100" : " opacity-0")}
        onLoad={() => setLoaded(true)}
      />
    </div>
  )
}

export default function TurnCharacterList() {
  const currentTurn = useTurn()
  const characters = (currentTurn?.characters || []).slice().sort((a, b) => (b.initiative ?? 0) - (a.initiative ?? 0))

  const [selectedCharacter, setSelectedCharacter] = useState<TurnCharacter | null>(null)
  const [modalOpen, setModalOpen] = useState(false)

  // Find the current actor: highest initiative, not complete
  const currentActorId = characters.find((c) => !c.isComplete)?.id

  const handleCharacterClick = (character: TurnCharacter) => {
    setSelectedCharacter(character)
    setModalOpen(true)
  }

  return (
    <>
      <div className="lg:w-[320px] rounded-xl p-1">
        <ul className="flex flex-col gap-4">
          {characters.map((character) => {
            const isDead = character.healthPercent === 0
            return (
              <li
                key={character.id}
                className={cn(
                  "w-full max-w-[300px] sm:w-[320px] flex items-center gap-3 p-1.5 sm:p-2 relative rounded-xl transition-all duration-1000 ease-in-out bg-gradient-to-tl ring ring-primary-700 cursor-pointer hover:ring-primary-500",
                  isDead ? "ring-gray-700 from-gray-800/50 via-gray-800/50 to-gray-700/50 opacity-60" : character.isComplete ? "ring-primary-600" : "from-primary-800 via-primary-800 to-primary-700",
                  character.id === currentActorId && !isDead ? "scale-100 shadow-md ring-primary-600 ring-2 from-primary-900" : "scale-90 from-primary-800/70 via-primary-800/70 opacity-90",
                  isDead && "opacity-50 scale-90" // Ensure dead characters are visually distinct
                )}
                onClick={() => handleCharacterClick(character)}
              >
                {character.image && <CharacterImage src={getImageUrl(character.image)} alt={character.name} />}
                <div className="z-10">
                  <div className="text-xxs sm:text-sm font-bold font-display flex items-center gap-2">
                    {character.name}
                    {character.isComplete && !isDead && <CircleCheckBig className="absolute bottom-1.5 right-1.5 inline-block text-green-700 w-4 h-4 rounded-full bg-black ring-2 ring-black" />}
                  </div>
                  {character.archetype !== "Monster" && (
                    <div className="text-xxxs sm:text-xxs font-display">
                      {character.gender} {character.race} {character.archetype}
                    </div>
                  )}

                  {characters.length > 1 && !isDead && (
                    <div className="text-base flex items-center justify-center rounded-full bg-black ring ring-primary-600 w-8 h-8 font-mono absolute top-4 -left-5">{character.initiative}</div>
                  )}
                </div>
                {character.effects && character.effects.length > 0 ? (
                  <div className="absolute top-2 right-8 z-10 bg-primary-100 text-primary-700 px-2 py-1 rounded text-xs">
                    {character.effects.map((effect, idx) => (
                      <span key={idx} className="mr-2">
                        <span className="font-bold">{effect.name}</span> ({effect.duration})
                      </span>
                    ))}
                  </div>
                ) : null}
                {isDead && <div className="text-xxs sm:text-xs text-red-400 font-bold font-mono px-2 py-0.5 bg-black rounded absolute -bottom-2 ring ring-red-700 right-8 z-10">DEAD</div>}
                {!isDead && (
                  <div className="absolute top-0 left-0 w-full h-full rounded-xl overflow-hidden">
                    <div
                      className="absolute top-0 left-0 w-full h-full bg-red-800 transition-all duration-1000 ease-in-out"
                      style={{ width: `${100 - character.healthPercent}%`, opacity: (100 - character.healthPercent) / 100 }}
                    />
                  </div>
                )}
              </li>
            )
          })}
        </ul>
      </div>

      {/* Show appropriate modal based on character type */}
      {selectedCharacter?.type === "pc" ? (
        <CharacterSheetModal character={selectedCharacter} open={modalOpen} onOpenChange={setModalOpen} />
      ) : (
        <NPCCharacterSheetModal character={selectedCharacter} open={modalOpen} onOpenChange={setModalOpen} />
      )}
    </>
  )
}


/*
  File: components/adventure/turn-narrative-reply.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/turn-narrative-reply.tsx
  Directory: components/adventure
*/

--- File: components/adventure/turn-narrative-reply.tsx ---

"use client"
import React from "react"
import { useAdventure } from "@/lib/context/AdventureContext"
import { SignedIn, SignedOut, SignUpButton, useUser } from "@clerk/nextjs"
import { useTurn } from "@/lib/context/TurnContext"
import { useState } from "react"
import { useRouter } from "next/navigation"
import { Textarea } from "@/components/ui/textarea"
import { Button } from "@/components/ui/button"
import type { TurnCharacter } from "@/types/adventure"
import type { Id } from "@/convex/_generated/dataModel"
import CharacterDiceRoll from "@/components/adventure/character-dice-roll"
import LoadingAnimation from "../ui/loading-animation"
import { hasBooleanProp, hasNumberProp } from "@/lib/utils"
import { formatNarrativeAction } from "@/lib/services/narrative-service"
import { resolvePlayerRollResult } from "@/app/_actions/adventure"
import { createAdventureWithFirstTurn } from "@/app/_actions/adventure"

type TurnNarrativeReplyProps = {
  character: TurnCharacter
  submitReply?: (args: { turnId: string | Id<"turns">; characterId: string; narrativeAction: string }) => Promise<unknown>
}

export default function TurnNarrativeReply({ character, submitReply }: TurnNarrativeReplyProps) {
  const [input, setInput] = useState("")
  const [loading, setLoading] = useState(false)
  const [hasSubmitted, setHasSubmitted] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const router = useRouter()
  const { user } = useUser()
  const currentTurn = useTurn()
  const { settingId, adventurePlanId, adventure } = useAdventure()

  if (!currentTurn) {
    return null
  }

  const characterState = currentTurn.characters.find((c: { id: string }) => c.id === character.id) as TurnCharacter | undefined
  const isComplete = hasBooleanProp(characterState, "isComplete") ? characterState.isComplete : undefined
  const rollResult = hasNumberProp(characterState, "rollResult") ? characterState.rollResult : null
  if (isComplete) return null

  const handleDemoReply = async () => {
    if (!user || !user.id || !currentTurn) return
    const userId = user.id
    let narrativeAction = input.trim()
    setError(null)
    try {
      if (character) {
        const paragraphs = (currentTurn.narrative || "").split(/\\n\\n+/).filter(Boolean)
        const narrativeContext = paragraphs.slice(-2).join("\\n\\n")
        narrativeAction = await formatNarrativeAction({
          characterName: character.name,
          playerInput: input,
          narrativeContext,
        })
      }
      const prev = currentTurn.narrative || ""
      const newNarrative = prev ? `${prev}\\n\\n${narrativeAction}` : narrativeAction
      const payload = {
        planId: adventurePlanId,
        settingId,
        title: adventure.title,
        ownerId: userId,
        playerIds: [userId],
        startedAt: Date.now(),
        playerInput: input,
        turn: {
          encounterId: currentTurn.encounterId,
          narrative: newNarrative,
          characters: (currentTurn.characters as TurnCharacter[]).map((c) => ({
            ...c,
            hasReplied: c.id === character.id,
            isComplete: c.id === character.id,
            rollRequired: undefined,
            rollResult: undefined,
          })),
          order: 0,
        },
      }
      console.log("[handleDemoReply] Calling createAdventureWithFirstTurn with payload:", JSON.stringify(payload, null, 2))
      setHasSubmitted(true)
      const res = await createAdventureWithFirstTurn(payload)
      console.log("[handleDemoReply] createAdventureWithFirstTurn result:", JSON.stringify(res, null, 2))
      if (res && res.adventureId) {
        console.log("[handleDemoReply] Navigating to new adventure:", `/${settingId}/${adventurePlanId}/${res.adventureId}`)
        router.push(`/${settingId}/${adventurePlanId}/${res.adventureId}`, { scroll: false })
        return
      }
    } catch (err) {
      console.error("[handleDemoReply] Error calling createAdventureWithFirstTurn:", err)
      setError(err instanceof Error ? err.message : "Failed to create adventure. Please try again.")
      setLoading(false)
    }
  }

  const handleCharacterReply = async () => {
    if (!currentTurn || !currentTurn.id || !submitReply) return
    setError(null)
    try {
      const paragraphs = (currentTurn.narrative || "").split(/\\n\\n+/).filter(Boolean)
      const narrativeContext = paragraphs.slice(-2).join("\\n\\n")
      const aiResult = await formatNarrativeAction({
        characterName: character.name,
        playerInput: input,
        narrativeContext,
      })
      console.log("[handleCharacterReply] aiResult:", JSON.stringify(aiResult, null, 2))
      if (typeof aiResult !== "string") {
        console.error("[handleCharacterReply] aiResult is not a string:", aiResult)
        setError("Failed to format reply. Please try again.")
        setLoading(false)
        return
      }
      if (typeof currentTurn.id !== "string") {
        console.error("[handleCharacterReply] currentTurn.id is not a string:", currentTurn.id)
        setError("Invalid turn ID. Please try again.")
        setLoading(false)
        return
      }
      setHasSubmitted(true)
      await submitReply({
        turnId: currentTurn.id,
        characterId: character.id,
        narrativeAction: aiResult,
      })
    } catch (err) {
      console.error("[handleCharacterReply] Error:", err)
      setError(err instanceof Error ? err.message : "Failed to submit reply. Please try again.")
      setLoading(false)
    }
  }

  const handleReply = async (e?: React.FormEvent) => {
    console.log("[handleReply] FUNCTION CALLED with input:", input)
    if (e) e.preventDefault()
    if (!input.trim()) return
    setLoading(true)
    setError(null)
    const isDemoTurn = currentTurn && currentTurn.id.includes("demo")
    try {
      if (isDemoTurn) {
        await handleDemoReply()
      } else {
        await handleCharacterReply()
      }
    } catch (err) {
      console.error("[handleReply] Error:", err)
      if (!error) {
        setError(err instanceof Error ? err.message : "An unexpected error occurred. Please try again.")
      }
    } finally {
      setLoading(false)
    }
  }

  const handleInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setInput(e.target.value)
    setError(null)
  }

  const handleRollResult = async (result: number) => {
    console.log("[handleRollResult] FUNCTION CALLED with result:", result)
    let turnId: Id<"turns"> | undefined = undefined
    if (currentTurn && typeof currentTurn.id === "string") {
      turnId = currentTurn.id as Id<"turns">
    }
    console.log("[handleRollResult] Computed turnId:", turnId)
    if (!turnId) {
      console.log("[handleRollResult] No turnId found, aborting.")
      setError("Cannot process roll: current turn ID is missing.")
      return
    }
    setLoading(true)
    setError(null)
    try {
      await resolvePlayerRollResult({
        turnId,
        characterId: character.id,
        result,
      })
    } catch (err) {
      console.error("[handleRollResult] Error in resolvePlayerRollResult:", err)
      if (err instanceof Error && err.message.includes("Insufficient tokens")) {
        setError("You do not have enough tokens to perform this action. Please add more tokens to your account.")
      } else if (err instanceof Error) {
        setError(err.message)
      } else {
        setError("Failed to process roll result. Please try again.")
      }
    } finally {
      setInput("")
      setLoading(false)
    }
  }

  const showDiceRoll = characterState?.rollRequired && rollResult == null

  return (
    <form onSubmit={handleReply} className="flex flex-col gap-4 min-h-[100px]">
      {!loading && !hasSubmitted && !showDiceRoll && (
        <>
          <Textarea className="text-lg border-white/30" value={input} onChange={handleInputChange} placeholder="Write your character's actions and dialogue here, in the third person..." />
          {error && <p className="text-sm text-red-500 mt-2">{error}</p>}
          <div className="flex justify-end mt-2">
            <SignedIn>
              <Button type="submit" disabled={!input.trim()} variant="epic" size="lg">
                Send Reply
              </Button>
            </SignedIn>
            <SignedOut>
              <SignUpButton mode="modal">
                <Button className="tracking-normal" variant="epic" size="lg">
                  Sign Up to Reply
                </Button>
              </SignUpButton>
            </SignedOut>
          </div>
        </>
      )}
      {showDiceRoll && characterState?.rollRequired && (
        <CharacterDiceRoll character={characterState as TurnCharacter} rollRequired={characterState.rollRequired} rollResult={rollResult ?? null} onRoll={handleRollResult} inputKey={input} />
      )}
      {loading && <LoadingAnimation />}
    </form>
  )
}


/*
  File: components/adventure/turn-narrative.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/turn-narrative.tsx
  Directory: components/adventure
*/

--- File: components/adventure/turn-narrative.tsx ---

"use client"

import { useEffect } from "react"
import { useTurnContext } from "@/lib/context/TurnContext"
import TurnNarrativeReply from "./turn-narrative-reply"
import { parseNarrative } from "@/lib/utils/parse-narrative"
import CharacterDiceRollResultDisplay from "@/components/adventure/character-dice-roll-result-display"
import type { TurnCharacter } from "@/types/adventure"
import type { Id } from "@/convex/_generated/dataModel"
import { advanceTurn } from "@/app/_actions/advance-turn"
import React from "react"
import TurnAdvanceButton from "@/components/adventure/turn-advance-button"
import { processTurnReply } from "@/app/_actions/adventure"
import { useAdventure } from "@/lib/context/AdventureContext"
import LoadingAnimation from "../ui/loading-animation"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { AlertTriangle } from "lucide-react"
import { scrollToBottom } from "../ui/utils"
import { useParams, useRouter } from "next/navigation"
import { useUser } from "@clerk/nextjs"
import { Button } from "@/components/ui/button"
import Link from "next/link"
import { cn } from "@/lib/utils"

export default function TurnNarrative() {
  const params = useParams()
  const router = useRouter()
  const { currentTurn, disableSSE } = useTurnContext()
  const { settingId, adventurePlanId } = useAdventure()
  const { isSignedIn, user } = useUser()
  const [advancing, setAdvancing] = React.useState(false)
  const [initialNarrative, setInitialNarrative] = React.useState("")
  const [tokenError, setTokenError] = React.useState<string | null>(null)

  useEffect(() => {
    // scroll to bottom of page when currentTurn.narrative changes after the first render
    if (currentTurn?.narrative) {
      if (!initialNarrative) {
        setInitialNarrative(currentTurn.narrative)
      } else if (initialNarrative !== currentTurn.narrative && !disableSSE) {
        scrollToBottom()
      }
    }
  }, [currentTurn?.narrative, disableSSE, initialNarrative])

  const isTurnComplete = currentTurn?.characters.every((c: TurnCharacter) => c.isComplete)

  if (!currentTurn) {
    console.log("[TurnNarrative] currentTurn is null, returning null")
    return null
  }

  // Sort characters by initiative (highest first) and find the current actor
  const charactersByInitiative = (currentTurn?.characters || []).slice().sort((a, b) => (b.initiative ?? 0) - (a.initiative ?? 0))

  // Find the current actor: highest initiative, not complete
  const currentCharacter = charactersByInitiative.find((c: TurnCharacter) => !c.isComplete)

  // Check if we're waiting for an NPC to process their turn
  const isNpcProcessing = currentCharacter && currentCharacter.type === "npc" && !currentCharacter.hasReplied

  const parsed = parseNarrative(currentTurn?.narrative || "")

  const shouldShowReplyCondition =
    currentTurn && !currentTurn.isFinalEncounter && currentCharacter && currentCharacter.type === "pc" && currentCharacter.userId === user?.id && !isNpcProcessing && !disableSSE

  // Find the player's character and check if their turn is complete
  const playerCharacter = currentTurn?.characters.find((c: TurnCharacter) => c.type === "pc" && c.userId === user?.id)
  const isPlayerTurnComplete = playerCharacter?.isComplete

  const handleAdvanceOrNavigate = async () => {
    console.log("[handleAdvanceOrNavigate] CALLED", { disableSSE, action: disableSSE ? "navigate" : "advance" })
    if (disableSSE) {
      // Navigation mode: just go to the next turn
      const currentTurnOrder = params.turnOrder ? parseInt(params.turnOrder as string, 10) : 1
      const nextTurnOrder = currentTurnOrder + 1
      const basePath = `/settings/${settingId}/${adventurePlanId}/${params.adventureId}`

      console.log("[TurnNarrative] Navigating to next turn:", `${basePath}/${nextTurnOrder}`)
      setAdvancing(true)
      router.push(`${basePath}/${nextTurnOrder}`)
      // Reset advancing state after a delay since navigation doesn't complete immediately
      setTimeout(() => setAdvancing(false), 1000)
    } else {
      setAdvancing(true)
      setTokenError(null) // Clear previous errors
      try {
        const result = await advanceTurn({ turnId: currentTurn?.id as Id<"turns">, settingId, adventurePlanId })
        console.log("[advanceTurn] result:", JSON.stringify(result, null, 2))

        // Navigate to the new turn URL after successful advancement
        if (result.status === "turn_advanced") {
          const currentTurnOrder = params.turnOrder ? parseInt(params.turnOrder as string, 10) : 1
          const newTurnOrder = currentTurnOrder + 1
          const basePath = `/settings/${settingId}/${adventurePlanId}/${params.adventureId}`
          router.replace(`${basePath}/${newTurnOrder}`, { scroll: false })
        }
      } catch (error) {
        console.error("[TurnNarrative] Error advancing turn:", error)
        if (error instanceof Error && error.message.includes("Insufficient tokens")) {
          setTokenError("You do not have enough tokens to perform this action. Please add more tokens to your account.")
        } else {
          setTokenError("An unexpected error occurred while advancing the turn. Please try again.")
        }
      } finally {
        setAdvancing(false)
      }
    }
  }

  return (
    <div className="grow max-w-2xl fade-in">
      {tokenError && (
        <Alert variant="destructive" className="mb-8">
          <AlertTriangle className="h-4 w-4" />
          <AlertTitle>Action Failed</AlertTitle>
          <AlertDescription>{tokenError}</AlertDescription>
        </Alert>
      )}
      {shouldShowReplyCondition && (
        <div className="fade-in flex justify-between items-center gap-4 px-4 h-14 -mt-18 mb-4 bg-black/70 rounded-lg border border-white/20">
          <p className="italic text-sm pl-2 font-bold text-amber-300">It is your turn!</p>
          <Button variant="outline" size="sm" className="text-xs" onClick={() => scrollToBottom()}>
            Go To Reply
          </Button>
        </div>
      )}
      {parsed.map((part, idx) => {
        if (part.type === "paragraph") {
          return (
            <p key={idx} className="text-sm sm:text-base md:text-lg whitespace-pre-line mb-4">
              {part.value}
            </p>
          )
        } else {
          // Use a more unique key if available, otherwise fallback to idx
          const key = part.character ? `${part.character}-${part.rollType}-${part.result}-${part.difficulty}` : idx
          return (
            <div className="pb-6" key={key}>
              <CharacterDiceRollResultDisplay
                character={part.character}
                rollType={part.rollType}
                difficulty={part.difficulty}
                result={part.result}
                image={part.image}
                modifier={part.modifier}
                baseRoll={part.baseRoll}
              />
            </div>
          )
        }
      })}

      {/* Show loading animation if an NPC is processing their turn */}
      {isNpcProcessing && !currentTurn?.isFinalEncounter && !disableSSE && (
        <div className="flex flex-col items-center gap-4 py-8">
          <LoadingAnimation />
          <p className="text-indigo-300 font-display">{currentCharacter.name} is rolling…</p>
        </div>
      )}

      {/* Show reply form only if current character is a PC and not in historical mode */}
      {shouldShowReplyCondition ? (
        <TurnNarrativeReply
          character={currentCharacter!}
          submitReply={async ({ turnId, characterId, narrativeAction }) => {
            setTokenError(null) // Clear previous errors
            try {
              // Cast turnId to Id<'turns'>
              console.log("[TurnNarrative] processTurnReply called with:", JSON.stringify({ turnId, characterId, narrativeAction }, null, 2))
              const result = await processTurnReply({ turnId: turnId as Id<"turns">, characterId, narrativeAction })
              console.log("[TurnNarrative] processTurnReply result:", JSON.stringify(result, null, 2))
              // If the action was implausible, set the feedback as a tokenError to display it.
              if (result?.actionImplausible && result.feedback) {
                setTokenError(result.feedback)
                // Potentially return a different structure or throw an error to prevent further processing in TurnNarrativeReply
                return result // Or throw new Error(result.feedback) if TurnNarrativeReply should stop hard.
              }
              return result
            } catch (error) {
              console.error("[TurnNarrative] Error processing turn reply:", error)
              if (error instanceof Error && error.message.includes("Insufficient tokens")) {
                setTokenError("You do not have enough tokens to perform this action. Please add more tokens to your account.")
              } else if (error instanceof Error) {
                // Handle other specific errors from processTurnReply if needed
                setTokenError(error.message) // Display the error message from the caught error
              } else {
                setTokenError("An unexpected error occurred while processing your action. Please try again.")
              }
              // When an error occurs, you might want to throw it or return a specific structure
              // to let TurnNarrativeReply know that the submission failed.
              // For now, it will fall through and TurnNarrativeReply might proceed as if successful depending on its logic.
              // Consider throwing the error to be caught by TurnNarrativeReply's own error handling if it has one.
              throw error // Re-throw the error so TurnNarrativeReply can also handle it if needed
            }
          }}
        />
      ) : (
        <div
          id="turn-indicator"
          className={cn(
            "flex flex-col gap-2 justify-center border mt-4 border-white/20 items-center p-8 rounded-lg",
            isPlayerTurnComplete ? "bg-neutral-900" : "bg-primary-800/70 border-dashed",
            isTurnComplete && "hidden"
          )}
        >
          <h4 className={cn("text-xl font-display", isPlayerTurnComplete ? "text-green-300/70" : "text-primary-200")}>{isPlayerTurnComplete ? "Your Turn is Complete" : "Waiting for Your Turn"}</h4>
          <div className="flex gap-3 mt-3 mb-4 scale-75">
            <span className={cn("w-2 h-2 rounded-full animate-pulse", isPlayerTurnComplete ? "bg-neutral-600" : "bg-primary-200")} style={{ animationDelay: "0ms", animationDuration: "2s" }}></span>
            <span className={cn("w-2 h-2 rounded-full animate-pulse", isPlayerTurnComplete ? "bg-neutral-600" : "bg-primary-200")} style={{ animationDelay: "200ms", animationDuration: "2s" }}></span>
            <span className={cn("w-2 h-2 rounded-full animate-pulse", isPlayerTurnComplete ? "bg-neutral-600" : "bg-primary-200")} style={{ animationDelay: "400ms", animationDuration: "2s" }}></span>
          </div>
          <p className="italic text-white/70">It is currently {currentCharacter?.name}’s turn</p>
        </div>
      )}

      {currentTurn?.isFinalEncounter && (
        <div className="flex flex-col items-center justify-center mt-8 md:mt-16 text-center px-4 py-8 md:py-16 border-double border-8 border-primary-800 rounded-lg">
          <p className="text-primary-300 text-lg font-display font-bold mb-6">You’ve reached the end of the journey for this adventure</p>
          {isSignedIn && (
            <Button size="sm" asChild variant="epic">
              <Link href={`/${settingId}/${adventurePlanId}`}>Play Again</Link>
            </Button>
          )}
        </div>
      )}
      {isTurnComplete && !currentTurn?.isFinalEncounter && (
        <div className="flex justify-center mt-8">
          <TurnAdvanceButton advancing={advancing} navigationMode={disableSSE} navigationLabel={disableSSE ? "Go to Next Turn" : undefined} onAdvance={handleAdvanceOrNavigate} />
        </div>
      )}
    </div>
  )
}


/*
  File: components/adventure/turn-navigation.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/turn-navigation.tsx
  Directory: components/adventure
*/

--- File: components/adventure/turn-navigation.tsx ---

"use client"

import { useParams } from "next/navigation"
import { ChevronFirst, ChevronLast } from "lucide-react"
import { Pagination, PaginationContent, PaginationItem, PaginationLink, PaginationPrevious, PaginationNext, PaginationEllipsis } from "@/components/ui/pagination"

interface TurnNavigationProps {
  currentTurnOrder: number
  totalTurns: number
  isLatestTurn: boolean
}

export default function TurnNavigation({ currentTurnOrder, totalTurns, isLatestTurn }: TurnNavigationProps) {
  const params = useParams()
  const { settingId, adventurePlanId, adventureId } = params

  const basePath = `/settings/${settingId}/${adventurePlanId}/${adventureId}`

  // currentTurnOrder is already the 1-based pagination number from URL
  const currentPaginationNumber = currentTurnOrder
  const hasPrevious = currentPaginationNumber > 1
  const hasNext = currentPaginationNumber < totalTurns
  const isFirstTurn = currentPaginationNumber === 1

  // Generate turn numbers to show (current +/- 2) - using 1-based pagination numbers
  const generateTurnNumbers = () => {
    const numbers = []
    const start = Math.max(1, currentPaginationNumber - 2)
    const end = Math.min(totalTurns, currentPaginationNumber + 2)

    // Add first turn if not in range
    if (start > 1) {
      numbers.push(1)
      if (start > 2) {
        numbers.push("ellipsis")
      }
    }

    // Add range around current turn
    for (let i = start; i <= end; i++) {
      numbers.push(i)
    }

    // Add last turn if not in range
    if (end < totalTurns) {
      if (end < totalTurns - 1) {
        numbers.push("ellipsis")
      }
      numbers.push(totalTurns)
    }

    return numbers
  }

  const turnNumbers = generateTurnNumbers()

  return (
    <div className="flex flex-col items-center gap-2 scale-90">
      <Pagination>
        <PaginationContent>
          {/* First Turn Button */}
          <PaginationItem>
            {!isFirstTurn ? (
              <PaginationLink href={`${basePath}/1`} aria-label="Go to first turn" className="gap-1 px-1.5">
                <ChevronFirst className="h-4 w-4" />
              </PaginationLink>
            ) : (
              <PaginationLink aria-label="Go to first turn" className="gap-1 px-1.5 pointer-events-none opacity-50">
                <ChevronFirst className="h-4 w-4" />
              </PaginationLink>
            )}
          </PaginationItem>

          {/* Previous Button */}
          <PaginationItem className="flex items-center justify-center px-0">
            {hasPrevious ? <PaginationPrevious href={`${basePath}/${currentPaginationNumber - 1}`} /> : <PaginationPrevious className="pointer-events-none opacity-50 px-0" />}
          </PaginationItem>

          {/* Turn Numbers */}
          {turnNumbers.map((turn, index) => (
            <PaginationItem key={index}>
              {turn === "ellipsis" ? (
                <PaginationEllipsis />
              ) : (
                <PaginationLink href={`${basePath}/${turn}`} isActive={turn === currentPaginationNumber}>
                  {turn}
                </PaginationLink>
              )}
            </PaginationItem>
          ))}

          {/* Next Button */}
          <PaginationItem>{hasNext ? <PaginationNext href={`${basePath}/${currentPaginationNumber + 1}`} /> : <PaginationNext className="pointer-events-none opacity-50" />}</PaginationItem>

          {/* Latest Turn Button */}
          <PaginationItem>
            {!isLatestTurn ? (
              <PaginationLink href={basePath} aria-label="Go to latest turn" className="gap-1 px-1.5">
                <ChevronLast className="h-4 w-4" />
              </PaginationLink>
            ) : (
              <PaginationLink aria-label="Go to latest turn" className="gap-1 px-1.5 pointer-events-none opacity-50">
                <ChevronLast className="h-4 w-4" />
              </PaginationLink>
            )}
          </PaginationItem>
        </PaginationContent>
      </Pagination>
    </div>
  )
}


/*
  File: components/adventure/turn.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure/turn.tsx
  Directory: components/adventure
*/

--- File: components/adventure/turn.tsx ---

import TurnCharacterList from "./turn-character-list"
import TurnNarrative from "./turn-narrative"

export default function Turn() {
  return (
    <div className="flex flex-col lg:flex-row gap-4 lg:gap-8 relative pb-24 px-8">
      <TurnCharacterList />
      <TurnNarrative />
    </div>
  )
}


/*
  File: components/adventure-plans/adventure-plan-basic-info.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure-plans/adventure-plan-basic-info.tsx
  Directory: components/adventure-plans
*/

--- File: components/adventure-plans/adventure-plan-basic-info.tsx ---

"use client"

import { Textarea } from "@/components/ui/textarea"
import { Input } from "@/components/ui/input"
import { ImageUpload } from "@/components/ui/image-upload"

interface AdventurePlanBasicInfoProps {
  adventurePlanId: string
  settingId: string
  image: string
  teaser: string
  overview: string
  minPartySize: number
  maxPartySize: number
  isSaving: boolean
  onImageChange: (url: string) => void
  onImageRemove: () => void
  onTeaserChange: (teaser: string) => void
  onOverviewChange: (overview: string) => void
  onMinPartySizeChange: (size: number) => void
  onMaxPartySizeChange: (size: number) => void
}

export function AdventurePlanBasicInfo({
  adventurePlanId,
  settingId,
  image,
  teaser,
  overview,
  minPartySize,
  maxPartySize,
  isSaving,
  onImageChange,
  onImageRemove,
  onTeaserChange,
  onOverviewChange,
  onMinPartySizeChange,
  onMaxPartySizeChange,
}: AdventurePlanBasicInfoProps) {
  const imageUploadFolder = `images/settings/${settingId}/${adventurePlanId}`

  return (
    <>
      <div className="grid grid-cols-2 gap-8 pb-4" id="adventure-plan-main-top">
        <div>
          <label htmlFor="adventureImage" className="block text-sm font-medium font-mono text-primary-200/90 mb-1">
            Cover Image
          </label>
          <ImageUpload id="adventureImage" value={image} onChange={onImageChange} onRemove={onImageRemove} folder={imageUploadFolder} />
        </div>
        <div className="flex flex-col gap-4">
          <div>
            <label htmlFor="teaser" className="block text-sm font-medium font-mono text-primary-200/90 mb-1">
              Teaser
            </label>
            <Textarea id="teaser" value={teaser} onChange={(e) => onTeaserChange(e.target.value)} placeholder="A short, enticing teaser for the adventure..." rows={3} disabled={isSaving} />
          </div>
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label htmlFor="minPartySize" className="block text-sm font-medium font-mono text-primary-200/90 mb-1">
                Min Party Size
              </label>
              <Input
                id="minPartySize"
                type="number"
                value={minPartySize}
                onChange={(e) => onMinPartySizeChange(parseInt(e.target.value, 10) || 0)}
                placeholder="Minimum party size"
                disabled={isSaving}
                min={1}
              />
            </div>
            <div>
              <label htmlFor="maxPartySize" className="block text-sm font-medium font-mono text-primary-200/90 mb-1">
                Max Party Size
              </label>
              <Input
                id="maxPartySize"
                type="number"
                value={maxPartySize}
                onChange={(e) => onMaxPartySizeChange(parseInt(e.target.value, 10) || 0)}
                placeholder="Maximum party size"
                disabled={isSaving}
                min={minPartySize || 1}
              />
            </div>
          </div>
        </div>
      </div>

      <div>
        <label htmlFor="overview" className="block text-sm font-medium font-mono text-primary-200/90 mb-1">
          Overview
        </label>
        <Textarea id="overview" value={overview} onChange={(e) => onOverviewChange(e.target.value)} placeholder="A broader overview of the adventure plan..." rows={6} disabled={isSaving} />
      </div>
    </>
  )
}


/*
  File: components/adventure-plans/adventure-plan-characters-edit.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure-plans/adventure-plan-characters-edit.tsx
  Directory: components/adventure-plans
*/

--- File: components/adventure-plans/adventure-plan-characters-edit.tsx ---

"use client"

import * as React from "react"
import { Button } from "@/components/ui/button"
import { Plus } from "lucide-react"
import type { Character, PCTemplate } from "@/types/character"
import { useCharacterManagement } from "@/components/adventure-plans/hooks/use-character-management"
import { CharacterGenerateForm } from "@/components/adventure-plans/character-generate-form"
import { CharacterCard } from "@/components/adventure-plans/character-card"

interface AdventurePlanCharactersEditProps {
  id: string
  type: "npcs" | "premadePlayerCharacters"
  characters: Record<string, Character> | PCTemplate[]
  onCharactersChange: (characters: Record<string, Character> | PCTemplate[]) => void
  isSaving: boolean
  adventurePlanId: string
  settingId: string
}

export function AdventurePlanCharactersEdit({ id, type, characters, onCharactersChange, isSaving, adventurePlanId, settingId }: AdventurePlanCharactersEditProps) {
  const [showGenerateForm, setShowGenerateForm] = React.useState(false)
  const [editingCharacters, setEditingCharacters] = React.useState<Set<string>>(new Set())

  const { isNpcs, charactersArray, addNewCharacter, updateCharacter, removeCharacter, getCharacter } = useCharacterManagement(type, characters, onCharactersChange)

  const toggleEditMode = (charId: string) => {
    setEditingCharacters((prev) => {
      const newSet = new Set(prev)
      if (newSet.has(charId)) {
        newSet.delete(charId)
      } else {
        newSet.add(charId)
      }
      return newSet
    })
  }

  const isEditing = (charId: string) => editingCharacters.has(charId)

  const handleRemoveCharacter = (charId: string) => {
    removeCharacter(charId)
    setEditingCharacters((prev) => {
      const newSet = new Set(prev)
      newSet.delete(charId)
      return newSet
    })
  }

  const title = isNpcs ? "NPCs" : "Premade Player Characters"
  const buttonText = isNpcs ? "Add NPC" : "Add PC"
  const generateButtonText = isNpcs ? "Generate NPC" : "Generate PC"
  const emptyText = isNpcs ? "No NPCs added yet." : "No premade player characters added yet."

  return (
    <div id={id} className="border-t border-white/20 pt-8 mt-8 w-full flex flex-col gap-4 scroll-mt-20">
      <div className="flex items-center justify-between">
        <h4 className="font-display opacity-70 text-lg text-indigo-300 font-bold tracking-wide">{title}</h4>
        <div className="flex items-center gap-2">
          <Button onClick={() => setShowGenerateForm(!showGenerateForm)} disabled={isSaving} size="sm" variant="outline" className="flex items-center gap-2 hover:scale-100">
            <Plus size={16} />
            {generateButtonText}
          </Button>
          <Button onClick={addNewCharacter} disabled={isSaving} size="sm" variant="outline" className="flex items-center gap-2 hover:scale-100">
            <Plus size={16} />
            {buttonText}
          </Button>
        </div>
      </div>

      {showGenerateForm && <CharacterGenerateForm type={type} characters={characters} onCharactersChange={onCharactersChange} onClose={() => setShowGenerateForm(false)} />}

      {charactersArray.length === 0 && <p className="text-sm text-gray-400 italic text-center py-8">{emptyText}</p>}

      <div className="space-y-4">
        {charactersArray.map(([charKey, charData], index) => {
          const char = charData as Character | PCTemplate
          const charId = isNpcs ? charKey : index.toString()
          const uniqueKey = isNpcs ? charKey : `pc-${index}`
          const editing = isEditing(charId)

          return (
            <CharacterCard
              key={uniqueKey}
              charId={charId}
              char={char}
              isNpcs={isNpcs}
              isSaving={isSaving}
              settingId={settingId}
              adventurePlanId={adventurePlanId}
              uniqueKey={uniqueKey}
              editing={editing}
              onToggleEdit={() => toggleEditMode(charId)}
              onRemove={() => handleRemoveCharacter(charId)}
              updateCharacter={updateCharacter}
              getCharacter={getCharacter}
            />
          )
        })}
      </div>
    </div>
  )
}


/*
  File: components/adventure-plans/adventure-plan-edit-form.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure-plans/adventure-plan-edit-form.tsx
  Directory: components/adventure-plans
*/

--- File: components/adventure-plans/adventure-plan-edit-form.tsx ---

"use client"

import * as React from "react"
import { AdventurePlan } from "@/types/adventure-plan"
import type { Character, PCTemplate } from "@/types/character"
import { Button } from "@/components/ui/button"
import { AdventurePlanCharactersEdit } from "@/components/adventure-plans/adventure-plan-characters-edit"
import { AdventurePlanEditSidebar } from "@/components/adventure-plans/adventure-plan-edit-sidebar"
import { AdventurePlanFormHeader } from "@/components/adventure-plans/adventure-plan-form-header"
import { AdventurePlanBasicInfo } from "@/components/adventure-plans/adventure-plan-basic-info"
import { AdventurePlanSections } from "@/components/adventure-plans/adventure-plan-sections"
import { useAdventurePlanForm } from "@/components/adventure-plans/hooks/use-adventure-plan-form"
import { useAdventureSections } from "@/components/adventure-plans/hooks/use-adventure-sections"
import { useEncounterHandlers } from "@/components/adventure-plans/hooks/use-encounter-handlers"
import { toast } from "sonner"

export function AdventurePlanEditForm({ adventurePlan }: { adventurePlan: AdventurePlan }) {
  // Use custom hooks for form state management
  const {
    teaser,
    setTeaser,
    overview,
    setOverview,
    minPartySize,
    setMinPartySize,
    maxPartySize,
    setMaxPartySize,
    image,
    setImage,
    sections,
    setSections,
    npcs,
    setNpcs,
    premadePlayerCharacters,
    setPremadePlayerCharacters,
    isSaving,
    availableNpcs,
    saveAdventurePlan,
  } = useAdventurePlanForm(adventurePlan)

  const sectionHandlers = useAdventureSections(sections, setSections)
  const encounterHandlers = useEncounterHandlers(sections, setSections)

  // Character change handlers
  const handleNpcsChange = (newNpcs: Record<string, Character>) => {
    setNpcs(newNpcs)
  }
  const handlePremadePlayerCharactersChange = (newPcs: PCTemplate[]) => {
    setPremadePlayerCharacters(newPcs)
  }

  // Wrapper handlers for the generic component
  const handleNpcsChangeWrapper = (characters: Record<string, Character> | PCTemplate[]) => {
    if (Array.isArray(characters)) {
      // This shouldn't happen for NPCs, but handle gracefully
      console.warn("NPCs handler received array instead of object")
      return
    }
    handleNpcsChange(characters)
  }

  const handlePremadePlayerCharactersChangeWrapper = (characters: Record<string, Character> | PCTemplate[]) => {
    if (!Array.isArray(characters)) {
      // This shouldn't happen for PCs, but handle gracefully
      console.warn("Premade PCs handler received object instead of array")
      return
    }
    handlePremadePlayerCharactersChange(characters)
  }

  // Image handlers with auto-save
  const handleImageChange = async (newUrl: string) => {
    setImage(newUrl)
    if (newUrl) {
      await saveAdventurePlan(newUrl)
    }
  }

  const handleImageRemove = async () => {
    setImage("")
    await saveAdventurePlan("")
  }

  // Download handler
  const handleDownload = () => {
    const currentAdventurePlan: AdventurePlan = {
      ...adventurePlan,
      teaser,
      overview,
      party: [Number(minPartySize), Number(maxPartySize)] as [number, number],
      image,
      sections,
      npcs,
      premadePlayerCharacters,
    }

    const jsonData = JSON.stringify(currentAdventurePlan, null, 2)
    const blob = new Blob([jsonData], { type: "application/json" })
    const url = URL.createObjectURL(blob)
    const link = document.createElement("a")
    link.href = url
    link.download = `${adventurePlan.title.replace(/[^a-z0-9]/gi, "_").toLowerCase()}_adventure_plan.json`
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
    URL.revokeObjectURL(url)
    toast.success("Adventure plan downloaded successfully!")
  }

  return (
    <div className="pb-8 flex flex-wrap h-[80vh]">
      <AdventurePlanFormHeader isSaving={isSaving} onDownload={handleDownload} onSave={() => saveAdventurePlan()} />
      <AdventurePlanEditSidebar adventurePlan={{ ...adventurePlan, sections }} />

      <div
        id="adventure-plan-main"
        className="flex-1 pt-2 pr-3 -mr-3 h-full overflow-y-auto [scrollbar-width:thin] [scrollbar-color:dimgray_black] [&::-webkit-scrollbar-track]:bg-black [&::-webkit-scrollbar-thumb]:bg-black [&::-webkit-scrollbar]:w-1"
      >
        <AdventurePlanBasicInfo
          adventurePlanId={adventurePlan.id}
          settingId={adventurePlan.settingId}
          image={image}
          teaser={teaser}
          overview={overview}
          minPartySize={minPartySize}
          maxPartySize={maxPartySize}
          isSaving={isSaving}
          onImageChange={handleImageChange}
          onImageRemove={handleImageRemove}
          onTeaserChange={setTeaser}
          onOverviewChange={setOverview}
          onMinPartySizeChange={setMinPartySize}
          onMaxPartySizeChange={setMaxPartySize}
        />

        <AdventurePlanSections
          adventurePlanId={adventurePlan.id}
          settingId={adventurePlan.settingId}
          sections={sections}
          availableNpcs={availableNpcs}
          isSaving={isSaving}
          onSectionTitleChange={sectionHandlers.handleSectionTitleChange}
          onSectionSummaryChange={sectionHandlers.handleSectionSummaryChange}
          onSceneTitleChange={sectionHandlers.handleSceneTitleChange}
          onSceneSummaryChange={sectionHandlers.handleSceneSummaryChange}
          onEncounterTitleChange={encounterHandlers.handleEncounterTitleChange}
          onEncounterIntroChange={encounterHandlers.handleEncounterIntroChange}
          onEncounterIdChange={encounterHandlers.handleEncounterIdChange}
          onEncounterInstructionsChange={encounterHandlers.handleEncounterInstructionsChange}
          onEncounterSkipInitialNpcTurnsChange={encounterHandlers.handleEncounterSkipInitialNpcTurnsChange}
          onEncounterResetHealthChange={encounterHandlers.handleEncounterResetHealthChange}
          onEncounterImageChange={encounterHandlers.handleEncounterImageChange}
          onEncounterDelete={encounterHandlers.handleEncounterDelete}
          onEncounterTransitionsChange={encounterHandlers.handleEncounterTransitionsChange}
          onEncounterNpcChange={encounterHandlers.handleEncounterNpcChange}
          onAddEncounter={sectionHandlers.handleAddEncounter}
        />

        <AdventurePlanCharactersEdit
          id="npcs-editor"
          type="npcs"
          characters={npcs}
          onCharactersChange={handleNpcsChangeWrapper}
          isSaving={isSaving}
          adventurePlanId={adventurePlan.id}
          settingId={adventurePlan.settingId}
        />

        <AdventurePlanCharactersEdit
          id="premade-pcs-editor"
          type="premadePlayerCharacters"
          characters={premadePlayerCharacters}
          onCharactersChange={handlePremadePlayerCharactersChangeWrapper}
          isSaving={isSaving}
          adventurePlanId={adventurePlan.id}
          settingId={adventurePlan.settingId}
        />

        <div className="flex flex-col items-end gap-4 mt-8 px-4 pb-8">
          <Button variant="epic" size="sm" onClick={() => saveAdventurePlan()} disabled={isSaving}>
            {isSaving ? "Saving..." : "Save Changes"}
          </Button>
        </div>
      </div>
    </div>
  )
}


/*
  File: components/adventure-plans/adventure-plan-edit-sidebar.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure-plans/adventure-plan-edit-sidebar.tsx
  Directory: components/adventure-plans
*/

--- File: components/adventure-plans/adventure-plan-edit-sidebar.tsx ---

"use client"

import * as React from "react"
import { AdventurePlan } from "@/types/adventure-plan"
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion"
import { cn } from "@/lib/utils"
import { reverseSlugify } from "@/lib/utils"
import Link from "next/link"

interface AdventurePlanEditSidebarProps {
  adventurePlan: AdventurePlan
}

const scrollToElement = (targetId: string) => {
  const container = document.getElementById("adventure-plan-main")
  const target = document.getElementById(targetId.replace("#", ""))

  if (container && target) {
    const containerRect = container.getBoundingClientRect()
    const targetRect = target.getBoundingClientRect()
    const scrollTop = container.scrollTop + targetRect.top - containerRect.top - 20 // 20px offset for better visibility

    container.scrollTo({
      top: scrollTop,
      behavior: "smooth",
    })
  }
}

const NavLink: React.FC<{ href: string; children: React.ReactNode; className?: string }> = ({ href, children, className = "" }) => (
  <a
    href={href}
    className={cn("block font-display text-xs hover:text-amber-300 transition-colors py-1 cursor-pointer", className)}
    onClick={(e) => {
      e.preventDefault()
      scrollToElement(href)
    }}
  >
    {children}
  </a>
)

export function AdventurePlanEditSidebar({ adventurePlan }: AdventurePlanEditSidebarProps) {
  // Generate default values for all scenes to be open by default
  const defaultOpenScenes = adventurePlan.sections.flatMap((section, sIndex) => section.scenes.map((_, scIndex) => `scene-${sIndex}-${scIndex}`))
  const settingId = adventurePlan.settingId
  const settingName = reverseSlugify(settingId)

  return (
    <div id="adventure-plan-edit-sidebar" className="w-[360px] h-full overflow-y-auto pr-8">
      <NavLink href="#adventure-plan-main" className="text-2xl text-amber-400 font-display block hover:text-amber-300 transition-colors">
        {adventurePlan.title}
      </NavLink>
      <div className="text-xs -mt-1 opacity-70 text-primary-100 font-display mb-4">
        <Link className="text-blue-300" href={`/settings/${settingId}`}>
          {settingName}
        </Link>{" "}
      </div>
      <nav className="space-y-1">
        {adventurePlan.sections.map((section, sIndex) => (
          <div key={`nav-section-${sIndex}`}>
            {adventurePlan.sections.length > 1 && (
              <NavLink href={`#section-${sIndex}`} className="font-medium">
                {section.title || "Untitled Section"}
              </NavLink>
            )}
            {section.scenes.length === 1 ? (
              // Single scene - no accordion needed
              section.scenes.map((scene, scIndex) => (
                <div key={`nav-scene-${sIndex}-${scIndex}`} className="space-y-1 border-t border-primary-200/30 pt-2">
                  <NavLink href={`#scene-${sIndex}-${scIndex}`} className="text-sm block py-1">
                    {scene.title || "Untitled Scene"}
                  </NavLink>
                  <div className="space-y-1">
                    {scene.encounters.map((encounter, eIndex) => (
                      <NavLink className="block w-full py-1 ml-2" key={`nav-encounter-${sIndex}-${scIndex}-${eIndex}`} href={`#encounter-${sIndex}-${scIndex}-${eIndex}`}>
                        {encounter.title || "Untitled Encounter"}
                      </NavLink>
                    ))}
                  </div>
                </div>
              ))
            ) : (
              // Multiple scenes - use accordion
              <Accordion type="multiple" defaultValue={defaultOpenScenes} className="space-y-0">
                {section.scenes.map((scene, scIndex) => (
                  <AccordionItem className="w-full" key={`nav-scene-${sIndex}-${scIndex}`} value={`scene-${sIndex}-${scIndex}`}>
                    <AccordionTrigger>
                      <NavLink href={`#scene-${sIndex}-${scIndex}`}>{scene.title || "Untitled Scene"}</NavLink>
                    </AccordionTrigger>
                    <AccordionContent>
                      <div className="space-y-1">
                        {scene.encounters.map((encounter, eIndex) => (
                          <NavLink className="block w-full py-1" key={`nav-encounter-${sIndex}-${scIndex}-${eIndex}`} href={`#encounter-${sIndex}-${scIndex}-${eIndex}`}>
                            {encounter.title || "Untitled Encounter"}
                          </NavLink>
                        ))}
                      </div>
                    </AccordionContent>
                  </AccordionItem>
                ))}
              </Accordion>
            )}
          </div>
        ))}
        <div className="border-t border-primary-200/30 pt-2 mt-2">
          <div className="font-display">Characters</div>
          <NavLink className="text-xs p-2" href="#npcs-editor">
            NPCs
          </NavLink>
          <NavLink className="text-xs p-2" href="#premade-pcs-editor">
            Premade PCs
          </NavLink>
        </div>
      </nav>
    </div>
  )
}


/*
  File: components/adventure-plans/adventure-plan-form-header.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure-plans/adventure-plan-form-header.tsx
  Directory: components/adventure-plans
*/

--- File: components/adventure-plans/adventure-plan-form-header.tsx ---

"use client"

import { Button } from "@/components/ui/button"
import { Download, Loader2 } from "lucide-react"

interface AdventurePlanFormHeaderProps {
  isSaving: boolean
  onDownload: () => void
  onSave: () => void
}

export function AdventurePlanFormHeader({ isSaving, onDownload, onSave }: AdventurePlanFormHeaderProps) {
  return (
    <div className="flex items-center justify-end gap-4 w-full border-b border-white/10 pb-2">
      <Button ariaLabel="download json" variant="outline" className="text-sm" size="icon" onClick={onDownload}>
        <Download size={20} className="opacity-50 scale-150" />
      </Button>
      <Button variant="outline" className="font-display font-extrabold tracking-widest text-sm w-24" size="sm" onClick={onSave} disabled={isSaving}>
        {isSaving ? (
          <div className="flex items-center gap-2">
            <Loader2 aria-label="Saving in progress" className="animate-spin" />
          </div>
        ) : (
          "Save"
        )}
      </Button>
    </div>
  )
}


/*
  File: components/adventure-plans/adventure-plan-sections.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure-plans/adventure-plan-sections.tsx
  Directory: components/adventure-plans
*/

--- File: components/adventure-plans/adventure-plan-sections.tsx ---

"use client"

import { AdventureSection } from "@/types/adventure-plan"
import { Textarea } from "@/components/ui/textarea"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { EncounterEditForm } from "@/components/adventure-plans/encounter-edit-form"
import { cn } from "@/lib/utils"
import { Plus } from "lucide-react"

interface AdventurePlanSectionsProps {
  adventurePlanId: string
  settingId: string
  sections: AdventureSection[]
  availableNpcs: Record<string, { id: string; name: string }>
  isSaving: boolean
  onSectionTitleChange: (index: number, newTitle: string) => void
  onSectionSummaryChange: (index: number, newSummary: string) => void
  onSceneTitleChange: (sectionIndex: number, sceneIndex: number, newTitle: string) => void
  onSceneSummaryChange: (sectionIndex: number, sceneIndex: number, newSummary: string) => void
  onEncounterTitleChange: (sectionIndex: number, sceneIndex: number, encounterIndex: number, newTitle: string) => void
  onEncounterIntroChange: (sectionIndex: number, sceneIndex: number, encounterIndex: number, newIntro: string) => void
  onEncounterIdChange: (sectionIndex: number, sceneIndex: number, encounterIndex: number, newId: string) => void
  onEncounterInstructionsChange: (sectionIndex: number, sceneIndex: number, encounterIndex: number, newInstructions: string) => void
  onEncounterSkipInitialNpcTurnsChange: (sectionIndex: number, sceneIndex: number, encounterIndex: number, newValue: boolean) => void
  onEncounterResetHealthChange: (sectionIndex: number, sceneIndex: number, encounterIndex: number, newValue: boolean) => void
  onEncounterImageChange: (sectionIndex: number, sceneIndex: number, encounterIndex: number, newImageUrl: string) => void
  onEncounterDelete: (sectionIndex: number, sceneIndex: number, encounterIndex: number) => void
  onEncounterTransitionsChange: (sectionIndex: number, sceneIndex: number, encounterIndex: number, newTransitions: { condition: string; encounter: string }[]) => void
  onEncounterNpcChange: (sectionIndex: number, sceneIndex: number, encounterIndex: number, newNpcs: { id: string; behavior: string; initialInitiative?: number }[]) => void
  onAddEncounter: (sectionIndex: number, sceneIndex: number) => void
}

export function AdventurePlanSections({
  adventurePlanId,
  settingId,
  sections,
  availableNpcs,
  isSaving,
  onSectionTitleChange,
  onSectionSummaryChange,
  onSceneTitleChange,
  onSceneSummaryChange,
  onEncounterTitleChange,
  onEncounterIntroChange,
  onEncounterIdChange,
  onEncounterInstructionsChange,
  onEncounterSkipInitialNpcTurnsChange,
  onEncounterResetHealthChange,
  onEncounterImageChange,
  onEncounterDelete,
  onEncounterTransitionsChange,
  onEncounterNpcChange,
  onAddEncounter,
}: AdventurePlanSectionsProps) {
  if (sections.length === 0) {
    return <p className="text-sm text-gray-400 italic">This adventure plan currently has no sections defined.</p>
  }

  return (
    <>
      <h4 className="font-mono pt-12 pb-1 mb-8 border-b-2 border-primary-700/70 text-primary-300 text-center tracking-widest">Adventure Plan</h4>
      {sections.map((section, sIndex) => (
        <div key={sIndex} id={`section-${sIndex}`} className="w-full flex flex-col gap-4 scroll-mt-20">
          {sections.length > 1 && (
            <>
              <h3 className="text-2xl font-bold font-display text-amber-300/80 text-center">{section.title || <span className="italic text-gray-400">Section {sIndex + 1}</span>}</h3>
              <div>
                <label htmlFor={`section-title-${sIndex}`} className="block text-sm font-medium font-mono text-primary-200/90 mb-1">
                  Section Title
                </label>
                <Input
                  id={`section-title-${sIndex}`}
                  value={section.title}
                  onChange={(e) => onSectionTitleChange(sIndex, e.target.value)}
                  placeholder="Enter section title"
                  disabled={isSaving}
                  className="bg-neutral-800/50 border-neutral-700 placeholder:text-white/50"
                />
              </div>
              <label htmlFor={`section-summary-${sIndex}`} className="block text-sm font-medium font-mono text-primary-200/90 mb-1">
                Section Summary
              </label>
              <Textarea
                id={`section-summary-${sIndex}`}
                value={section.summary}
                onChange={(e) => onSectionSummaryChange(sIndex, e.target.value)}
                placeholder="Enter section summary"
                rows={3}
                disabled={isSaving}
                className="bg-neutral-800/50 border-neutral-700 placeholder:text-white/50"
              />
            </>
          )}

          <div>
            <div>
              {section.scenes.map((scene, scIndex) => (
                <div id={`scene-${sIndex}-${scIndex}`} className={cn(section.scenes.length > 1 && "border border-white/20 rounded-lg p-4 mt-8 flex flex-col gap-4 scroll-mt-20")} key={scIndex}>
                  <div>
                    <h3 className="text-2xl font-bold font-display text-amber-300/80 text-center pb-2">{scene.title || <span className="italic text-gray-400">Scene {scIndex + 1}</span>}</h3>
                    <label htmlFor={`scene-title-${sIndex}-${scIndex}`} className="block text-sm font-medium font-mono text-primary-200/90 mb-1">
                      Scene Title
                    </label>
                    <Input
                      id={`scene-title-${sIndex}-${scIndex}`}
                      value={scene.title}
                      onChange={(e) => onSceneTitleChange(sIndex, scIndex, e.target.value)}
                      placeholder="Enter scene title"
                      disabled={isSaving}
                      className="bg-neutral-800/50 border-neutral-700 placeholder:text-white/50"
                    />
                    <label htmlFor={`scene-summary-${sIndex}-${scIndex}`} className="block text-sm font-medium font-mono text-primary-200/90 mb-1 mt-4">
                      Scene Summary
                    </label>
                    <div className="group">
                      <Textarea
                        id={`scene-summary-${sIndex}-${scIndex}`}
                        value={scene.summary}
                        onChange={(e) => onSceneSummaryChange(sIndex, scIndex, e.target.value)}
                        placeholder="Enter scene summary"
                        rows={3}
                        disabled={isSaving}
                        className="bg-neutral-800/50 border-neutral-700 placeholder:text-white/50 max-h-[180px] overflow-y-auto group-focus-within:max-h-none"
                      />
                    </div>
                    <p className="text-sm text-white/70 italic pt-2">The scene summary should describe the overall course of the scene for the GameMaster.</p>

                    <div>
                      {scene.encounters.map((encounter, eIndex) => (
                        <EncounterEditForm
                          key={eIndex}
                          id={`encounter-${sIndex}-${scIndex}-${eIndex}`}
                          adventurePlanId={adventurePlanId}
                          settingId={settingId}
                          encounter={encounter}
                          sectionIndex={sIndex}
                          sceneIndex={scIndex}
                          encounterIndex={eIndex}
                          allSections={sections}
                          availableNpcs={availableNpcs}
                          onTitleChange={onEncounterTitleChange}
                          onIntroChange={onEncounterIntroChange}
                          onIdChange={onEncounterIdChange}
                          onInstructionsChange={onEncounterInstructionsChange}
                          onSkipInitialNpcTurnsChange={onEncounterSkipInitialNpcTurnsChange}
                          onResetHealthChange={onEncounterResetHealthChange}
                          onImageChange={onEncounterImageChange}
                          onDelete={onEncounterDelete}
                          onTransitionsChange={onEncounterTransitionsChange}
                          onNpcChange={onEncounterNpcChange}
                          isSaving={isSaving}
                        />
                      ))}

                      <div className="mt-4 flex justify-center">
                        <Button onClick={() => onAddEncounter(sIndex, scIndex)} disabled={isSaving} size="sm" variant="outline" className="flex items-center gap-2 hover:scale-100">
                          <Plus size={16} />
                          Add Encounter
                        </Button>
                      </div>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      ))}
    </>
  )
}


/*
  File: components/adventure-plans/character-card.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure-plans/character-card.tsx
  Directory: components/adventure-plans
*/

--- File: components/adventure-plans/character-card.tsx ---

"use client"

import * as React from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Textarea } from "@/components/ui/textarea"
import { Label } from "@/components/ui/label"
import { Card, CardContent } from "@/components/ui/card"
import { ImageUpload } from "@/components/ui/image-upload"
import { Plus, X, Edit, ChevronsUp } from "lucide-react"
import type { Character, PCTemplate } from "@/types/character"
import { cn } from "@/lib/utils"
import Image from "next/image"
import { useCharacterDetails } from "@/components/adventure-plans/hooks/use-character-details"

const IMAGE_HOST = process.env.NEXT_PUBLIC_IMAGE_HOST || ""

interface CharacterCardProps {
  charId: string
  char: Character | PCTemplate
  isNpcs: boolean
  isSaving: boolean
  settingId: string
  adventurePlanId: string
  uniqueKey: string
  editing: boolean
  onToggleEdit: () => void
  onRemove: () => void
  updateCharacter: (charId: string, updates: Partial<Character | PCTemplate>) => void
  getCharacter: (charId: string) => Character | PCTemplate
}

export function CharacterCard({ charId, char, isNpcs, isSaving, settingId, adventurePlanId, uniqueKey, editing, onToggleEdit, onRemove, updateCharacter, getCharacter }: CharacterCardProps) {
  const characterDetails = useCharacterDetails(charId, getCharacter, updateCharacter)
  const imageUploadFolder = `images/settings/${settingId}/${adventurePlanId}/${isNpcs ? "npcs" : "pcs"}`
  const imageUrl = char.image ? IMAGE_HOST + "/" + char.image : ""

  console.log("imageUrl", imageUrl)

  if (!editing) {
    // Collapsed Mode
    return (
      <Card key={uniqueKey} className={cn("bg-white/5 border-white/20 text-white py-0")}>
        <CardContent className="p-4">
          <div className="flex items-center gap-4">
            <div onClick={onToggleEdit} className="w-16 h-16 rounded-lg overflow-hidden bg-white/10 flex-shrink-0 cursor-pointer relative">
              {imageUrl ? (
                <Image fill={true} src={imageUrl} alt={char.name || "Character"} className="w-full h-full object-cover" />
              ) : (
                <div className="w-full h-full flex items-center justify-center text-white/40 text-xs">No Image</div>
              )}
            </div>
            <div onClick={onToggleEdit} className="flex-1 min-w-0 cursor-pointer">
              <div className="text-lg font-display text-amber-300/90 truncate">{char.name || `Unnamed ${isNpcs ? "NPC" : "Character"}`}</div>
              <div className="text-sm text-white/70 space-y-1">
                {char.gender} {char.race} {char.archetype}
              </div>
            </div>
            <Button onClick={onToggleEdit} disabled={isSaving} size="sm" variant="outline" className="flex items-center gap-2 text-sm">
              <Edit size={14} />
              Edit
            </Button>
            <Button onClick={onRemove} disabled={isSaving} size="sm" variant="outline" className="flex items-center gap-2 text-sm">
              <X size={14} />
              Delete
            </Button>
          </div>
        </CardContent>
      </Card>
    )
  }

  // Expanded Mode
  return (
    <Card key={uniqueKey} className={cn("bg-white/5 border-white/20 text-white")}>
      <CardContent className="relative grid grid-cols-2 gap-8">
        <button onClick={onToggleEdit} className="text-sm flex gap-1 items-center absolute -top-5 right-3 text-indigo-400 hover:text-indigo-300">
          <ChevronsUp size={14} /> close
        </button>

        {/* Left Column */}
        <div className="flex flex-col">
          <div className="pb-4">
            <Label className="font-mono p-1 text-primary-200" htmlFor={`char-image-${charId}`}>
              Image
            </Label>
            <ImageUpload
              id={`char-image-${charId}`}
              value={imageUrl || ""}
              onChange={(url) => updateCharacter(charId, { image: url })}
              onRemove={() => updateCharacter(charId, { image: "" })}
              folder={imageUploadFolder}
              className="aspect-square"
            />
          </div>
          <div className="grid grid-cols-3 gap-4">
            <div className="col-span-2">
              <Label className="font-mono p-1 text-primary-200" htmlFor={`char-name-${charId}`}>
                Name
              </Label>
              <Input id={`char-name-${charId}`} value={char.name || ""} onChange={(e) => updateCharacter(charId, { name: e.target.value })} disabled={isSaving} placeholder="Character Name" />
            </div>
            <div>
              <Label className="font-mono p-1 text-primary-200" htmlFor={`char-gender-${charId}`}>
                Gender
              </Label>
              <Input id={`char-gender-${charId}`} value={char.gender || ""} onChange={(e) => updateCharacter(charId, { gender: e.target.value })} disabled={isSaving} placeholder="Optional" />
            </div>
          </div>
          <div className="grid grid-cols-2 gap-4 pt-4">
            <div>
              <Label className="font-mono p-1 text-primary-200" htmlFor={`char-race-${charId}`}>
                Race
              </Label>
              <Input id={`char-race-${charId}`} value={char.race || ""} onChange={(e) => updateCharacter(charId, { race: e.target.value })} disabled={isSaving} placeholder="e.g., Human, Elf, Dwarf" />
            </div>
            <div>
              <Label className="font-mono p-1 text-primary-200" htmlFor={`char-archetype-${charId}`}>
                Archetype
              </Label>
              <Input
                id={`char-archetype-${charId}`}
                value={char.archetype || ""}
                onChange={(e) => updateCharacter(charId, { archetype: e.target.value })}
                disabled={isSaving}
                placeholder={isNpcs ? "e.g., Guard, Merchant, Noble" : "e.g., Fighter, Wizard, Rogue"}
              />
            </div>
          </div>
          <div className="grid grid-cols-3 gap-4 pt-4">
            {["strength", "dexterity", "constitution", "intelligence", "wisdom", "charisma"].map((attr) => (
              <div key={attr}>
                <Label className="font-mono p-1 text-primary-200 capitalize" htmlFor={`char-${attr}-${charId}`}>
                  {attr}
                </Label>
                <Input
                  id={`char-${attr}-${charId}`}
                  type="number"
                  min="1"
                  max="20"
                  value={char.attributes?.[attr as keyof typeof char.attributes] || ""}
                  onChange={(e) => characterDetails.updateAttributes(attr, parseInt(e.target.value) || 0)}
                  disabled={isSaving}
                  placeholder="1-20"
                />
              </div>
            ))}
          </div>
        </div>

        {/* Right Column */}
        <div className="flex flex-col gap-4">
          <div>
            <Label className="font-mono p-1 text-primary-200" htmlFor={`char-appearance-${charId}`}>
              Appearance
            </Label>
            <Textarea
              id={`char-appearance-${charId}`}
              value={char.appearance || ""}
              onChange={(e) => updateCharacter(charId, { appearance: e.target.value })}
              disabled={isSaving}
              placeholder="Physical description of the character"
              rows={3}
            />
          </div>
          <div>
            <Label className="font-mono p-1 text-primary-200" htmlFor={`char-personality-${charId}`}>
              Personality
            </Label>
            <Textarea
              id={`char-personality-${charId}`}
              value={char.personality || ""}
              onChange={(e) => updateCharacter(charId, { personality: e.target.value })}
              disabled={isSaving}
              placeholder="Personality traits, mannerisms, speech patterns"
              rows={3}
            />
          </div>
          <div>
            <Label className="font-mono p-1 text-primary-200" htmlFor={`char-background-${charId}`}>
              Background
            </Label>
            <Textarea
              id={`char-background-${charId}`}
              value={char.background || ""}
              onChange={(e) => updateCharacter(charId, { background: e.target.value })}
              disabled={isSaving}
              placeholder="Background story and history"
              rows={3}
            />
          </div>
          <div>
            <Label className="font-mono p-1 text-primary-200" htmlFor={`char-motivation-${charId}`}>
              Motivation
            </Label>
            <Textarea
              id={`char-motivation-${charId}`}
              value={char.motivation || ""}
              onChange={(e) => updateCharacter(charId, { motivation: e.target.value })}
              disabled={isSaving}
              placeholder="What drives this character? Goals and desires"
              rows={2}
            />
          </div>
          <div>
            <Label className="font-mono p-1 text-primary-200" htmlFor={`char-behavior-${charId}`}>
              Behavior
            </Label>
            <Textarea
              id={`char-behavior-${charId}`}
              value={char.behavior || ""}
              onChange={(e) => updateCharacter(charId, { behavior: e.target.value })}
              disabled={isSaving}
              placeholder="How does this character typically behave in interactions?"
              rows={2}
            />
          </div>

          {/* Skills Section */}
          <div className="space-y-2">
            <div className="font-mono px-1 text-primary-200">Skills</div>
            {(char.skills || []).map((skill, index) => (
              <div key={index} className="flex gap-2">
                <Input value={skill} onChange={(e) => characterDetails.updateSkill(index, e.target.value)} disabled={isSaving} placeholder="Skill name" className="flex-1" />
                <Button onClick={() => characterDetails.removeSkill(index)} disabled={isSaving} size="sm" variant="ghost" className="text-red-400 hover:text-red-300">
                  <X size={16} />
                </Button>
              </div>
            ))}
            <Button onClick={characterDetails.addSkill} disabled={isSaving} size="sm" variant="outline" className="text-xs">
              <Plus size={16} className="mr-2" />
              Add Skill
            </Button>
          </div>

          {/* Spells Section */}
          <div className="space-y-2">
            <div className="font-mono px-1 text-primary-200">Spells</div>
            {(char.spells || []).map((spell, index) => (
              <div key={index} className="space-y-2 p-3 border border-white/10 rounded">
                <div className="flex gap-2">
                  <Input value={spell.name} onChange={(e) => characterDetails.updateSpell(index, { name: e.target.value })} disabled={isSaving} placeholder="Spell name" className="flex-1" />
                  <Button onClick={() => characterDetails.removeSpell(index)} disabled={isSaving} size="sm" variant="ghost" className="text-red-400 hover:text-red-300">
                    <X size={16} />
                  </Button>
                </div>
                <Textarea
                  value={spell.description || ""}
                  onChange={(e) => characterDetails.updateSpell(index, { description: e.target.value })}
                  disabled={isSaving}
                  placeholder="Spell description (optional)"
                  rows={2}
                />
              </div>
            ))}
            <Button onClick={characterDetails.addSpell} disabled={isSaving} size="sm" variant="outline" className="text-xs">
              <Plus size={16} className="mr-2" />
              Add Spell
            </Button>
          </div>

          {/* Special Abilities Section */}
          <div className="space-y-2">
            <div className="font-mono px-1 text-primary-200">Special Abilities</div>
            {(char.specialAbilities || []).map((ability, index) => (
              <div key={index} className="flex gap-2">
                <Input value={ability} onChange={(e) => characterDetails.updateSpecialAbility(index, e.target.value)} disabled={isSaving} placeholder="Special ability name" className="flex-1" />
                <Button onClick={() => characterDetails.removeSpecialAbility(index)} disabled={isSaving} size="sm" variant="ghost" className="text-red-400 hover:text-red-300">
                  <X size={16} />
                </Button>
              </div>
            ))}
            <Button onClick={characterDetails.addSpecialAbility} disabled={isSaving} size="sm" variant="outline" className="text-xs">
              <Plus size={16} className="mr-2" />
              Add Special Ability
            </Button>
          </div>

          {/* Equipment Section */}
          <div className="space-y-2">
            <div className="font-mono px-1 text-primary-200">Equipment</div>
            {(char.equipment || []).map((item, index) => (
              <div key={index} className="space-y-2 p-3 border border-white/10 rounded">
                <div className="flex gap-2">
                  <Input value={item.name} onChange={(e) => characterDetails.updateEquipmentItem(index, { name: e.target.value })} disabled={isSaving} placeholder="Item name" className="flex-1" />
                  <Button onClick={() => characterDetails.removeEquipmentItem(index)} disabled={isSaving} size="sm" variant="ghost" className="text-red-400 hover:text-red-300">
                    <X size={16} />
                  </Button>
                </div>
                <Textarea
                  value={item.description || ""}
                  onChange={(e) => characterDetails.updateEquipmentItem(index, { description: e.target.value })}
                  disabled={isSaving}
                  placeholder="Item description (optional)"
                  rows={2}
                />
              </div>
            ))}
            <Button onClick={characterDetails.addEquipmentItem} disabled={isSaving} size="sm" variant="outline" className="text-xs">
              <Plus size={16} className="mr-2" />
              Add Equipment
            </Button>
          </div>
        </div>
      </CardContent>
    </Card>
  )
}


/*
  File: components/adventure-plans/character-generate-form.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure-plans/character-generate-form.tsx
  Directory: components/adventure-plans
*/

--- File: components/adventure-plans/character-generate-form.tsx ---

"use client"

import * as React from "react"
import { Button } from "@/components/ui/button"
import { Textarea } from "@/components/ui/textarea"
import { Label } from "@/components/ui/label"
import { generateCharacterAction } from "@/app/_actions/generate-character-action"
import { toast } from "sonner"
import type { Character, PCTemplate } from "@/types/character"

interface CharacterGenerateFormProps {
  type: "npcs" | "premadePlayerCharacters"
  characters: Record<string, Character> | PCTemplate[]
  onCharactersChange: (characters: Record<string, Character> | PCTemplate[]) => void
  onClose: () => void
}

export function CharacterGenerateForm({ type, characters, onCharactersChange, onClose }: CharacterGenerateFormProps) {
  const [generatePrompt, setGeneratePrompt] = React.useState("")
  const [isGenerating, setIsGenerating] = React.useState(false)

  const isNpcs = type === "npcs"
  const generateButtonText = isNpcs ? "Generate NPC" : "Generate PC"

  const handleGenerate = async () => {
    if (!generatePrompt.trim()) return

    setIsGenerating(true)

    try {
      const result = await generateCharacterAction({
        prompt: generatePrompt,
        characterType: isNpcs ? "npc" : "pc",
      })

      if (result.success && result.character) {
        // Generate unique ID and add missing fields
        const newId = isNpcs ? `${type}-${Date.now()}` : Date.now().toString()
        const generatedCharacter = {
          ...result.character,
          id: newId,
          image: "", // Start with empty image, user can upload later
        }

        if (isNpcs) {
          // Add to NPCs record
          const npcsRecord = characters as Record<string, Character>
          const updatedNpcs = {
            ...npcsRecord,
            [newId]: generatedCharacter as Character,
          }
          onCharactersChange(updatedNpcs)
        } else {
          // Add to PC array
          const pcArray = characters as PCTemplate[]
          const updatedPcs = [...pcArray, generatedCharacter as PCTemplate]
          onCharactersChange(updatedPcs)
        }

        toast.success(`${isNpcs ? "NPC" : "Character"} generated successfully!`)

        // Reset form
        setGeneratePrompt("")
        onClose()
      } else {
        toast.error(result.error || "Failed to generate character")
      }
    } catch (error) {
      console.error("Error generating character:", error)
      toast.error("An unexpected error occurred while generating the character")
    } finally {
      setIsGenerating(false)
    }
  }

  return (
    <div className="border border-white/20 rounded-lg p-4 sm:p-8 bg-white/5">
      <div className="space-y-8">
        <div>
          <Label className="font-mono p-1 text-primary-200" htmlFor="generate-prompt">
            Character Generation Prompt
          </Label>
          <Textarea
            id="generate-prompt"
            value={generatePrompt}
            onChange={(e) => setGeneratePrompt(e.target.value)}
            placeholder={`Describe the ${isNpcs ? "NPC" : "player character"} you want to generate (e.g., "A gruff dwarf blacksmith with a mysterious past" or "A charismatic elven bard who tells tall tales")`}
            rows={3}
            disabled={isGenerating}
          />
        </div>
        <div className="w-full flex items-center justify-end gap-8">
          <Button onClick={onClose} disabled={isGenerating} size="sm" variant="ghost">
            Cancel
          </Button>
          <Button onClick={handleGenerate} disabled={isGenerating || !generatePrompt.trim()} size="sm" variant="epic">
            {isGenerating ? "Generating..." : generateButtonText}
          </Button>
        </div>
      </div>
    </div>
  )
}


/*
  File: components/adventure-plans/encounter-edit-form.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure-plans/encounter-edit-form.tsx
  Directory: components/adventure-plans
*/

--- File: components/adventure-plans/encounter-edit-form.tsx ---

"use client"

import * as React from "react"
import { AdventureEncounter, EncounterTransition, AdventureSection, EncounterCharacterRef } from "@/types/adventure-plan"
import { Input } from "@/components/ui/input"
import { Textarea } from "@/components/ui/textarea"
import { Checkbox } from "@/components/ui/checkbox"
import { Label } from "@/components/ui/label"
import Image from "next/image"
import { ImageUpload } from "@/components/ui/image-upload"
import { Button } from "@/components/ui/button"
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog"
import { X, Edit, ChevronsUp, ChevronsRight } from "lucide-react"
import { IMAGE_HOST } from "@/lib/config"

interface EncounterEditFormProps {
  id: string
  encounter: AdventureEncounter
  adventurePlanId: string
  settingId: string
  sectionIndex: number
  sceneIndex: number
  encounterIndex: number
  allSections: AdventureSection[] // Properly typed sections array
  availableNpcs: Record<string, { id: string; name: string }> // Available NPCs from adventure plan
  onTitleChange: (sectionIndex: number, sceneIndex: number, encounterIndex: number, newTitle: string) => void
  onIntroChange: (sectionIndex: number, sceneIndex: number, encounterIndex: number, newIntro: string) => void
  onIdChange: (sectionIndex: number, sceneIndex: number, encounterIndex: number, newId: string) => void // Keep this for now, we'll use it later
  onInstructionsChange: (sectionIndex: number, sceneIndex: number, encounterIndex: number, newInstructions: string) => void
  onSkipInitialNpcTurnsChange: (sectionIndex: number, sceneIndex: number, encounterIndex: number, newValue: boolean) => void
  onResetHealthChange: (sectionIndex: number, sceneIndex: number, encounterIndex: number, newValue: boolean) => void
  onImageChange: (sectionIndex: number, sceneIndex: number, encounterIndex: number, newImageUrl: string) => void
  onTransitionsChange: (sectionIndex: number, sceneIndex: number, encounterIndex: number, newTransitions: EncounterTransition[]) => void
  onNpcChange: (sectionIndex: number, sceneIndex: number, encounterIndex: number, newNpcs: EncounterCharacterRef[]) => void
  onDelete: (sectionIndex: number, sceneIndex: number, encounterIndex: number) => void
  isSaving: boolean
}

export function EncounterEditForm({
  id,
  encounter,
  adventurePlanId,
  settingId,
  sectionIndex,
  sceneIndex,
  encounterIndex,
  allSections,
  availableNpcs,
  onTitleChange,
  onIntroChange,
  onInstructionsChange,
  onSkipInitialNpcTurnsChange,
  onResetHealthChange,
  onImageChange,
  onTransitionsChange,
  onNpcChange,
  onDelete,
  isSaving,
}: EncounterEditFormProps) {
  const [isEditing, setIsEditing] = React.useState(false)

  React.useEffect(() => {
    console.log("[EncounterEditForm] Component rendered/updated")
    console.log("[EncounterEditForm] Encounter data:", encounter)
    console.log("[EncounterEditForm] Encounter title:", encounter.title)
    console.log("[EncounterEditForm] Is saving:", isSaving)
  }, [encounter, isSaving])

  const toggleEditMode = () => {
    setIsEditing(!isEditing)
  }

  const handleTitleChange = (newTitle: string) => {
    console.log("[EncounterEditForm] handleTitleChange called with:", newTitle)
    console.log("[EncounterEditForm] Current encounter title:", encounter.title)
    console.log("[EncounterEditForm] Section/Scene/Encounter indices:", sectionIndex, sceneIndex, encounterIndex)

    onTitleChange(sectionIndex, sceneIndex, encounterIndex, newTitle)
  }

  const getAllEncounterIds = () => {
    const encounters: { id: string; title: string; sectionTitle?: string; sceneTitle?: string }[] = []
    allSections.forEach((section) => {
      section.scenes?.forEach((scene) => {
        scene.encounters?.forEach((enc) => {
          if (enc.id) {
            encounters.push({
              id: enc.id,
              title: enc.title || "Untitled Encounter",
              sectionTitle: section.title,
              sceneTitle: scene.title,
            })
          }
        })
      })
    })
    return encounters
  }

  const availableEncounters = getAllEncounterIds()
  const transitions = encounter.transitions || []

  const handleAddNpc = (npcId: string) => {
    if (!npcId) return
    const newNpcs = [...(encounter.npc || []), { id: npcId, behavior: "", initialInitiative: 0 }]
    onNpcChange(sectionIndex, sceneIndex, encounterIndex, newNpcs)
  }

  // Get NPCs that haven't been added to this encounter yet
  const getAvailableNpcsForAdd = () => {
    const assignedNpcIds = new Set((encounter.npc || []).map((npc) => npc.id))
    return Object.entries(availableNpcs).filter(([npcId]) => !assignedNpcIds.has(npcId))
  }

  const availableNpcsForAdd = getAvailableNpcsForAdd()

  const handleNpcChange = (npcIndex: number, field: "id" | "behavior" | "initialInitiative", value: string | number) => {
    const newNpcs = (encounter.npc || []).map((npc, idx) => {
      if (idx === npcIndex) {
        return { ...npc, [field]: value }
      }
      return npc
    })
    onNpcChange(sectionIndex, sceneIndex, encounterIndex, newNpcs)
  }

  const handleRemoveNpc = (npcIndex: number) => {
    const newNpcs = (encounter.npc || []).filter((_, idx) => idx !== npcIndex)
    onNpcChange(sectionIndex, sceneIndex, encounterIndex, newNpcs)
  }

  const baseId = `encounter-${sectionIndex}-${sceneIndex}-${encounterIndex}`
  const imageUploadFolder = `images/settings/${settingId}/${adventurePlanId}/encounters/${encounter.id || `temp-${baseId}`}`

  // Helper function to construct the full URL for display
  const getDisplayUrl = (value: string): string => {
    if (!value) return value

    // If it's already a full URL, use it as-is
    if (value.startsWith("http://") || value.startsWith("https://")) {
      return value
    }

    // If it's a relative path, prepend the IMAGE_HOST
    return `${IMAGE_HOST}/${value.replace(/^\/+/, "")}`
  }

  const imageUrl = getDisplayUrl(encounter.image || "")

  // Helper: Get available encounters for transitions (not already selected)
  const getAvailableEncountersForTransition = () => {
    const selectedEncounterIds = new Set(transitions.map((t) => t.encounter))
    return availableEncounters.filter((enc) => !selectedEncounterIds.has(enc.id))
  }
  const availableEncountersForTransition = getAvailableEncountersForTransition()
  const [addTransitionValue, setAddTransitionValue] = React.useState("")

  // Restore transition handlers (needed for transitions section)
  const handleTransitionChange = (transitionIndex: number, field: "condition" | "encounter", value: string) => {
    const newTransitions = transitions.map((transition, idx) => {
      if (idx === transitionIndex) {
        return { ...transition, [field]: value }
      }
      return transition
    })
    onTransitionsChange(sectionIndex, sceneIndex, encounterIndex, newTransitions)
  }

  const handleRemoveTransition = (transitionIndex: number) => {
    const newTransitions = transitions.filter((_, idx) => idx !== transitionIndex)
    onTransitionsChange(sectionIndex, sceneIndex, encounterIndex, newTransitions)
  }

  return (
    <div id={id} className={`border border-white/20 rounded-lg mt-8 flex flex-col gap-4 relative ${!isEditing ? "py-0" : "p-4"}`}>
      {!isEditing ? (
        // Collapsed Mode
        <div className="p-4 flex items-center gap-4 relative">
          <div onClick={toggleEditMode} className="h-16 aspect-video rounded-lg overflow-hidden bg-white/10 flex-shrink-0 cursor-pointer relative">
            {imageUrl ? (
              <Image fill={true} src={imageUrl} alt={encounter.title || "Encounter"} className="w-full h-full object-cover" />
            ) : (
              <div className="w-full h-full flex items-center justify-center text-white/40 text-xs">No Image</div>
            )}
          </div>
          <div onClick={toggleEditMode} className="flex-1 min-w-0 cursor-pointer">
            <div className="text-lg font-display font-bold text-amber-300 truncate">{encounter.title || "Untitled Encounter"}</div>
            {!encounter.transitions ||
              (encounter.transitions.length === 0 && (
                <div className="absolute -bottom-3 left-6 bg-black border border-red-700/80 rounded px-2 py-0.5 text-xxs font-mono text-white/90">Final Encounter</div>
              ))}
            <div className="text-sm text-white/90 space-y-1">{encounter.intro && <div className="text-white/60 text-xs truncate">{encounter.intro.substring(0, 100)}...</div>}</div>
            {/* Transition Badges */}
            {encounter.transitions && encounter.transitions.length > 0 && (
              <div className="flex flex-wrap gap-1 mt-2">
                {encounter.transitions.map((transition, idx) => {
                  const target = availableEncounters.find((enc) => enc.id === transition.encounter)
                  if (!target) return null
                  return (
                    <span
                      key={transition.encounter + idx}
                      className="inline-flex items-center gap-1 bg-indigo-800/80 text-indigo-100 text-xxs font-mono rounded-full px-2 py-0.5 max-w-xs truncate"
                      title={target.title}
                    >
                      <ChevronsRight size={10} /> {target.title}
                    </span>
                  )
                })}
              </div>
            )}
          </div>
          <Button onClick={toggleEditMode} disabled={isSaving} size="sm" variant="outline" className="flex items-center gap-2 text-sm">
            <Edit size={14} />
            Edit
          </Button>
          <AlertDialog>
            <AlertDialogTrigger asChild>
              <Button disabled={isSaving} size="sm" variant="outline" className="flex items-center gap-2 text-sm">
                <X size={14} />
                Delete
              </Button>
            </AlertDialogTrigger>
            <AlertDialogContent>
              <AlertDialogHeader>
                <AlertDialogTitle>Delete Encounter</AlertDialogTitle>
                <AlertDialogDescription>Are you sure you want to delete the encounter “{encounter.title || "Untitled Encounter"}”? This action cannot be undone.</AlertDialogDescription>
              </AlertDialogHeader>
              <AlertDialogFooter>
                <AlertDialogCancel>Cancel</AlertDialogCancel>
                <AlertDialogAction onClick={() => onDelete(sectionIndex, sceneIndex, encounterIndex)} className="bg-red-600 hover:bg-red-700 focus:ring-red-600">
                  Delete Encounter
                </AlertDialogAction>
              </AlertDialogFooter>
            </AlertDialogContent>
          </AlertDialog>
        </div>
      ) : (
        // Expanded Mode
        <>
          <button onClick={toggleEditMode} className="text-sm flex gap-1 items-center absolute -top-5 right-3 text-indigo-400 hover:text-indigo-300">
            <ChevronsUp size={14} /> close
          </button>
          <div className="absolute -top-4 left-2 text-xxs font-mono text-white/60 px-1.5 pt-8 pb-2 rounded">{encounter.id || ""}</div>
          <h4 className="text-5xl font-display text-amber-400 text-center pt-4">{encounter.title}</h4>

          <div>
            <Label htmlFor={`${baseId}-image-upload`} className="block text-sm font-medium font-mono text-primary-200/90 mb-1">
              Encounter Image
            </Label>
            <ImageUpload
              id={`${baseId}-image-upload`}
              value={encounter.image || ""}
              onChange={(newUrl) => onImageChange(sectionIndex, sceneIndex, encounterIndex, newUrl)}
              onRemove={() => onImageChange(sectionIndex, sceneIndex, encounterIndex, "")}
              folder={imageUploadFolder}
            />
          </div>

          <div>
            <Label htmlFor={`${baseId}-title`} className="block text-sm font-medium font-mono text-primary-200/90 cursor-pointer mb-1">
              Encounter Title
            </Label>
            <Input
              id={`${baseId}-title`}
              value={encounter.title}
              onChange={(e) => {
                console.log("[EncounterEditForm] Input onChange triggered, value:", e.target.value)
                handleTitleChange(e.target.value)
              }}
              placeholder="Enter encounter title"
              disabled={isSaving}
              className="bg-white/10 placeholder:text-white/40"
            />
          </div>
          <div>
            <Label htmlFor={`${baseId}-intro`} className="block text-sm font-medium font-mono text-primary-200/90 cursor-pointer mb-1">
              Encounter Intro
            </Label>
            <Textarea
              id={`${baseId}-intro`}
              value={encounter.intro}
              onChange={(e) => onIntroChange(sectionIndex, sceneIndex, encounterIndex, e.target.value)}
              placeholder="Enter encounter introduction narrative"
              rows={5}
              disabled={isSaving}
              className="bg-white/10 placeholder:text-white/40"
            />
          </div>
          <div>
            <Label htmlFor={`${baseId}-instructions`} className="block text-sm font-medium font-mono text-primary-200/90 cursor-pointer mb-1">
              Instructions
            </Label>
            <Textarea
              id={`${baseId}-instructions`}
              value={encounter.instructions}
              onChange={(e) => onInstructionsChange(sectionIndex, sceneIndex, encounterIndex, e.target.value)}
              placeholder="Enter GM instructions for the encounter"
              rows={5}
              disabled={isSaving}
              className="bg-white/10 placeholder:text-white/40"
            />
          </div>

          {/* NPCs Section */}
          <div className="border-t border-white/10 pt-4">
            <div className="mb-3">
              <Label className="text-lg font-display text-amber-400/90 pl-2">NPCs</Label>
            </div>

            {!encounter.npc || encounter.npc.length === 0 ? (
              <p className="text-xs text-gray-400 italic mb-2">No NPCs assigned to this encounter.</p>
            ) : (
              <div className="space-y-3 mb-3">
                {encounter.npc.map((npc, nIndex) => (
                  <div key={nIndex} className="border border-white/10 rounded p-3 space-y-2">
                    <div className="flex items-center justify-between">
                      <span className="text-xs font-mono text-white/60">NPC {nIndex + 1}</span>
                      <Button onClick={() => handleRemoveNpc(nIndex)} disabled={isSaving} size="icon" variant="ghost" className="h-5 w-5 p-0 text-red-400 hover:text-red-300 hover:bg-red-400/10">
                        <X size={10} />
                      </Button>
                    </div>

                    <div>
                      <Label htmlFor={`${baseId}-npc-${nIndex}-id`} className="text-xs font-mono text-primary-200/90 mb-1 block">
                        NPC Character
                      </Label>
                      <select
                        id={`${baseId}-npc-${nIndex}-id`}
                        value={npc.id}
                        onChange={(e) => handleNpcChange(nIndex, "id", e.target.value)}
                        disabled={isSaving}
                        className="w-full bg-white/5 border border-white/20 rounded px-2 py-1 text-xs text-white placeholder:text-white/40"
                      >
                        <option value="">Select NPC...</option>
                        {Object.entries(availableNpcs).map(([npcId, npcData]) => (
                          <option key={npcId} value={npcId} className="bg-gray-800">
                            {npcData.name}
                          </option>
                        ))}
                      </select>
                    </div>

                    <div>
                      <Label htmlFor={`${baseId}-npc-${nIndex}-behavior`} className="text-xs font-mono text-primary-200/90 mb-1 block">
                        Behavior Instructions
                      </Label>
                      <Textarea
                        id={`${baseId}-npc-${nIndex}-behavior`}
                        value={npc.behavior}
                        onChange={(e) => handleNpcChange(nIndex, "behavior", e.target.value)}
                        placeholder="e.g., 'Aggressive attacker, focuses on spellcasters' or 'Tries to negotiate before fighting'"
                        rows={2}
                        disabled={isSaving}
                        className="bg-white/5 placeholder:text-white/40 text-xs"
                      />
                    </div>
                  </div>
                ))}
              </div>
            )}

            {/* Add NPC Dropdown */}
            {availableNpcsForAdd.length > 0 && (
              <div className="max-w-[300px]">
                <select
                  value=""
                  onChange={(e) => {
                    if (e.target.value) {
                      handleAddNpc(e.target.value)
                      // Reset the select to show the placeholder again
                      e.target.value = ""
                    }
                  }}
                  disabled={isSaving}
                  className="w-full bg-white/5 border border-white/20 rounded p-2 text-xs text-white placeholder:text-white/40"
                >
                  <option value="">+ Add NPC</option>
                  {availableNpcsForAdd.map(([npcId, npcData]) => (
                    <option key={npcId} value={npcId} className="bg-gray-800">
                      {npcData.name}
                    </option>
                  ))}
                </select>
              </div>
            )}
          </div>

          {/* Transitions Section */}
          <div className="border-t border-white/10 pt-4">
            <div className="flex items-center justify-between mb-3">
              <Label className="text-lg font-display text-amber-400/90 pl-2">Transitions</Label>
            </div>

            {transitions.length === 0 ? (
              <p className="text-xs text-gray-400 italic mb-2">No transitions defined. This encounter will end the adventure.</p>
            ) : (
              <div className="space-y-2">
                {transitions.map((transition, tIndex) => (
                  <div key={tIndex} className="border border-white/10 rounded pb-2 space-y-2">
                    <div className="flex items-center justify-end -mb-4">
                      <Button
                        onClick={() => handleRemoveTransition(tIndex)}
                        disabled={isSaving}
                        size="icon"
                        variant="ghost"
                        className="scale-150 h-5 w-5 p-0 text-red-400 hover:text-red-300 hover:bg-red-400/10"
                      >
                        <X size={10} />
                      </Button>
                    </div>

                    <div>
                      <Label htmlFor={`${baseId}-transition-${tIndex}-encounter`} className="text-xs font-mono text-primary-200/90 mb-1 block">
                        Target Encounter
                      </Label>
                      <div className="max-w-[300px]">
                        <select
                          id={`${baseId}-transition-${tIndex}-encounter`}
                          value={transition.encounter}
                          onChange={(e) => handleTransitionChange(tIndex, "encounter", e.target.value)}
                          disabled={isSaving}
                          className="w-full bg-white/5 border border-white/20 rounded p-2 text-base text-white placeholder:text-white/40"
                        >
                          {!transition.encounter && <option value="">Select target encounter...</option>}
                          {availableEncounters.map((enc) => (
                            <option key={enc.id} value={enc.id} className="bg-gray-800">
                              {enc.title}
                            </option>
                          ))}
                        </select>
                      </div>
                    </div>

                    <div>
                      <Label htmlFor={`${baseId}-transition-${tIndex}-condition`} className="text-xs font-mono text-primary-200/90 mb-1 block">
                        Condition
                      </Label>
                      <Textarea
                        id={`${baseId}-transition-${tIndex}-condition`}
                        value={transition.condition}
                        onChange={(e) => handleTransitionChange(tIndex, "condition", e.target.value)}
                        placeholder="e.g., 'Player successfully unlocks the door' or 'Combat ends with all enemies defeated'"
                        rows={2}
                        disabled={isSaving}
                        className="bg-white/5 placeholder:text-white/40 text-xs"
                      />
                    </div>
                  </div>
                ))}
              </div>
            )}

            {/* Add Transition Dropdown */}
            {availableEncountersForTransition.length > 0 && (
              <div className="max-w-[300px] mt-2">
                <select
                  value={addTransitionValue}
                  onChange={(e) => {
                    const selected = e.target.value
                    if (selected) {
                      const newTransitions = [...transitions, { condition: "", encounter: selected }]
                      onTransitionsChange(sectionIndex, sceneIndex, encounterIndex, newTransitions)
                      setAddTransitionValue("")
                    }
                  }}
                  disabled={isSaving}
                  className="w-full bg-white/5 border border-white/20 rounded p-2 text-xs text-white placeholder:text-white/40"
                >
                  <option value="">+ Add Transition</option>
                  {availableEncountersForTransition.map((enc) => (
                    <option key={enc.id} value={enc.id} className="bg-gray-800">
                      {enc.title}
                    </option>
                  ))}
                </select>
              </div>
            )}
          </div>

          <div className="flex items-center space-x-2">
            <Checkbox
              id={`${baseId}-skipNpcTurns`}
              checked={encounter.skipInitialNpcTurns || false}
              onCheckedChange={(checked) => onSkipInitialNpcTurnsChange(sectionIndex, sceneIndex, encounterIndex, !!checked)}
              disabled={isSaving}
            />
            <Label htmlFor={`${baseId}-skipNpcTurns`} className="text-sm font-medium font-mono text-primary-200/90 cursor-pointer">
              Skip Initial NPC Turns?
            </Label>
          </div>
          <div className="flex items-center space-x-2">
            <Checkbox
              id={`${baseId}-resetHealth`}
              checked={encounter.resetHealth || false}
              onCheckedChange={(checked) => onResetHealthChange(sectionIndex, sceneIndex, encounterIndex, !!checked)}
              disabled={isSaving}
            />
            <Label htmlFor={`${baseId}-resetHealth`} className="text-sm font-medium font-mono text-primary-200/90 cursor-pointer">
              Reset Health on Encounter Start?
            </Label>
          </div>

          <div className="w-full flex justify-end items-center">
            <AlertDialog>
              <AlertDialogTrigger asChild>
                <Button disabled={isSaving} size="sm" variant="ghost" className="flex items-center gap-2 text-red-400 hover:text-red-400 hover:bg-red-400/10 z-10">
                  <X size={14} />
                  Delete Encounter
                </Button>
              </AlertDialogTrigger>
              <AlertDialogContent>
                <AlertDialogHeader>
                  <AlertDialogTitle>Delete Encounter</AlertDialogTitle>
                  <AlertDialogDescription>Are you sure you want to delete the encounter “{encounter.title || "Untitled Encounter"}”? This action cannot be undone.</AlertDialogDescription>
                </AlertDialogHeader>
                <AlertDialogFooter>
                  <AlertDialogCancel>Cancel</AlertDialogCancel>
                  <AlertDialogAction onClick={() => onDelete(sectionIndex, sceneIndex, encounterIndex)} className="bg-red-800 font-display font-bold hover:bg-red-700 focus:ring-red-800">
                    Delete Encounter
                  </AlertDialogAction>
                </AlertDialogFooter>
              </AlertDialogContent>
            </AlertDialog>
          </div>
        </>
      )}
    </div>
  )
}


/*
  File: components/adventure-plans/hooks/use-adventure-plan-form.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure-plans/hooks/use-adventure-plan-form.ts
  Directory: components/adventure-plans/hooks
*/

--- File: components/adventure-plans/hooks/use-adventure-plan-form.ts ---

import * as React from "react"
import { AdventurePlan, AdventureSection } from "@/types/adventure-plan"
import type { Character, PCTemplate } from "@/types/character"
import { updateAdventurePlanAction } from "@/app/_actions/adventure-plan-actions"
import { toast } from "sonner"

export function useAdventurePlanForm(adventurePlan: AdventurePlan) {
  const [teaser, setTeaser] = React.useState(adventurePlan.teaser)
  const [overview, setOverview] = React.useState(adventurePlan.overview)
  const [minPartySize, setMinPartySize] = React.useState(adventurePlan.party ? adventurePlan.party[0] : 1)
  const [maxPartySize, setMaxPartySize] = React.useState(adventurePlan.party ? adventurePlan.party[1] : 1)
  const [image, setImage] = React.useState(adventurePlan.image || "")
  const [sections, setSections] = React.useState<AdventureSection[]>(adventurePlan.sections || [])
  const [npcs, setNpcs] = React.useState<Record<string, Character>>(adventurePlan.npcs || {})
  const [premadePlayerCharacters, setPremadePlayerCharacters] = React.useState<PCTemplate[]>(adventurePlan.premadePlayerCharacters || [])
  const [isSaving, setIsSaving] = React.useState(false)

  const saveAdventurePlan = async (overrideImage?: string) => {
    setIsSaving(true)
    const imageToSave = overrideImage !== undefined ? overrideImage : image
    const updatedAdventurePlan: AdventurePlan = {
      ...adventurePlan,
      teaser,
      overview,
      party: [Number(minPartySize), Number(maxPartySize)] as [number, number],
      image: imageToSave,
      sections,
      npcs,
      premadePlayerCharacters,
    }

    try {
      const result = await updateAdventurePlanAction({ adventurePlan: updatedAdventurePlan })
      if (result.success) {
        toast.success(result.message || "Saved successfully!")
      } else {
        toast.error(result.error || "Failed to save.")
      }
    } catch (error) {
      console.error("Error during save operation:", error)
      const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred."
      toast.error(`Error: ${errorMessage}`)
    } finally {
      setIsSaving(false)
    }
  }

  const availableNpcs = React.useMemo(() => {
    const npcOptions: Record<string, { id: string; name: string }> = {}
    Object.entries(npcs).forEach(([npcId, npcData]) => {
      npcOptions[npcId] = {
        id: npcId,
        name: npcData.name || npcId,
      }
    })
    return npcOptions
  }, [npcs])

  return {
    // State
    teaser,
    setTeaser,
    overview,
    setOverview,
    minPartySize,
    setMinPartySize,
    maxPartySize,
    setMaxPartySize,
    image,
    setImage,
    sections,
    setSections,
    npcs,
    setNpcs,
    premadePlayerCharacters,
    setPremadePlayerCharacters,
    isSaving,
    availableNpcs,
    // Actions
    saveAdventurePlan,
  }
} 

/*
  File: components/adventure-plans/hooks/use-adventure-sections.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure-plans/hooks/use-adventure-sections.ts
  Directory: components/adventure-plans/hooks
*/

--- File: components/adventure-plans/hooks/use-adventure-sections.ts ---

import * as React from "react"
import { AdventureSection } from "@/types/adventure-plan"

export function useAdventureSections(
  sections: AdventureSection[],
  setSections: React.Dispatch<React.SetStateAction<AdventureSection[]>>
) {
  const handleSectionTitleChange = (index: number, newTitle: string) => {
    const updatedSections = sections.map((section, i) => (i === index ? { ...section, title: newTitle } : section))
    setSections(updatedSections)
  }

  const handleSectionSummaryChange = (index: number, newSummary: string) => {
    const updatedSections = sections.map((section, i) => (i === index ? { ...section, summary: newSummary } : section))
    setSections(updatedSections)
  }

  const handleSceneTitleChange = (sectionIndex: number, sceneIndex: number, newTitle: string) => {
    const updatedSections = sections.map((section, sIdx) => {
      if (sIdx === sectionIndex) {
        const updatedScenes = section.scenes.map((scene, scIdx) => {
          if (scIdx === sceneIndex) {
            return { ...scene, title: newTitle }
          }
          return scene
        })
        return { ...section, scenes: updatedScenes }
      }
      return section
    })
    setSections(updatedSections)
  }

  const handleSceneSummaryChange = (sectionIndex: number, sceneIndex: number, newSummary: string) => {
    const updatedSections = sections.map((section, sIdx) => {
      if (sIdx === sectionIndex) {
        const updatedScenes = section.scenes.map((scene, scIdx) => {
          if (scIdx === sceneIndex) {
            return { ...scene, summary: newSummary }
          }
          return scene
        })
        return { ...section, scenes: updatedScenes }
      }
      return section
    })
    setSections(updatedSections)
  }

  const handleAddEncounter = (sectionIndex: number, sceneIndex: number) => {
    const newEncounterId = `encounter-${Date.now()}`
    const newEncounter = {
      id: newEncounterId,
      title: "",
      intro: "",
      instructions: "",
      image: "",
      transitions: [],
      npc: [],
      skipInitialNpcTurns: false,
      resetHealth: false,
    }

    setSections((prevSections) =>
      prevSections.map((section, sIndex) => {
        if (sIndex === sectionIndex) {
          return {
            ...section,
            scenes: section.scenes.map((scene, scIndex) => {
              if (scIndex === sceneIndex) {
                return {
                  ...scene,
                  encounters: [...scene.encounters, newEncounter],
                }
              }
              return scene
            }),
          }
        }
        return section
      })
    )
  }

  return {
    handleSectionTitleChange,
    handleSectionSummaryChange,
    handleSceneTitleChange,
    handleSceneSummaryChange,
    handleAddEncounter,
  }
} 

/*
  File: components/adventure-plans/hooks/use-character-details.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure-plans/hooks/use-character-details.ts
  Directory: components/adventure-plans/hooks
*/

--- File: components/adventure-plans/hooks/use-character-details.ts ---

import type { Character, PCTemplate, EquipmentItem } from "@/types/character"

export function useCharacterDetails(
  charId: string,
  getCharacter: (charId: string) => Character | PCTemplate,
  updateCharacter: (charId: string, updates: Partial<Character | PCTemplate>) => void
) {
  const char = getCharacter(charId)

  // Equipment management
  const updateEquipment = (equipment: EquipmentItem[]) => {
    updateCharacter(charId, { equipment })
  }

  const addEquipmentItem = () => {
    const newEquipment = [...(char.equipment || []), { name: "", description: "" }]
    updateEquipment(newEquipment)
  }

  const removeEquipmentItem = (index: number) => {
    const newEquipment = (char.equipment || []).filter((_, i) => i !== index)
    updateEquipment(newEquipment)
  }

  const updateEquipmentItem = (index: number, updates: Partial<EquipmentItem>) => {
    const newEquipment = (char.equipment || []).map((item, i) => (i === index ? { ...item, ...updates } : item))
    updateEquipment(newEquipment)
  }

  // Skills management
  const updateSkills = (skills: string[]) => {
    updateCharacter(charId, { skills })
  }

  const addSkill = () => {
    const newSkills = [...(char.skills || []), ""]
    updateSkills(newSkills)
  }

  const removeSkill = (index: number) => {
    const newSkills = (char.skills || []).filter((_, i) => i !== index)
    updateSkills(newSkills)
  }

  const updateSkill = (index: number, skill: string) => {
    const newSkills = (char.skills || []).map((s, i) => (i === index ? skill : s))
    updateSkills(newSkills)
  }

  // Spells management
  const updateSpells = (spells: Array<{ name: string; description?: string; isUsed?: boolean }>) => {
    updateCharacter(charId, { spells })
  }

  const addSpell = () => {
    const newSpells = [...(char.spells || []), { name: "", description: "", isUsed: false }]
    updateSpells(newSpells)
  }

  const removeSpell = (index: number) => {
    const newSpells = (char.spells || []).filter((_, i) => i !== index)
    updateSpells(newSpells)
  }

  const updateSpell = (index: number, updates: { name?: string; description?: string; isUsed?: boolean }) => {
    const newSpells = (char.spells || []).map((spell, i) => (i === index ? { ...spell, ...updates } : spell))
    updateSpells(newSpells)
  }

  // Special abilities management
  const updateSpecialAbilities = (specialAbilities: string[]) => {
    updateCharacter(charId, { specialAbilities })
  }

  const addSpecialAbility = () => {
    const newSpecialAbilities = [...(char.specialAbilities || []), ""]
    updateSpecialAbilities(newSpecialAbilities)
  }

  const removeSpecialAbility = (index: number) => {
    const newSpecialAbilities = (char.specialAbilities || []).filter((_, i) => i !== index)
    updateSpecialAbilities(newSpecialAbilities)
  }

  const updateSpecialAbility = (index: number, ability: string) => {
    const newSpecialAbilities = (char.specialAbilities || []).map((a, i) => (i === index ? ability : a))
    updateSpecialAbilities(newSpecialAbilities)
  }

  // Attributes management
  const updateAttributes = (attribute: string, value: number) => {
    const newAttributes = {
      ...char.attributes,
      [attribute]: value,
    }
    updateCharacter(charId, { attributes: newAttributes })
  }

  return {
    char,
    // Equipment
    addEquipmentItem,
    removeEquipmentItem,
    updateEquipmentItem,
    // Skills
    addSkill,
    removeSkill,
    updateSkill,
    // Spells
    addSpell,
    removeSpell,
    updateSpell,
    // Special abilities
    addSpecialAbility,
    removeSpecialAbility,
    updateSpecialAbility,
    // Attributes
    updateAttributes,
  }
} 

/*
  File: components/adventure-plans/hooks/use-character-management.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure-plans/hooks/use-character-management.ts
  Directory: components/adventure-plans/hooks
*/

--- File: components/adventure-plans/hooks/use-character-management.ts ---

import type { Character, NPC, PCTemplate } from "@/types/character"

export function useCharacterManagement(
  type: "npcs" | "premadePlayerCharacters",
  characters: Record<string, Character> | PCTemplate[],
  onCharactersChange: (characters: Record<string, Character> | PCTemplate[]) => void
) {
  const isNpcs = type === "npcs"

  const addNewCharacter = () => {
    const newId = isNpcs ? `${type}-${Date.now()}` : Date.now().toString()

    if (isNpcs) {
      const newNpc: NPC = {
        id: newId,
        type: "npc",
        name: "",
        image: "",
        archetype: "",
        race: "",
        appearance: "",
        healthPercent: 100,
        equipment: [],
        skills: [],
      }
      const npcsRecord = characters as Record<string, Character>
      onCharactersChange({
        ...npcsRecord,
        [newId]: newNpc,
      })
    } else {
      const newPc: PCTemplate = {
        id: newId,
        type: "pc",
        name: "",
        image: "",
        archetype: "",
        race: "",
        appearance: "",
        healthPercent: 100,
        equipment: [],
        skills: [],
        attributes: {
          strength: 10,
          dexterity: 10,
          constitution: 10,
          intelligence: 10,
          wisdom: 10,
          charisma: 10,
        },
      }
      const pcArray = characters as PCTemplate[]
      onCharactersChange([...pcArray, newPc])
    }
  }

  const updateCharacter = (charId: string, updates: Partial<Character | PCTemplate>) => {
    if (isNpcs) {
      const npcsRecord = characters as Record<string, Character>
      const updatedNpcs = {
        ...npcsRecord,
        [charId]: {
          ...npcsRecord[charId],
          ...updates,
        } as Character,
      }
      onCharactersChange(updatedNpcs)
    } else {
      const pcArray = characters as PCTemplate[]
      const index = parseInt(charId)
      const updatedPcs = pcArray.map((char, i) => (i === index ? ({ ...char, ...updates } as PCTemplate) : char))
      onCharactersChange(updatedPcs)
    }
  }

  const removeCharacter = (charId: string) => {
    if (isNpcs) {
      const npcsRecord = characters as Record<string, Character>
      const updatedNpcs = { ...npcsRecord }
      delete updatedNpcs[charId]
      onCharactersChange(updatedNpcs)
    } else {
      const pcArray = characters as PCTemplate[]
      const index = parseInt(charId)
      const updatedPcs = pcArray.filter((_, i) => i !== index)
      onCharactersChange(updatedPcs)
    }
  }

  const getCharacter = (charId: string): Character | PCTemplate => {
    return isNpcs ? (characters as Record<string, Character>)[charId] : (characters as PCTemplate[])[parseInt(charId)]
  }

  // Get the characters array for rendering - convert objects to array format for consistency
  const charactersArray: [string, Character | PCTemplate][] = isNpcs
    ? Object.entries(characters as Record<string, Character>)
    : (characters as PCTemplate[]).map((char, index) => [index.toString(), char])

  return {
    isNpcs,
    charactersArray,
    addNewCharacter,
    updateCharacter,
    removeCharacter,
    getCharacter,
  }
} 

/*
  File: components/adventure-plans/hooks/use-encounter-handlers.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/adventure-plans/hooks/use-encounter-handlers.ts
  Directory: components/adventure-plans/hooks
*/

--- File: components/adventure-plans/hooks/use-encounter-handlers.ts ---

import * as React from "react"
import { AdventureSection } from "@/types/adventure-plan"
import slugify from "slugify"

export function useEncounterHandlers(
  sections: AdventureSection[],
  setSections: React.Dispatch<React.SetStateAction<AdventureSection[]>>
) {
  const handleEncounterTitleChange = (sectionIndex: number, sceneIndex: number, encounterIndex: number, newTitle: string) => {
    const updatedSections = sections.map((section, sIdx) => {
      if (sIdx === sectionIndex) {
        const updatedScenes = section.scenes.map((scene, scIdx) => {
          if (scIdx === sceneIndex) {
            const updatedEncounters = scene.encounters.map((encounter, eIdx) => {
              if (eIdx === encounterIndex) {
                const newId = slugify(newTitle, { lower: true, strict: true })
                return { ...encounter, title: newTitle, id: newId }
              }
              return encounter
            })
            return { ...scene, encounters: updatedEncounters }
          }
          return scene
        })
        return { ...section, scenes: updatedScenes }
      }
      return section
    })
    setSections(updatedSections)
  }

  const handleEncounterIntroChange = (sectionIndex: number, sceneIndex: number, encounterIndex: number, newIntro: string) => {
    const updatedSections = sections.map((section, sIdx) => {
      if (sIdx === sectionIndex) {
        const updatedScenes = section.scenes.map((scene, scIdx) => {
          if (scIdx === sceneIndex) {
            const updatedEncounters = scene.encounters.map((encounter, eIdx) => {
              if (eIdx === encounterIndex) {
                return { ...encounter, intro: newIntro }
              }
              return encounter
            })
            return { ...scene, encounters: updatedEncounters }
          }
          return scene
        })
        return { ...section, scenes: updatedScenes }
      }
      return section
    })
    setSections(updatedSections)
  }

  const handleEncounterIdChange = (sectionIndex: number, sceneIndex: number, encounterIndex: number, newId: string) => {
    const updatedSections = sections.map((section, sIdx) => {
      if (sIdx === sectionIndex) {
        const updatedScenes = section.scenes.map((scene, scIdx) => {
          if (scIdx === sceneIndex) {
            const updatedEncounters = scene.encounters.map((encounter, eIdx) => {
              if (eIdx === encounterIndex) {
                return { ...encounter, id: newId }
              }
              return encounter
            })
            return { ...scene, encounters: updatedEncounters }
          }
          return scene
        })
        return { ...section, scenes: updatedScenes }
      }
      return section
    })
    setSections(updatedSections)
  }

  const handleEncounterInstructionsChange = (sectionIndex: number, sceneIndex: number, encounterIndex: number, newInstructions: string) => {
    setSections((prevSections) =>
      prevSections.map((section, sIdx) => {
        if (sIdx === sectionIndex) {
          return {
            ...section,
            scenes: section.scenes.map((scene, scIdx) => {
              if (scIdx === sceneIndex) {
                return {
                  ...scene,
                  encounters: scene.encounters.map((encounter, eIdx) => {
                    if (eIdx === encounterIndex) {
                      return { ...encounter, instructions: newInstructions }
                    }
                    return encounter
                  }),
                }
              }
              return scene
            }),
          }
        }
        return section
      })
    )
  }

  const handleEncounterSkipInitialNpcTurnsChange = (sectionIndex: number, sceneIndex: number, encounterIndex: number, newValue: boolean) => {
    setSections((prevSections) =>
      prevSections.map((section, sIdx) => {
        if (sIdx === sectionIndex) {
          return {
            ...section,
            scenes: section.scenes.map((scene, scIdx) => {
              if (scIdx === sceneIndex) {
                return {
                  ...scene,
                  encounters: scene.encounters.map((encounter, eIdx) => {
                    if (eIdx === encounterIndex) {
                      return { ...encounter, skipInitialNpcTurns: newValue }
                    }
                    return encounter
                  }),
                }
              }
              return scene
            }),
          }
        }
        return section
      })
    )
  }

  const handleEncounterResetHealthChange = (sectionIndex: number, sceneIndex: number, encounterIndex: number, newValue: boolean) => {
    setSections((prevSections) =>
      prevSections.map((section, sIdx) => {
        if (sIdx === sectionIndex) {
          return {
            ...section,
            scenes: section.scenes.map((scene, scIdx) => {
              if (scIdx === sceneIndex) {
                return {
                  ...scene,
                  encounters: scene.encounters.map((encounter, eIdx) => {
                    if (eIdx === encounterIndex) {
                      return { ...encounter, resetHealth: newValue }
                    }
                    return encounter
                  }),
                }
              }
              return scene
            }),
          }
        }
        return section
      })
    )
  }

  const handleEncounterImageChange = (sectionIndex: number, sceneIndex: number, encounterIndex: number, newImageUrl: string) => {
    setSections((prevSections) =>
      prevSections.map((section, sIndex) => {
        if (sIndex === sectionIndex) {
          return {
            ...section,
            scenes: section.scenes.map((scene, scIndex) => {
              if (scIndex === sceneIndex) {
                return {
                  ...scene,
                  encounters: scene.encounters.map((encounter, eIndex) => {
                    if (eIndex === encounterIndex) {
                      return {
                        ...encounter,
                        image: newImageUrl,
                      }
                    }
                    return encounter
                  }),
                }
              }
              return scene
            }),
          }
        }
        return section
      })
    )
  }

  const handleEncounterDelete = (sectionIndex: number, sceneIndex: number, encounterIndex: number) => {
    setSections((prevSections) =>
      prevSections.map((section, sIndex) => {
        if (sIndex === sectionIndex) {
          return {
            ...section,
            scenes: section.scenes.map((scene, scIndex) => {
              if (scIndex === sceneIndex) {
                return {
                  ...scene,
                  encounters: scene.encounters.filter((_, eIndex) => eIndex !== encounterIndex),
                }
              }
              return scene
            }),
          }
        }
        return section
      })
    )
  }

  const handleEncounterTransitionsChange = (sectionIndex: number, sceneIndex: number, encounterIndex: number, newTransitions: { condition: string; encounter: string }[]) => {
    setSections((prevSections) =>
      prevSections.map((section, sIndex) => {
        if (sIndex === sectionIndex) {
          return {
            ...section,
            scenes: section.scenes.map((scene, scIndex) => {
              if (scIndex === sceneIndex) {
                return {
                  ...scene,
                  encounters: scene.encounters.map((encounter, eIndex) => {
                    if (eIndex === encounterIndex) {
                      return { ...encounter, transitions: newTransitions }
                    }
                    return encounter
                  }),
                }
              }
              return scene
            }),
          }
        }
        return section
      })
    )
  }

  const handleEncounterNpcChange = (sectionIndex: number, sceneIndex: number, encounterIndex: number, newNpcs: { id: string; behavior: string; initialInitiative?: number }[]) => {
    setSections((prevSections) =>
      prevSections.map((section, sIndex) => {
        if (sIndex === sectionIndex) {
          return {
            ...section,
            scenes: section.scenes.map((scene, scIndex) => {
              if (scIndex === sceneIndex) {
                return {
                  ...scene,
                  encounters: scene.encounters.map((encounter, eIndex) => {
                    if (eIndex === encounterIndex) {
                      return { ...encounter, npc: newNpcs }
                    }
                    return encounter
                  }),
                }
              }
              return scene
            }),
          }
        }
        return section
      })
    )
  }

  return {
    handleEncounterTitleChange,
    handleEncounterIntroChange,
    handleEncounterIdChange,
    handleEncounterInstructionsChange,
    handleEncounterSkipInitialNpcTurnsChange,
    handleEncounterResetHealthChange,
    handleEncounterImageChange,
    handleEncounterDelete,
    handleEncounterTransitionsChange,
    handleEncounterNpcChange,
  }
} 

/*
  File: components/checkout/stripe-payment-form.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/checkout/stripe-payment-form.tsx
  Directory: components/checkout
*/

--- File: components/checkout/stripe-payment-form.tsx ---

"use client"

import { useState } from "react"
import { loadStripe } from "@stripe/stripe-js"
import { PaymentElement, Elements, useStripe, useElements } from "@stripe/react-stripe-js"
import { Button } from "@/components/ui/button"

const stripePromise = loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!)

interface PaymentFormProps {
  quantity: number
  userId: string
  onSuccess?: () => void
  discountCode: string
}

function PaymentForm({ quantity, userId, onSuccess, discountCode }: PaymentFormProps) {
  const stripe = useStripe()
  const elements = useElements()
  const [loading, setLoading] = useState(false)

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    if (!stripe || !elements || loading) return

    setLoading(true)

    try {
      const { error, paymentIntent } = await stripe.confirmPayment({
        elements,
        redirect: "if_required",
      })

      if (error) {
        console.error("Payment error:", error)
        return
      }

      if (paymentIntent.status === "succeeded") {
        await fetch("/api/credits/add", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            paymentIntentId: paymentIntent.id,
            userId,
            quantity,
            discountCode,
          }),
        })

        onSuccess?.()
      }
    } catch (error) {
      console.error("Payment processing error:", error)
    } finally {
      setLoading(false)
    }
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div className="max-h-[400px] overflow-y-auto pr-2">
        <PaymentElement />
      </div>
      <Button type="submit" disabled={!stripe || loading} className="w-full mt-4">
        {loading ? "Processing..." : "Pay Now"}
      </Button>
    </form>
  )
}

interface StripePaymentFormProps extends PaymentFormProps {
  clientSecret: string
}

export function StripePaymentForm({ clientSecret, quantity, userId, onSuccess, discountCode }: StripePaymentFormProps) {
  return (
    <Elements stripe={stripePromise} options={{ clientSecret }}>
      <PaymentForm quantity={quantity} userId={userId} onSuccess={onSuccess} discountCode={discountCode} />
    </Elements>
  )
}


/*
  File: components/contact/contact-dialog.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/contact/contact-dialog.tsx
  Directory: components/contact
*/

--- File: components/contact/contact-dialog.tsx ---

"use client"

import { useState } from "react"
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog"
import { ContactForm } from "./contact-form"

interface ContactDialogProps {
  trigger: React.ReactNode
  subject?: string
}

export function ContactDialog({ trigger, subject }: ContactDialogProps) {
  const [open, setOpen] = useState(false)

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>{trigger}</DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Contact Us</DialogTitle>
          <DialogDescription>Send us a message and we&apos;ll get back to you as soon as possible.</DialogDescription>
        </DialogHeader>
        <ContactForm subject={subject} onSuccess={() => setOpen(false)} />
      </DialogContent>
    </Dialog>
  )
}


/*
  File: components/contact/contact-form.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/contact/contact-form.tsx
  Directory: components/contact
*/

--- File: components/contact/contact-form.tsx ---

"use client"

import { useState } from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Textarea } from "@/components/ui/textarea"
import { toast } from "sonner"
import { sendContactEmail } from "@/app/_actions/contact"
import { useTheme } from "next-themes"
import ReCAPTCHA from "react-google-recaptcha"

interface ContactFormProps {
  subject?: string
  onSuccess?: () => void
  requireCaptcha?: boolean
}

export function ContactForm({ subject = "Contact Message", onSuccess, requireCaptcha = false }: ContactFormProps) {
  const [isLoading, setIsLoading] = useState(false)
  const [captchaToken, setCaptchaToken] = useState<string | null>(null)
  const { theme } = useTheme()

  async function onSubmit(event: React.FormEvent<HTMLFormElement>) {
    event.preventDefault()
    setIsLoading(true)

    const formData = new FormData(event.currentTarget)
    const data = {
      name: formData.get("name") as string,
      email: formData.get("email") as string,
      message: formData.get("message") as string,
      subject,
      ...(requireCaptcha && captchaToken && { captchaToken }),
    }

    try {
      if (requireCaptcha && !captchaToken) {
        throw new Error("Please complete the reCAPTCHA verification")
      }

      const result = await sendContactEmail(data)

      if (result.success) {
        toast.success("Message sent", {
          description: "We'll get back to you as soon as possible.",
        })
        onSuccess?.()
        // Reset form
        event.currentTarget.reset()
        setCaptchaToken(null)
      } else {
        throw new Error(result.error)
      }
    } catch (err) {
      const error = err as Error
      toast.error("Error", {
        description: error.message || "There was a problem sending your message. Please try again.",
      })
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <form onSubmit={onSubmit}>
      <div className="grid gap-4">
        <div className="grid gap-2">
          <Label htmlFor="name">Name</Label>
          <Input id="name" name="name" placeholder="Your name" required />
        </div>
        <div className="grid gap-2">
          <Label htmlFor="email">Email</Label>
          <Input id="email" name="email" type="email" placeholder="your@email.com" required />
        </div>
        <div className="grid gap-2">
          <Label htmlFor="message">Message</Label>
          <Textarea id="message" name="message" placeholder="Your message" required />
        </div>
        {requireCaptcha && (
          <div className="w-full">
            <ReCAPTCHA sitekey={process.env.NEXT_PUBLIC_RECAPTCHA_SITE_KEY || ""} theme={theme === "dark" ? "dark" : "light"} onChange={(value) => setCaptchaToken(value)} />
          </div>
        )}
      </div>
      <div className="mt-4 flex justify-end">
        <Button type="submit" disabled={isLoading || (requireCaptcha && !captchaToken)}>
          {isLoading ? "Sending..." : "Send Message"}
        </Button>
      </div>
    </form>
  )
}


/*
  File: components/demo/ai-demo-client.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/demo/ai-demo-client.tsx
  Directory: components/demo
*/

--- File: components/demo/ai-demo-client.tsx ---

"use client"
import { useState } from "react"
import { Button } from "@/components/ui/button"
import { Textarea } from "@/components/ui/textarea"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { useGenerateText } from "@/app/_hooks/useGenerateText"
import { useGenerateStrings } from "@/app/_hooks/useGenerateStrings"
import { useGenerateObject } from "@/app/_hooks/useGenerateObject"
import { useGenerateImage } from "@/app/_hooks/useGenerateImage"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Input } from "@/components/ui/input"
import Image from "next/image"
import { z } from "zod"

const personSchema = z.object({
  name: z.string().describe("The person's full name"),
  age: z.number().describe("The person's age"),
  occupation: z.string().describe("The person's job or profession"),
  interests: z.array(z.string()).describe("List of the person's hobbies and interests"),
  contact: z
    .object({
      email: z.string().email().describe("The person's email address"),
      phone: z.string().describe("The person's phone number"),
    })
    .describe("Contact information"),
})

export function AIDemoClient({ isMissingReplicateToken }: { isMissingReplicateToken: boolean }) {
  const [generatedText, setGeneratedText] = useState("")
  const [generatedStrings, setGeneratedStrings] = useState<string[]>([])
  const [isGenerating, setIsGenerating] = useState(false)
  const { streamText } = useGenerateText()
  const { generate: generateStrings } = useGenerateStrings()
  const { generate: generateObject, object: generatedObject, isLoading: isGeneratingObject } = useGenerateObject(personSchema)
  const { generate: generateImage, imageUrl, isLoading: isGeneratingImage, error: imageError } = useGenerateImage()

  const handleGenerateText = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    const formData = new FormData(e.currentTarget)
    const prompt = formData.get("prompt") as string

    if (!prompt) return

    setIsGenerating(true)
    try {
      await streamText(prompt, (output: string) => {
        setGeneratedText(output)
      })
    } catch (error) {
      console.error("Error generating text:", error)
    } finally {
      setIsGenerating(false)
    }
  }

  const handleGenerateStrings = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    const formData = new FormData(e.currentTarget)
    const prompt = formData.get("prompt") as string
    const count = Number(formData.get("count")) || 6

    if (!prompt) return

    setIsGenerating(true)
    try {
      const strings = await generateStrings(prompt, count)
      setGeneratedStrings(strings)
    } catch (error) {
      console.error("Error generating strings:", error)
    } finally {
      setIsGenerating(false)
    }
  }

  const handleGenerateObject = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    const formData = new FormData(e.currentTarget)
    const prompt = formData.get("prompt") as string

    if (!prompt) return

    await generateObject(prompt)
  }

  const handleGenerateImage = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    const formData = new FormData(e.currentTarget)
    const prompt = formData.get("prompt") as string

    if (!prompt) return

    await generateImage(prompt)
  }

  return (
    <Tabs defaultValue="text" className="space-y-8">
      <TabsList className="grid w-full grid-cols-4">
        <TabsTrigger value="text">Text</TabsTrigger>
        <TabsTrigger value="strings">String Array</TabsTrigger>
        <TabsTrigger value="object">Structured Data</TabsTrigger>
        <TabsTrigger value="image">Image</TabsTrigger>
      </TabsList>

      <TabsContent value="text" className="space-y-8">
        <Card>
          <CardHeader>
            <CardTitle className="flex justify-between items-center">
              <div>Text Generation</div>
              <div className="font-mono text-sm font-normal text-primary">useGenerateText()</div>
            </CardTitle>
            <CardDescription>Enter a prompt and the AI will generate text based on your input.</CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={handleGenerateText} className="space-y-4">
              <Textarea name="prompt" placeholder="Enter your prompt here..." className="min-h-[100px]" />
              <Button type="submit" className="w-full" disabled={isGenerating}>
                {isGenerating ? "Generating..." : "Generate Text"}
              </Button>
            </form>
          </CardContent>
        </Card>

        {generatedText && (
          <Card>
            <CardHeader>
              <CardTitle>Generated Text</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="whitespace-pre-wrap">{generatedText}</div>
            </CardContent>
          </Card>
        )}
      </TabsContent>

      <TabsContent value="strings" className="space-y-8">
        <Card>
          <CardHeader>
            <CardTitle className="flex justify-between items-center">
              <div>String Array Generation</div>
              <div className="font-mono text-sm font-normal text-primary">useGenerateStrings()</div>
            </CardTitle>
            <CardDescription>Generate multiple strings based on your prompt. Useful for brainstorming names, titles, or ideas.</CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={handleGenerateStrings} className="space-y-4">
              <Textarea name="prompt" placeholder="Enter your prompt here..." className="min-h-[100px]" />
              <div className="flex items-center gap-4">
                <Input type="number" name="count" defaultValue="6" min="1" max="20" className="w-24" />
                <span className="text-sm text-muted-foreground">Number of strings to generate</span>
              </div>
              <Button type="submit" className="w-full" disabled={isGenerating}>
                {isGenerating ? "Generating..." : "Generate Strings"}
              </Button>
            </form>
          </CardContent>
        </Card>

        {generatedStrings.length > 0 && (
          <Card>
            <CardHeader>
              <CardTitle>Generated Strings</CardTitle>
            </CardHeader>
            <CardContent>
              <ul className="list-disc pl-6 space-y-2">
                {generatedStrings.map((string, index) => (
                  <li key={index}>{string}</li>
                ))}
              </ul>
            </CardContent>
          </Card>
        )}
      </TabsContent>

      <TabsContent value="object" className="space-y-8">
        <Card>
          <CardHeader>
            <CardTitle className="flex justify-between items-center">
              <div>Structured Data Generation</div>
              <div className="font-mono text-sm font-normal text-primary">useGenerateObject()</div>
            </CardTitle>
            <CardDescription>Generate structured data about a person. The AI will create a profile with name, age, occupation, interests, and contact information.</CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={handleGenerateObject} className="space-y-4">
              <Textarea name="prompt" placeholder="Describe the person you want to generate data for..." className="min-h-[100px]" />
              <Button type="submit" className="w-full" disabled={isGeneratingObject}>
                {isGeneratingObject ? "Generating..." : "Generate Profile"}
              </Button>
            </form>
          </CardContent>
        </Card>

        {generatedObject && (
          <Card>
            <CardHeader>
              <CardTitle>Generated Profile</CardTitle>
            </CardHeader>
            <CardContent>
              <dl className="space-y-4">
                <div>
                  <dt className="font-semibold">Name</dt>
                  <dd>{generatedObject.name}</dd>
                </div>
                <div>
                  <dt className="font-semibold">Age</dt>
                  <dd>{generatedObject.age}</dd>
                </div>
                <div>
                  <dt className="font-semibold">Occupation</dt>
                  <dd>{generatedObject.occupation}</dd>
                </div>
                {generatedObject.interests && (
                  <div>
                    <dt className="font-semibold">Interests</dt>
                    <dd>
                      <ul className="list-disc pl-6">
                        {generatedObject.interests.map((interest, index) => (
                          <li key={index}>{interest}</li>
                        ))}
                      </ul>
                    </dd>
                  </div>
                )}
                {generatedObject.contact && (
                  <div>
                    <dt className="font-semibold">Contact</dt>
                    <dd className="space-y-1">
                      <div>Email: {generatedObject.contact.email}</div>
                      <div>Phone: {generatedObject.contact.phone}</div>
                    </dd>
                  </div>
                )}
              </dl>
            </CardContent>
          </Card>
        )}
      </TabsContent>

      <TabsContent value="image" className="space-y-8">
        <Card>
          <CardHeader>
            <CardTitle className="flex justify-between items-center">
              <div>Image Generation</div>
              <div className="font-mono text-sm font-normal text-primary">useGenerateImage()</div>
            </CardTitle>
            <CardDescription>Generate an image based on your description.</CardDescription>
          </CardHeader>
          <CardContent>
            {isMissingReplicateToken ? (
              <div className="flex flex-col items-center justify-center h-32 p-4 bg-muted rounded-lg text-red-600">
                <p>Please configure your Replicate API token to enable image generation.</p>
              </div>
            ) : (
              <>
                <div className="font-mono text-xs -mt-4 mb-1 w-full text-right text-muted-foreground">black-forest-labs/flux-schnell</div>
                <form onSubmit={handleGenerateImage} className="space-y-4">
                  <Textarea name="prompt" placeholder="Describe the image you want to generate..." className="min-h-[100px]" />
                  <Button type="submit" className="w-full" disabled={isGeneratingImage}>
                    {isGeneratingImage ? "Generating..." : "Generate Image"}
                  </Button>
                </form>
              </>
            )}
          </CardContent>
        </Card>

        {imageError && (
          <Card className="border-destructive">
            <CardHeader>
              <CardTitle className="text-destructive">Error</CardTitle>
            </CardHeader>
            <CardContent>
              <p>{imageError}</p>
            </CardContent>
          </Card>
        )}

        {imageUrl && !imageError && (
          <Card>
            <CardHeader>
              <CardTitle>Generated Image</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="relative aspect-[2/3] w-full overflow-hidden rounded-lg">
                <Image src={imageUrl} alt="AI generated image" fill className="object-cover" sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw" priority />
              </div>
            </CardContent>
          </Card>
        )}
      </TabsContent>
    </Tabs>
  )
}


/*
  File: components/demo/upload-demo-client.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/demo/upload-demo-client.tsx
  Directory: components/demo
*/

--- File: components/demo/upload-demo-client.tsx ---

"use client"

import { useState } from "react"
import { ImageUpload } from "@/components/ui/image-upload"
import { Card } from "@/components/ui/card"
import { SignInButton, useUser } from "@clerk/nextjs"
import { Button } from "@/components/ui/button"
import { LogIn } from "lucide-react"

export function UploadDemoClient() {
  const [imageUrl, setImageUrl] = useState("")
  const { isSignedIn, isLoaded } = useUser()

  if (!isLoaded) {
    return null // or a loading spinner
  }

  return (
    <Card className="p-6">
      {isSignedIn ? (
        <div className="space-y-8">
          <div>
            <h3 className="text-lg font-medium mb-2">Upload an Image</h3>
            <p className="text-sm text-muted-foreground mb-4">Drag and drop an image file or click to select one from your computer.</p>
            <ImageUpload value={imageUrl} onChange={setImageUrl} onRemove={() => setImageUrl("")} />
          </div>
          {imageUrl && (
            <div>
              <h3 className="text-lg font-medium mb-2">Uploaded Image URL</h3>
              <code className="block w-full p-4 bg-muted rounded-lg text-sm break-all">{imageUrl}</code>
            </div>
          )}
        </div>
      ) : (
        <div className="py-12 text-center space-y-4">
          <div className="flex justify-center mb-4">
            <div className="p-3 rounded-full bg-primary/10">
              <LogIn className="w-6 h-6 text-primary" />
            </div>
          </div>
          <h3 className="text-lg font-medium">Sign in to Upload Files</h3>
          <p className="text-sm text-muted-foreground mb-6">You need to be signed in to use the file upload system.</p>
          <SignInButton mode="modal">
            <Button size="lg">Sign in to Continue</Button>
          </SignInButton>
        </div>
      )}
    </Card>
  )
}


/*
  File: components/edit-profile/index.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/edit-profile/index.tsx
  Directory: components/edit-profile
*/

--- File: components/edit-profile/index.tsx ---

"use client"

import { useState } from "react"
import { toast } from "sonner"
import { useUser } from "@clerk/nextjs"
import { Edit2, Plus, X } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Textarea } from "@/components/ui/textarea"
import { Label } from "@/components/ui/label"
import { updateProfile } from "@/app/_actions/profile"

interface UserData {
  id: string
  username: string | null
  firstName: string | null
  lastName: string | null
  imageUrl: string
  unsafeMetadata?: Record<string, unknown>
}

interface Link {
  label: string
  url: string
}

interface EditProfileProps {
  user: UserData
  bio: string
  onUpdate: () => void
  isEditing: boolean
  onCancel: () => void
  onStartEdit: () => void
}

export function EditProfile({ user, bio, onUpdate, isEditing, onCancel, onStartEdit }: EditProfileProps) {
  const { user: currentUser } = useUser()
  const [loading, setLoading] = useState(false)
  const [profileData, setProfileData] = useState({
    firstName: user.firstName || "",
    lastName: user.lastName || "",
    bio: bio || "",
    website: {
      label: "Website",
      url: (user.unsafeMetadata?.website as string) || "",
    },
    twitter: {
      label: "Twitter",
      url: (user.unsafeMetadata?.twitter as string) || "",
    },
    github: {
      label: "GitHub",
      url: (user.unsafeMetadata?.github as string) || "",
    },
    customLinks: ((user.unsafeMetadata?.customLinks as Link[]) || []).map((link) => ({
      label: link.label || "",
      url: link.url || "",
    })),
  })

  const addCustomLink = () => {
    setProfileData((prev) => ({
      ...prev,
      customLinks: [...prev.customLinks, { label: "", url: "" }],
    }))
  }

  const removeCustomLink = (index: number) => {
    setProfileData((prev) => ({
      ...prev,
      customLinks: prev.customLinks.filter((_, i) => i !== index),
    }))
  }

  const updateCustomLink = (index: number, field: "label" | "url", value: string) => {
    setProfileData((prev) => ({
      ...prev,
      customLinks: prev.customLinks.map((link, i) => (i === index ? { ...link, [field]: value } : link)),
    }))
  }

  const isOwnProfile = currentUser?.username?.toLowerCase() === user.username?.toLowerCase()

  const handleSave = async () => {
    if (!currentUser || !isOwnProfile) return

    setLoading(true)
    try {
      const result = await updateProfile(currentUser.id, {
        firstName: profileData.firstName,
        lastName: profileData.lastName,
        bio: profileData.bio,
        website: profileData.website.url,
        twitter: profileData.twitter.url,
        github: profileData.github.url,
        customLinks: profileData.customLinks,
      })

      if (!result.success) {
        throw new Error(result.error)
      }

      toast.success("Profile updated", {
        description: "Your profile has been successfully updated.",
      })

      onUpdate()
    } catch (error) {
      console.error("Error updating profile:", error)
      toast.error("Error", {
        description: "Failed to update profile. Please try again.",
      })
    }
    setLoading(false)
  }

  if (!isOwnProfile) {
    return null
  }

  if (!isEditing) {
    return (
      <Button variant="outline" size="sm" onClick={onStartEdit}>
        <Edit2 className="mr-2 h-4 w-4" />
        Edit Profile
      </Button>
    )
  }

  return (
    <div className="space-y-4 w-full -mt-6">
      <h3 className="text-lg font-medium">Edit Profile</h3>
      <div>
        <Input placeholder="First Name" value={profileData.firstName} onChange={(e) => setProfileData({ ...profileData, firstName: e.target.value })} className="mb-2" />
        <Input placeholder="Last Name" value={profileData.lastName} onChange={(e) => setProfileData({ ...profileData, lastName: e.target.value })} />
      </div>
      <div>
        <h2 className="font-medium mb-2">About</h2>
        <Textarea placeholder="Tell us about yourself..." value={profileData.bio} onChange={(e) => setProfileData({ ...profileData, bio: e.target.value })} rows={4} />
      </div>
      <div>
        <div className="space-y-4">
          <div className="space-y-2 pt-2">
            <Label>Website</Label>
            <Input
              data-testid="website-url"
              value={profileData.website.url}
              onChange={(e) => setProfileData({ ...profileData, website: { ...profileData.website, url: e.target.value } })}
              placeholder="URL (e.g. https://example.com)"
            />
          </div>

          <div className="space-y-2">
            <Label>Twitter/X</Label>
            <Input
              data-testid="twitter-username"
              value={profileData.twitter.url}
              onChange={(e) => setProfileData({ ...profileData, twitter: { ...profileData.twitter, url: e.target.value } })}
              placeholder="Username (without @)"
            />
          </div>

          <div className="space-y-2">
            <Label>GitHub</Label>
            <Input
              data-testid="github-username"
              value={profileData.github.url}
              onChange={(e) => setProfileData({ ...profileData, github: { ...profileData.github, url: e.target.value } })}
              placeholder="Username"
            />
          </div>

          {profileData.customLinks.map((link, index) => (
            <div key={index} className="space-y-2">
              <div className="flex items-center justify-between">
                <div className="h-4" />
                <Button type="button" variant="ghost" size="sm" onClick={() => removeCustomLink(index)} className="h-8 w-8 p-0">
                  <X className="h-4 w-4" />
                </Button>
              </div>
              <div className="flex gap-2">
                <Input data-testid={`custom-link-${index}-label`} value={link.label} onChange={(e) => updateCustomLink(index, "label", e.target.value)} placeholder="Label" className="w-1/3" />
                <Input data-testid={`custom-link-${index}-url`} value={link.url} onChange={(e) => updateCustomLink(index, "url", e.target.value)} placeholder="URL" className="flex-1" />
              </div>
            </div>
          ))}

          <Button type="button" variant="outline" size="sm" onClick={addCustomLink} className="w-full">
            <Plus className="mr-2 h-4 w-4" />
            Add Custom Link
          </Button>
        </div>
      </div>
      <div className="flex justify-end gap-6 pt-4">
        <Button variant="ghost" onClick={onCancel} disabled={loading}>
          Cancel
        </Button>
        <Button id="saveProfileChanges" onClick={handleSave} disabled={loading} className="w-1/2">
          {loading ? "Saving..." : "Save Changes"}
        </Button>
      </div>
    </div>
  )
}


/*
  File: components/forms/mailing-list-form.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/forms/mailing-list-form.tsx
  Directory: components/forms
*/

--- File: components/forms/mailing-list-form.tsx ---

"use client"

import { useState } from "react"
import { useUser } from "@clerk/nextjs"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { subscribe } from "@/app/_actions/mailing-list"
import { toast } from "sonner"
import { useRouter } from "next/navigation"
import Link from "next/link"

export function MailingListForm({ initialEmail }: { initialEmail?: string }) {
  const router = useRouter()
  const { user, isSignedIn, isLoaded } = useUser()
  const [isLoading, setIsLoading] = useState(false)

  if (!isLoaded) {
    return null
  }

  const handleSubscribe = async () => {
    if (!isSignedIn || !user?.emailAddresses?.[0]?.emailAddress) {
      toast.error("Please sign in to join the waitlist")
      return
    }

    try {
      setIsLoading(true)
      await subscribe({
        userId: user.id,
        email: initialEmail || user.emailAddresses[0].emailAddress,
        name: user.fullName || user.firstName || null,
        // preferences: {} // Assuming subscribe action will be updated
      })
      toast.success("Successfully joined the waitlist!")
      router.refresh()
    } catch (error) {
      console.error("Error joining waitlist:", error)
      toast.error("Failed to join the waitlist. Please try again.")
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <Card className="w-full max-w-[500px] p-4 md:mt-4">
      <CardHeader className="md:pt-4">
        <CardTitle className="text-lg">Join the Waitlist</CardTitle>
        <CardDescription>Be the first to know when we launch and get exclusive early access.</CardDescription>
      </CardHeader>
      <CardContent className="md:pb-4">
        <div className="space-y-4">
          {isSignedIn ? (
            <div className="flex gap-4">
              <Button onClick={handleSubscribe} disabled={isLoading || !isSignedIn}>
                Join Waitlist
              </Button>
            </div>
          ) : (
            <p className="border p-4 rounded-lg mt-6">
              Please{" "}
              <Link href="/sign-in/" className="text-primary hover:underline">
                sign in
              </Link>{" "}
              to join the waitlist.
            </p>
          )}
          <p className="text-sm text-muted-foreground pt-4">We&apos;ll notify you as soon as we&apos;re ready. You can unsubscribe at any time.</p>
        </div>
      </CardContent>
    </Card>
  )
}


/*
  File: components/graphics/animation/LoadingAnimation.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/graphics/animation/LoadingAnimation.tsx
  Directory: components/graphics/animation
*/

--- File: components/graphics/animation/LoadingAnimation.tsx ---

"use client"
import React, { useEffect, useRef } from "react"
import Image from "next/image"
import AnimateIn from "@/components/ui/animate-in"
import { cn } from "@/lib/utils"

const spin = `@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  80% {
    transform: rotate(360deg);
  }
  99.99% {
    transform: rotate(360deg);
  }
}`

const LoadingAnimation = ({
  className,
  children,
  containerClassName,
  scrollIntoView = false,
}: {
  className?: string
  containerClassName?: string
  children?: React.ReactNode
  scrollIntoView?: boolean
}) => {
  const containerRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    if (scrollIntoView) {
      containerRef.current?.scrollIntoView({ behavior: "smooth", block: "center" })
    }
  }, [scrollIntoView])

  return (
    <div ref={containerRef} className={cn("flex flex-col items-center justify-center gap-2", containerClassName)}>
      <AnimateIn from="opacity-0 scale-0" to="opacity-100 scale-100" duration={1000} className={cn("w-full flex justify-center", className)}>
        <style>{spin}</style>
        <Image
          className="inline-block p-3 border-2 bg-black/90 border-blue-300 rounded-full overflow-hidden transition-all ease-in-out scale-75 animate-spin"
          src="/images/d20-white.svg"
          width={72}
          height={72}
          alt="Loading"
          style={{ animation: "spin 2s infinite ease-in-out", boxShadow: "0 0 2px #000, 0 0 4px #000, 0 0 8px #000, 0 0 16px #000" }}
        />
      </AnimateIn>
      {children && (
        <AnimateIn className="font-mono" style={{ textShadow: "0 2px 4px #000, 0 2px 16px #000" }} from="opacity-0" to="opacity-80" delay={1000}>
          {children}
        </AnimateIn>
      )}
    </div>
  )
}

export default LoadingAnimation


/*
  File: components/graphics/background/Parchment.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/graphics/background/Parchment.tsx
  Directory: components/graphics/background
*/

--- File: components/graphics/background/Parchment.tsx ---

import Image from "next/image"
import { cn } from "@/lib/utils"

export default function Parchment({ containerClass, imageClass }: { containerClass?: string; imageClass?: string }) {
  return (
    <div className={cn("absolute inset-0 z-0 overflow-hidden bg-gradient-to-t from-[rgba(11,0,0,.1)] to-40%", containerClass)}>
      <Image className={cn("object-cover opacity-[.133]", imageClass)} src="/images/app/backgrounds/parchment-texture.png" fill={true} alt="" priority />
    </div>
  )
}


/*
  File: components/graphics/icon.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/graphics/icon.tsx
  Directory: components/graphics
*/

--- File: components/graphics/icon.tsx ---

import { SparklesIcon } from "@heroicons/react/24/solid"

export function Icon() {
  return (
    <span className="inline-flex flex-col items-center text-fuchsia-600 dark:text-fuchsia-500 select-none">
      <SparklesIcon className="w-3.5 h-3.5 -mb-2.5 relative" />
      <span className="scale-x-200 text-lg font-medium">V</span>
    </span>
  )
}


/*
  File: components/graphics/logo-lockup.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/graphics/logo-lockup.tsx
  Directory: components/graphics
*/

--- File: components/graphics/logo-lockup.tsx ---

import { Icon } from "./icon"

export function LogoLockup() {
  return (
    <div className="flex items-center gap-3">
      <Icon />
      <span className="text-xl font-bold bg-clip-text text-transparent bg-linear-to-br dark:bg-linear-to-br from-blue-500 via-purple-700 to-indigo-500 dark:from-blue-300 dark:via-purple-500 dark:to-indigo-500">
        party starter
      </span>
    </div>
  )
}


/*
  File: components/graphics/styles.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/graphics/styles.ts
  Directory: components/graphics
*/

--- File: components/graphics/styles.ts ---

import { CSSProperties } from "react"

// Extend CSSProperties and include textWrap
interface CustomCSSProperties extends CSSProperties {
  textWrap?: "wrap" | "nowrap" | "balance" | "pretty" | "stable" | "inherit" | "initial" | "revert" | "revert-layer" | "unset"
}

export const emboss = {
  style: {
    textWrap: "balance",
    borderRadius: "255px 15px 225px 15px/15px 225px 15px 255px",
    boxShadow: "-1px 1px 8px 3px rgba(0,0,0,.25) inset",
  } as CustomCSSProperties,
  className:
    "bg-primary-700 text-base font-bold opacity-90 cursor-pointer border-2 sm:border-4 hover:border-primary-400 transition-all ease-in-out duration-500 hover:scale-105 border-primary-500 text-blue-50 hover:text-white disabled:bg-gray-600 disabled:opacity-50 uppercase tracking-widest px-6 rounded-md py-1",
}

export const paper = {
  className: "bg-amber-50 bg-contain bg-repeat brightness-150 contrast-150",
  style: { backgroundImage: `url('/images/app/backgrounds/paper-texture.png')`, backgroundSize: "33%", filter: "saturate(2) hue-rotate(330deg) contrast(1.1)" },
}


/*
  File: components/layout/header.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/layout/header.tsx
  Directory: components/layout
*/

--- File: components/layout/header.tsx ---

import Link from "next/link"
import Image from "next/image"
import AuthButtons from "../nav/auth-buttons"
import { cn } from "@/lib/utils"
import { paper } from "../graphics/styles"
import Parchment from "../graphics/background/Parchment"

export default async function Header({ path }: { path: string }) {
  const isBig = path === "" || path === "/" || path === "/start" || path === "/join"

  return (
    <header
      className={cn(
        paper.className,
        "fixed top-0 select-none z-30 flex sm:gap-1 items-center pr-2 sm:px-8 md:px-12 pt-1 sm:py-4 w-full border-b-8 border-[rgba(0,0,0,.25)]",
        !isBig && "md:px-8 sm:py-0"
      )}
      style={paper.style}
    >
      <Parchment />
      <Link className="cursor-pointer flex items-center font-display scale-90 sm:scale-100 gap-2 mix-blend-multiply" href="/">
        <Image
          className={cn("inline -mt-1 scale-90 sm:scale-100 w-12 h-12", isBig ? "sm:w-[72px] sm:h-[72px]" : "sm:w-8 sm:h-8")}
          width={isBig ? 72 : 36}
          height={isBig ? 72 : 36}
          alt=""
          src="/images/d20.jpg"
        />
        <div className="flex flex-col">
          <h1 className={cn(!isBig && "scale-[.6] -ml-12 font-semibold")} aria-label="D20 Adventures">
            <span className="sr-only">D20 Adventures</span>
            <span aria-hidden="true">
              <span className={cn("text-2xl sm:text-4xl text-primary-600 mr-1", !isBig && "text-2xl")}>D20</span>
              <span className={cn("text-xl sm:text-3xl text-primary-500 relative -top-px", !isBig && "text-xl")}>A</span>
              <span className={cn("text-lg sm:text-2xl text-primary-500 relative -top-[3px]", !isBig && "text-sm")}>dventures</span>
            </span>
          </h1>
        </div>
      </Link>
      <div className="flex flex-1 justify-end items-center scale-90 sm:scale-100 -mt-1 sm:-mt-0 gap-8 pl-4">
        <a
          className="text-lg font-display text-amber-950/60 hover:text-amber-950/80 transition-all ease-in-out duration-500 font-bold"
          href="https://discord.gg/5kEA9Tk4hG"
          style={{ textShadow: "0 0 4px #fff" }}
        >
          JOin Discord
        </a>
        <AuthButtons />
      </div>
    </header>
  )
}


/*
  File: components/layout/theme-provider.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/layout/theme-provider.tsx
  Directory: components/layout
*/

--- File: components/layout/theme-provider.tsx ---

"use client"
import { ThemeProvider as NextThemesProvider } from "next-themes"
import type { ThemeProviderProps } from "next-themes"

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}



/*
  File: components/nav/admin-breadcrumb.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/nav/admin-breadcrumb.tsx
  Directory: components/nav
*/

--- File: components/nav/admin-breadcrumb.tsx ---

import { Breadcrumb, type BreadcrumbItem } from "./breadcrumb"

interface AdminBreadcrumbProps {
  items: BreadcrumbItem[]
}

export function AdminBreadcrumb({ items }: AdminBreadcrumbProps) {
  return (
    <div className="mb-6">
      <Breadcrumb items={items} homeHref="/admin" homeLabel="Admin" />
    </div>
  )
}


/*
  File: components/nav/admin-nav-item.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/nav/admin-nav-item.tsx
  Directory: components/nav
*/

--- File: components/nav/admin-nav-item.tsx ---

"use client"

import { useEffect, useState } from "react"
import Link from "next/link"
import { usePathname } from "next/navigation"
import { useUser } from "@clerk/nextjs"
import { cn } from "@/lib/utils"
import { ShieldCheckIcon } from "lucide-react"

export function AdminNavItem() {
  const pathname = usePathname()
  const { user, isSignedIn, isLoaded } = useUser()
  const [isAdmin, setIsAdmin] = useState(false)

  useEffect(() => {
    // Check if the user is an admin when the component mounts or user changes
    const checkAdminStatus = async () => {
      if (!isLoaded || !isSignedIn || !user?.id) {
        setIsAdmin(false)
        return
      }

      try {
        // Fetch admin status from the server
        const response = await fetch("/api/check-admin")
        if (response.ok) {
          const data = await response.json()
          setIsAdmin(data.isAdmin)
        } else {
          setIsAdmin(false)
        }
      } catch (error) {
        console.error("Error checking admin status:", error)
        setIsAdmin(false)
      }
    }

    checkAdminStatus()
  }, [isLoaded, isSignedIn, user?.id])

  // Only render the admin link if the user is an admin
  if (!isAdmin) {
    return null
  }

  return (
    <Link href="/admin" className={cn("text-sm font-medium transition-colors hover:text-primary flex items-center gap-1", pathname.startsWith("/admin") ? "text-primary" : "text-muted-foreground")}>
      <ShieldCheckIcon className="h-4 w-4" />
      Admin
    </Link>
  )
}


/*
  File: components/nav/auth-buttons.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/nav/auth-buttons.tsx
  Directory: components/nav
*/

--- File: components/nav/auth-buttons.tsx ---

"use client"

import { SignedIn, SignedOut, SignInButton, SignUpButton, UserButton } from "@clerk/nextjs"
import { Button } from "@/components/ui/button"
import { useTokens } from "@/lib/context/TokenContext"
import TokenCount from "./token-count"
import { useState, useEffect } from "react"

export default function AuthButtons() {
  const { tokensRemaining, isLoading: isLoadingTokens } = useTokens()
  const [mounted, setMounted] = useState(false)

  useEffect(() => {
    setMounted(true)
  }, [])

  // Prevent hydration mismatch by showing a neutral state until mounted
  if (!mounted) {
    return (
      <div className={`flex items-center overflow-hidden transition-[width] duration-300 ease-in-out`}>
        <div className="flex gap-2 sm:gap-4 whitespace-nowrap sm:px-2">
          {/* Placeholder buttons that match the signed-out state */}
          <Button className="text-[11px] sm:text-sm py-1 px-2 sm:px-4 my-2 tracking-tight sm:tracking-normal font-display normal-case opacity-0" variant="emboss">
            Sign In
          </Button>
          <Button className="text-[11px] sm:text-sm py-1 px-2 sm:px-4 my-2 tracking-tight sm:tracking-normal font-display normal-case opacity-0" variant="emboss">
            Sign Up
          </Button>
        </div>
      </div>
    )
  }

  return (
    <div className={`flex items-center overflow-hidden transition-[width] duration-300 ease-in-out`}>
      <SignedOut>
        <div className="flex gap-2 sm:gap-4 whitespace-nowrap sm:px-2">
          <SignInButton mode="modal">
            <Button id="signinButton" className="text-[11px] sm:text-sm py-1 px-2 sm:px-4 my-2 tracking-tight sm:tracking-normal font-display normal-case" variant="emboss">
              Sign In
            </Button>
          </SignInButton>
          <SignUpButton mode="modal">
            <Button id="signupButton" className="text-[11px] sm:text-sm py-1 px-2 sm:px-4 my-2 tracking-tight sm:tracking-normal font-display normal-case" variant="emboss">
              Sign Up
            </Button>
          </SignUpButton>
        </div>
      </SignedOut>
      <SignedIn>
        <div className="flex items-center gap-1.5 saturate-50">
          <div className="flex items-center gap-0.5 text-xs sm:text-sm text-muted-foreground">
            {!isLoadingTokens && typeof tokensRemaining === "number" && <TokenCount tokensRemaining={tokensRemaining} />}
          </div>
          <UserButton userProfileUrl="/account" />
        </div>
      </SignedIn>
    </div>
  )
}


/*
  File: components/nav/breadcrumb.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/nav/breadcrumb.tsx
  Directory: components/nav
*/

--- File: components/nav/breadcrumb.tsx ---

import Link from "next/link"
import { ChevronRight } from "lucide-react"

export interface BreadcrumbItem {
  label: string
  href?: string
}

interface BreadcrumbProps {
  items: BreadcrumbItem[]
  homeHref?: string
  homeLabel?: string
}

export function Breadcrumb({ items, homeHref = "/", homeLabel = "Home" }: BreadcrumbProps) {
  return (
    <nav className="flex items-center text-sm text-muted-foreground">
      <Link href={homeHref} className="hover:text-foreground transition-colors">
        {homeLabel}
      </Link>
      {items.map((item, index) => (
        <div key={item.label} className="flex items-center">
          <ChevronRight className="h-4 w-4 mx-1" />
          {index === items.length - 1 ? (
            <span className="text-foreground font-medium">{item.label}</span>
          ) : (
            <Link href={item.href!} className="hover:text-foreground transition-colors">
              {item.label}
            </Link>
          )}
        </div>
      ))}
    </nav>
  )
}


/*
  File: components/nav/main-nav.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/nav/main-nav.tsx
  Directory: components/nav
*/

--- File: components/nav/main-nav.tsx ---

"use client"

import Link from "next/link"
import { usePathname } from "next/navigation"
import { LogoLockup } from "@/components/graphics/logo-lockup"
import { cn } from "@/lib/utils"
import { navItems } from "@/lib/config/navigation"
import { siteConfig } from "@/lib/config"
import Image from "next/image"
import { Icon } from "@radix-ui/react-select"
interface MainNavProps {
  isAdmin: boolean
}

export function MainNav({ isAdmin }: MainNavProps) {
  const pathname = usePathname()

  return (
    <nav className="flex gap-6 items-center">
      <Link href="/" className="mr-4">
        {siteConfig.title === ("Vibecode Party Starter" as string) ? (
          <LogoLockup />
        ) : (
          <div className="flex items-center gap-3">
            {siteConfig.logo ? <Image src={siteConfig.logo} alt={siteConfig.title + " logo"} width={32} height={32} /> : <Icon />}
            <span className="text-xl font-bold bg-clip-text text-transparent bg-linear-to-br dark:bg-linear-to-br from-blue-500 via-purple-700 to-indigo-500 dark:from-blue-300 dark:via-purple-500 dark:to-indigo-500">
              {siteConfig.title}
            </span>
          </div>
        )}
      </Link>

      {navItems.map((item) => (
        <Link key={item.href} href={item.href} className={cn("text-sm mt-1 font-medium transition-colors hover:text-primary", pathname === item.href ? "text-primary" : "text-muted-foreground")}>
          {item.title}
        </Link>
      ))}

      {isAdmin && (
        <Link href="/admin" className={cn("text-sm mt-1 font-medium transition-colors hover:text-primary", pathname?.startsWith("/admin") ? "text-primary" : "text-muted-foreground")}>
          Admin
        </Link>
      )}
    </nav>
  )
}


/*
  File: components/nav/mobile-nav.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/nav/mobile-nav.tsx
  Directory: components/nav
*/

--- File: components/nav/mobile-nav.tsx ---

"use client"

import { useState } from "react"
import Link from "next/link"
import { usePathname } from "next/navigation"
import { Menu, ShieldCheck } from "lucide-react"
import { LogoLockup } from "@/components/graphics/logo-lockup"
import { Button } from "@/components/ui/button"
import { Sheet, SheetContent, SheetTitle, SheetTrigger } from "@/components/ui/sheet"
import { cn } from "@/lib/utils"
import { useUser } from "@clerk/nextjs"
import { useEffect } from "react"
import { SignedIn, SignedOut, SignInButton, SignUpButton, UserButton } from "@clerk/nextjs"
import { navItems } from "@/lib/config/navigation"
import { siteConfig } from "@/lib/config"
import Image from "next/image"

export function MobileNav() {
  const [open, setOpen] = useState(false)
  const [isAdmin, setIsAdmin] = useState(false)
  const pathname = usePathname()
  const { user, isSignedIn, isLoaded } = useUser()

  useEffect(() => {
    // Check if the user is an admin when the component mounts or user changes
    const checkAdminStatus = async () => {
      if (!isLoaded || !isSignedIn || !user?.id) {
        setIsAdmin(false)
        return
      }

      try {
        // Fetch admin status from the server
        const response = await fetch("/api/check-admin")
        if (response.ok) {
          const data = await response.json()
          setIsAdmin(data.isAdmin)
        } else {
          setIsAdmin(false)
        }
      } catch (error) {
        console.error("Error checking admin status:", error)
        setIsAdmin(false)
      }
    }

    checkAdminStatus()
  }, [isLoaded, isSignedIn, user?.id])

  return (
    <Sheet open={open} onOpenChange={setOpen}>
      <SheetTrigger asChild>
        <Button variant="ghost" size="icon" className="md:hidden">
          <Menu className="h-5 w-5" />
          <span className="sr-only">Toggle menu</span>
        </Button>
      </SheetTrigger>
      <SheetContent side="left" className="flex flex-col">
        <SheetTitle className="sr-only">Menu</SheetTitle>
        <div className="flex items-center justify-between border-b pb-4">
          <Link href="/" className="flex items-center space-x-2 pl-4 pt-4" onClick={() => setOpen(false)}>
            {siteConfig.title === ("Vibecode Party Starter" as string) ? (
              <LogoLockup />
            ) : (
              <div className="flex items-center gap-3">
                {siteConfig.logo && <Image src={siteConfig.logo} alt={siteConfig.title + " logo"} width={32} height={32} />}
                <span className="text-xl font-bold bg-clip-text text-transparent bg-linear-to-br dark:bg-linear-to-br from-blue-500 via-purple-700 to-indigo-500 dark:from-blue-300 dark:via-purple-500 dark:to-indigo-500">
                  {siteConfig.title}
                </span>
              </div>
            )}
          </Link>
        </div>
        <nav className="mt-6 flex flex-col gap-4 pl-10">
          {navItems.map((item) => (
            <Link
              key={item.href}
              href={item.href}
              className={cn("text-lg font-medium transition-colors hover:text-primary", pathname === item.href ? "text-primary" : "text-muted-foreground")}
              onClick={() => setOpen(false)}
            >
              {item.title}
            </Link>
          ))}

          {/* Admin link - only visible to admin users */}
          {isAdmin && (
            <Link
              href="/admin"
              className={cn("text-lg font-medium transition-colors hover:text-primary flex items-center gap-2", pathname.startsWith("/admin") ? "text-primary" : "text-muted-foreground")}
              onClick={() => setOpen(false)}
            >
              <ShieldCheck className="h-5 w-5" />
              Admin
            </Link>
          )}
        </nav>
        <div className="mt-auto flex flex-col gap-4 p-8">
          <SignedOut>
            <SignUpButton mode="modal">
              <Button className="w-full" onClick={() => setOpen(false)}>
                Sign Up
              </Button>
            </SignUpButton>
            <SignInButton mode="modal">
              <Button variant="outline" className="w-full" onClick={() => setOpen(false)}>
                Sign In
              </Button>
            </SignInButton>
          </SignedOut>
          <SignedIn>
            <div className="flex items-center justify-center">
              <UserButton afterSignOutUrl="/" userProfileUrl="/settings/profile" />
            </div>
          </SignedIn>
        </div>
      </SheetContent>
    </Sheet>
  )
}


/*
  File: components/nav/theme-toggle.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/nav/theme-toggle.tsx
  Directory: components/nav
*/

--- File: components/nav/theme-toggle.tsx ---

"use client"

import { useTheme } from "next-themes"
import { Moon, Sun } from "lucide-react"

import { Button } from "@/components/ui/button"
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu"

export function ThemeToggle() {
  const { setTheme } = useTheme()

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" size="icon">
          <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>Light</DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>Dark</DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>System</DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}



/*
  File: components/nav/token-count.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/nav/token-count.tsx
  Directory: components/nav
*/

--- File: components/nav/token-count.tsx ---

"use client"

import { Sparkle } from "lucide-react"
import { HoverCard, HoverCardContent, HoverCardTrigger } from "@/components/ui/hover-card"
import { formatNumberToK } from "@/lib/utils"

interface TokenCountProps {
  tokensRemaining: number
}

export default function TokenCount({ tokensRemaining }: TokenCountProps) {
  return (
    <HoverCard>
      <HoverCardTrigger asChild>
        <div id="tokenCount" className="flex items-center gap-0.5 text-xxs font-mono font-bold bg-blue-900 text-white py-0.5 px-1.5 rounded cursor-help transition-colors hover:bg-blue-800">
          <Sparkle className="w-3 h-3 scale-75" />
          <span>{formatNumberToK(tokensRemaining)}</span>
        </div>
      </HoverCardTrigger>
      <HoverCardContent align="end" className="bg-gradient-to-tl from-blue-950 to-blue-900 text-white">
        <div className="space-y-2">
          <h4 className="font-display font-bold">Tokens Remaining</h4>
          <p className="text-sm">
            You have <span className="font-mono font-semibold">{Math.round(tokensRemaining).toLocaleString()}</span> tokens for D20 gameplay. Instead of paying a monthly fee, simply buy more tokens as
            needed.
          </p>
        </div>
      </HoverCardContent>
    </HoverCard>
  )
}


/*
  File: components/profile/profile-card.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/profile/profile-card.tsx
  Directory: components/profile
*/

--- File: components/profile/profile-card.tsx ---

"use client"

import { useState } from "react"
import Link from "next/link"
import { cn } from "@/lib/utils"
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar"
import { Card, CardContent } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Separator } from "@/components/ui/separator"
import { Calendar, CheckCircle, Globe, Twitter, Github, Link as LinkIcon } from "lucide-react"
import { EditProfile } from "@/components/edit-profile"
import { refreshProfile } from "@/app/_actions/profile"
import { Heading } from "@/components/typography/heading"

interface Link {
  label: string
  url: string
}

interface ProfileCardProps {
  user: {
    id: string
    username: string | null
    firstName: string | null
    lastName: string | null
    imageUrl: string
    unsafeMetadata?: Record<string, unknown>
  }
  bio: string
  status: string
  joinedDate: string
  path: string
}

export function ProfileCard({ user, bio, status, joinedDate, path }: ProfileCardProps) {
  const [isEditing, setIsEditing] = useState(false)
  const name = user.firstName && user.lastName ? `${user.firstName} ${user.lastName}` : user.firstName || user.username || "Anonymous"
  const website = user.unsafeMetadata?.website as string
  const twitter = user.unsafeMetadata?.twitter as string
  const github = user.unsafeMetadata?.github as string
  const customLinks = (user.unsafeMetadata?.customLinks as Link[]) || []

  const handleUpdate = async () => {
    setIsEditing(false)
    await refreshProfile(path)
  }

  if (isEditing) {
    return (
      <Card>
        <CardContent className="pt-6">
          <EditProfile user={user} bio={bio} onUpdate={handleUpdate} isEditing={true} onCancel={() => setIsEditing(false)} onStartEdit={() => setIsEditing(true)} />
        </CardContent>
      </Card>
    )
  }

  const hasLinks = website || twitter || github || customLinks.length > 0

  return (
    <Card>
      <CardContent className="pt-6">
        <div className="flex flex-col items-center text-center">
          <Link href={`/participants/${user.username}`} className="block hover:opacity-80 transition-opacity">
            <Avatar className="h-24 w-24 mb-4">
              {user.imageUrl && <AvatarImage src={user.imageUrl} alt={name} />}
              <AvatarFallback>{name.substring(0, 2).toUpperCase()}</AvatarFallback>
            </Avatar>
          </Link>
          <div className="space-y-2">
            <Link href={`/participants/${user.username}`} className="block hover:text-primary transition-colors">
              <Heading variant="h1" className="text-2xl font-bold">
                {name}
              </Heading>
            </Link>
            <div className="inline-flex items-center rounded-full bg-green-100 px-3 py-1 text-sm font-medium text-green-800 dark:bg-green-900 dark:text-green-100">
              <CheckCircle className="mr-1 h-3 w-3" />
              {status.charAt(0).toUpperCase() + status.slice(1)}
            </div>
          </div>

          {hasLinks && (
            <div className="flex flex-wrap gap-2 mt-4 justify-center">
              {website && (
                <Button size="sm" variant="outline" asChild>
                  <a href={website.startsWith("http") ? website : `https://${website}`} target="_blank" rel="noopener noreferrer">
                    <Globe className="mr-2 h-4 w-4" />
                    Website
                  </a>
                </Button>
              )}
              {twitter && (
                <Button size="sm" variant="outline" asChild>
                  <a href={`https://x.com/${twitter}`} target="_blank" rel="noopener noreferrer">
                    <Twitter className="mr-2 h-4 w-4" />
                    Twitter/X
                  </a>
                </Button>
              )}
              {github && (
                <Button size="sm" variant="outline" asChild>
                  <a href={`https://github.com/${github}`} target="_blank" rel="noopener noreferrer">
                    <Github className="mr-2 h-4 w-4" />
                    GitHub
                  </a>
                </Button>
              )}
              {customLinks.map((link, index) => (
                <Button key={index} size="sm" variant="outline" asChild>
                  <a href={link.url.startsWith("http") ? link.url : `https://${link.url}`} target="_blank" rel="noopener noreferrer">
                    <LinkIcon className="mr-2 h-4 w-4" />
                    {link.label}
                  </a>
                </Button>
              ))}
            </div>
          )}
        </div>

        <Separator className="my-6" />

        <div className="space-y-4">
          <div>
            <div className="flex items-center justify-between mb-2">
              <Heading variant="h2" className="font-medium">
                About
              </Heading>
              <EditProfile user={user} bio={bio} onUpdate={handleUpdate} isEditing={false} onCancel={() => setIsEditing(false)} onStartEdit={() => setIsEditing(true)} />
            </div>
            <p className={cn("text-sm", bio ? "text-foreground" : "text-muted-foreground italic")}>{bio || "No bio created yet"}</p>
          </div>

          <div className="flex items-center gap-2">
            <Calendar className="h-4 w-4 text-muted-foreground" />
            <span className="text-sm">Joined on {joinedDate}</span>
          </div>
        </div>
      </CardContent>
    </Card>
  )
}


/*
  File: components/settings/hooks/use-setting-form.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/settings/hooks/use-setting-form.ts
  Directory: components/settings/hooks
*/

--- File: components/settings/hooks/use-setting-form.ts ---

import { useState, useCallback } from "react"
import { Setting, Location } from "@/types/setting"
import { updateSettingAction } from "@/app/_actions/setting-actions"
import { toast } from "sonner"

export function useSettingForm(initialSetting: Setting, settingId: string) {
  console.log("[useSettingForm] Hook initialized with:", JSON.stringify({
    settingId,
    initialSetting: {
      name: initialSetting?.name,
      hasDescription: !!initialSetting?.description,
      hasLocations: initialSetting?.locations?.length > 0,
      keys: initialSetting ? Object.keys(initialSetting) : 'no setting'
    }
  }, null, 2))

  const [name, setName] = useState(initialSetting.name)
  const [description, setDescription] = useState(initialSetting.description)
  const [genre, setGenre] = useState(initialSetting.genre)
  const [image, setImage] = useState(initialSetting.image)
  const [technology, setTechnology] = useState(initialSetting.technology)
  const [magic, setMagic] = useState(initialSetting.magic)
  const [locations, setLocations] = useState<Location[]>(initialSetting.locations)
  const [isPublic, setIsPublic] = useState(initialSetting.isPublic)
  const [isSaving, setIsSaving] = useState(false)

  console.log("[useSettingForm] State initialized:", JSON.stringify({
    name,
    hasDescription: !!description,
    genre,
    hasImage: !!image,
    locationsCount: locations?.length || 0,
    isPublic,
    isSaving
  }, null, 2))

  const saveSetting = useCallback(async (imageOverride?: string) => {
    setIsSaving(true)
    try {
      const settingData: Setting = {
        name,
        description,
        genre,
        image: imageOverride !== undefined ? imageOverride : image,
        technology,
        magic,
        locations,
        isPublic,
      }

      console.log("[useSettingForm] Calling updateSettingAction with:", JSON.stringify({ settingData, settingId }, null, 2))
      
      const result = await updateSettingAction({
        setting: settingData,
        settingId
      })

      if (result.success) {
        toast.success(result.message || "Setting saved successfully!")
      } else {
        console.error("Server action failed:", result.error)
        toast.error(result.error || "Failed to save setting. Please try again.")
      }
    } catch (error) {
      console.error("Error calling updateSettingAction:", error)
      toast.error("Failed to save setting. Please try again.")
    } finally {
      setIsSaving(false)
    }
  }, [settingId, name, description, genre, image, technology, magic, locations, isPublic])

  return {
    name,
    setName,
    description,
    setDescription,
    genre,
    setGenre,
    image,
    setImage,
    technology,
    setTechnology,
    magic,
    setMagic,
    locations,
    setLocations,
    isPublic,
    setIsPublic,
    isSaving,
    saveSetting,
  }
} 

/*
  File: components/settings/setting-basic-info.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/settings/setting-basic-info.tsx
  Directory: components/settings
*/

--- File: components/settings/setting-basic-info.tsx ---

"use client"

import { Textarea } from "@/components/ui/textarea"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Switch } from "@/components/ui/switch"
import { ImageUpload } from "@/components/ui/image-upload"

interface SettingBasicInfoProps {
  settingId: string
  name: string
  description: string
  genre: string
  image: string
  technology: string
  magic: string
  isPublic: boolean
  isSaving: boolean
  onNameChange: (name: string) => void
  onDescriptionChange: (description: string) => void
  onGenreChange: (genre: string) => void
  onImageChange: (url: string) => void
  onImageRemove: () => void
  onTechnologyChange: (technology: string) => void
  onMagicChange: (magic: string) => void
  onIsPublicChange: (isPublic: boolean) => void
}

export function SettingBasicInfo({
  settingId,
  name,
  description,
  genre,
  image,
  technology,
  magic,
  isPublic,
  isSaving,
  onNameChange,
  onDescriptionChange,
  onGenreChange,
  onImageChange,
  onImageRemove,
  onTechnologyChange,
  onMagicChange,
  onIsPublicChange,
}: SettingBasicInfoProps) {
  const imageUploadFolder = `images/settings/${settingId}`

  return (
    <div className="space-y-6 p-4">
      <div className="grid grid-cols-2 gap-8" id="setting-main-top">
        <div>
          <Label htmlFor="settingImage" className="block text-sm font-medium font-mono text-primary-200/90 mb-1">
            Setting Image
          </Label>
          <ImageUpload id="settingImage" value={image} onChange={onImageChange} onRemove={onImageRemove} folder={imageUploadFolder} />
        </div>

        <div className="space-y-4">
          <div>
            <Label htmlFor="settingName" className="block text-sm font-medium font-mono text-primary-200/90 mb-1">
              Setting Name
            </Label>
            <Input id="settingName" value={name} onChange={(e) => onNameChange(e.target.value)} placeholder="Enter setting name..." disabled={isSaving} />
          </div>

          <div>
            <Label htmlFor="settingGenre" className="block text-sm font-medium font-mono text-primary-200/90 mb-1">
              Genre
            </Label>
            <Input id="settingGenre" value={genre} onChange={(e) => onGenreChange(e.target.value)} placeholder="Enter genre (e.g., Fantasy, Sci-Fi, Modern)..." disabled={isSaving} />
          </div>

          <div className="flex items-center space-x-2">
            <Switch id="isPublic" checked={isPublic} onCheckedChange={onIsPublicChange} disabled={isSaving} />
            <Label htmlFor="isPublic" className="text-sm font-medium font-mono text-primary-200/90">
              Public Setting
            </Label>
          </div>
        </div>
      </div>

      <div>
        <Label htmlFor="settingDescription" className="block text-sm font-medium font-mono text-primary-200/90 mb-1">
          Description
        </Label>
        <Textarea id="settingDescription" value={description} onChange={(e) => onDescriptionChange(e.target.value)} placeholder="Describe the setting..." rows={4} disabled={isSaving} />
      </div>

      <div>
        <Label htmlFor="settingTechnology" className="block text-sm font-medium font-mono text-primary-200/90 mb-1">
          Technology
        </Label>
        <Textarea
          id="settingTechnology"
          value={technology}
          onChange={(e) => onTechnologyChange(e.target.value)}
          placeholder="Describe the technology level and available tech..."
          rows={3}
          disabled={isSaving}
        />
      </div>

      <div>
        <Label htmlFor="settingMagic" className="block text-sm font-medium font-mono text-primary-200/90 mb-1">
          Magic
        </Label>
        <Textarea id="settingMagic" value={magic} onChange={(e) => onMagicChange(e.target.value)} placeholder="Describe the magic system and availability..." rows={3} disabled={isSaving} />
      </div>
    </div>
  )
}


/*
  File: components/settings/setting-edit-form.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/settings/setting-edit-form.tsx
  Directory: components/settings
*/

--- File: components/settings/setting-edit-form.tsx ---

"use client"

import * as React from "react"
import { Setting } from "@/types/setting"
import { Button } from "@/components/ui/button"
import { SettingFormHeader } from "./setting-form-header"
import { SettingBasicInfo } from "./setting-basic-info"
import { SettingLocations } from "./setting-locations"
import { useSettingForm } from "@/components/settings/hooks/use-setting-form"
import { toast } from "sonner"

export function SettingEditForm({ setting, settingId }: { setting: Setting; settingId: string }) {
  console.log(
    "[SettingEditForm] Component mounted with:",
    JSON.stringify(
      {
        settingId,
        settingName: setting?.name,
        hasLocations: setting?.locations?.length > 0,
        settingKeys: setting ? Object.keys(setting) : "no setting",
      },
      null,
      2
    )
  )

  const {
    name,
    setName,
    description,
    setDescription,
    genre,
    setGenre,
    image,
    setImage,
    technology,
    setTechnology,
    magic,
    setMagic,
    locations,
    setLocations,
    isPublic,
    setIsPublic,
    isSaving,
    saveSetting,
  } = useSettingForm(setting, settingId)

  console.log(
    "[SettingEditForm] Hook returned state:",
    JSON.stringify(
      {
        name,
        hasDescription: !!description,
        hasImage: !!image,
        locationsCount: locations?.length || 0,
        isSaving,
      },
      null,
      2
    )
  )

  // Image handlers with auto-save
  const handleImageChange = async (newUrl: string) => {
    setImage(newUrl)
    if (newUrl) {
      await saveSetting(newUrl)
    }
  }

  const handleImageRemove = async () => {
    setImage("")
    await saveSetting("")
  }

  // Download handler
  const handleDownload = () => {
    const currentSetting: Setting = {
      name,
      description,
      genre,
      image,
      technology,
      magic,
      locations,
      isPublic,
    }

    const jsonData = JSON.stringify(currentSetting, null, 2)
    const blob = new Blob([jsonData], { type: "application/json" })
    const url = URL.createObjectURL(blob)
    const link = document.createElement("a")
    link.href = url
    link.download = `${name.replace(/[^a-z0-9]/gi, "_").toLowerCase()}_setting.json`
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
    URL.revokeObjectURL(url)
    toast.success("Setting downloaded successfully!")
  }

  console.log("[SettingEditForm] About to render, checking components...")

  // Add a simple fallback UI to ensure we can see something
  if (!setting) {
    console.error("[SettingEditForm] No setting data provided")
    return <div className="p-8 text-white">Error: No setting data provided</div>
  }

  try {
    console.log("[SettingEditForm] Rendering form components...")

    return (
      <div className="pt-12 flex flex-col h-[90vh] text-white">
        <SettingFormHeader settingId={settingId} settingName={setting.name} isSaving={isSaving} onDownload={handleDownload} onSave={() => saveSetting()} />

        <div
          id="setting-main"
          className="pt-2 pr-3 -mr-3 h-full w-full overflow-y-auto [scrollbar-width:thin] [scrollbar-color:dimgray_black] [&::-webkit-scrollbar-track]:bg-black [&::-webkit-scrollbar-thumb]:bg-black [&::-webkit-scrollbar]:w-1"
        >
          <div className="max-w-5xl mx-auto">
            <SettingBasicInfo
              settingId={settingId}
              name={name}
              description={description}
              genre={genre}
              image={image}
              technology={technology}
              magic={magic}
              isPublic={isPublic}
              isSaving={isSaving}
              onNameChange={setName}
              onDescriptionChange={setDescription}
              onGenreChange={setGenre}
              onImageChange={handleImageChange}
              onImageRemove={handleImageRemove}
              onTechnologyChange={setTechnology}
              onMagicChange={setMagic}
              onIsPublicChange={setIsPublic}
            />

            <SettingLocations settingId={settingId} locations={locations} isSaving={isSaving} onLocationsChange={setLocations} />

            <div className="flex flex-col items-end gap-4 mt-8 px-4 pb-8">
              <Button variant="epic" size="sm" onClick={() => saveSetting()} disabled={isSaving}>
                {isSaving ? "Saving..." : "Save Changes"}
              </Button>
            </div>
          </div>
        </div>
      </div>
    )
  } catch (error) {
    console.error("[SettingEditForm] Error rendering components:", error)
    return (
      <div className="p-8 text-white bg-red-900">
        <h2>Rendering Error</h2>
        <p>Error: {error instanceof Error ? error.message : "Unknown error"}</p>
        <p>Setting ID: {settingId}</p>
        <p>Setting Name: {setting?.name || "No name"}</p>
      </div>
    )
  }
}


/*
  File: components/settings/setting-form-header.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/settings/setting-form-header.tsx
  Directory: components/settings
*/

--- File: components/settings/setting-form-header.tsx ---

"use client"

import { Button } from "@/components/ui/button"
import { Download } from "lucide-react"
import Link from "next/link"

interface SettingFormHeaderProps {
  settingId: string
  settingName: string
  isSaving: boolean
  onDownload: () => void
  onSave: () => void
}

export function SettingFormHeader({ settingId, settingName, isSaving, onDownload, onSave }: SettingFormHeaderProps) {
  console.log("[SettingFormHeader] Rendering header, isSaving:", isSaving)

  return (
    <div className="w-full flex justify-between items-center p-4 border-b border-white/10 bg-black/50 backdrop-blur-sm -mt-4">
      <div className="flex gap-4">
        <h1 className="text-xl font-display text-primary-200 pl-4">Edit Setting</h1>
        <Link className="border-l border-white/20 text-xl font-display hover:text-amber-400 text-amber-300 font-bold pl-4 transition-all duration-500 ease-in-out" href={`/settings/${settingId}`}>
          {settingName}
        </Link>
      </div>
      <div className="flex gap-8 items-center">
        <Button ariaLabel="Download JSON" variant="outline" size="icon" className="text-white p-0" onClick={onDownload}>
          <Download className="w-4 h-4" />
        </Button>
        <Button variant="epic" size="sm" className="text-sm" onClick={onSave} disabled={isSaving}>
          {isSaving ? "Saving..." : "Save Changes"}
        </Button>
      </div>
    </div>
  )
}


/*
  File: components/settings/setting-locations.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/settings/setting-locations.tsx
  Directory: components/settings
*/

--- File: components/settings/setting-locations.tsx ---

"use client"

import * as React from "react"
import { Location, Organization } from "@/types/setting"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Textarea } from "@/components/ui/textarea"
import { Label } from "@/components/ui/label"
import { ImageUpload } from "@/components/ui/image-upload"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Plus, Trash2, ChevronDown, ChevronRight } from "lucide-react"
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from "@/components/ui/collapsible"

interface SettingLocationsProps {
  settingId: string
  locations: Location[]
  isSaving: boolean
  onLocationsChange: (locations: Location[]) => void
}

export function SettingLocations({ settingId, locations, isSaving, onLocationsChange }: SettingLocationsProps) {
  const [openLocations, setOpenLocations] = React.useState<Set<number>>(new Set())
  const [openOrganizations, setOpenOrganizations] = React.useState<Set<string>>(new Set())

  const toggleLocation = (index: number) => {
    setOpenLocations((prev) => {
      const newSet = new Set(prev)
      if (newSet.has(index)) {
        newSet.delete(index)
      } else {
        newSet.add(index)
      }
      return newSet
    })
  }

  const toggleOrganization = (locationIndex: number, orgIndex: number) => {
    const key = `${locationIndex}-${orgIndex}`
    setOpenOrganizations((prev) => {
      const newSet = new Set(prev)
      if (newSet.has(key)) {
        newSet.delete(key)
      } else {
        newSet.add(key)
      }
      return newSet
    })
  }

  const addLocation = () => {
    const newLocation: Location = {
      name: "",
      description: "",
      image: "",
      history: "",
      inhabitants: "",
      organizations: [],
    }
    onLocationsChange([...locations, newLocation])
  }

  const removeLocation = (index: number) => {
    const newLocations = locations.filter((_, i) => i !== index)
    onLocationsChange(newLocations)
    setOpenLocations((prev) => {
      const newSet = new Set(prev)
      newSet.delete(index)
      return newSet
    })
  }

  const updateLocation = (index: number, field: keyof Location, value: string | Organization[]) => {
    const newLocations = [...locations]
    newLocations[index] = { ...newLocations[index], [field]: value }
    onLocationsChange(newLocations)
  }

  const addOrganization = (locationIndex: number) => {
    const newOrg: Organization = {
      name: "",
      description: "",
      image: "",
    }
    const newLocations = [...locations]
    newLocations[locationIndex] = {
      ...newLocations[locationIndex],
      organizations: [...newLocations[locationIndex].organizations, newOrg],
    }
    onLocationsChange(newLocations)
  }

  const removeOrganization = (locationIndex: number, orgIndex: number) => {
    const newLocations = [...locations]
    newLocations[locationIndex] = {
      ...newLocations[locationIndex],
      organizations: newLocations[locationIndex].organizations.filter((_, i) => i !== orgIndex),
    }
    onLocationsChange(newLocations)
    const key = `${locationIndex}-${orgIndex}`
    setOpenOrganizations((prev) => {
      const newSet = new Set(prev)
      newSet.delete(key)
      return newSet
    })
  }

  const updateOrganization = (locationIndex: number, orgIndex: number, field: keyof Organization, value: string) => {
    const newLocations = [...locations]
    newLocations[locationIndex] = {
      ...newLocations[locationIndex],
      organizations: newLocations[locationIndex].organizations.map((org, i) => (i === orgIndex ? { ...org, [field]: value } : org)),
    }
    onLocationsChange(newLocations)
  }

  return (
    <div className="space-y-6 p-4">
      <div className="flex items-center justify-between">
        <h3 className="text-xl font-display font-bold text-primary-200">Locations</h3>
        <Button onClick={addLocation} size="sm" disabled={isSaving}>
          <Plus className="w-4 h-4 mr-2" />
          Add Location
        </Button>
      </div>

      <div className="space-y-4">
        {locations.map((location, locationIndex) => (
          <Card key={locationIndex} className="bg-black/20 border-white/10">
            <Collapsible open={openLocations.has(locationIndex)} onOpenChange={() => toggleLocation(locationIndex)}>
              <CollapsibleTrigger asChild>
                <CardHeader className="cursor-pointer text-white hover:text-amber-300 transition-colors duration-500 ease-in-out">
                  <CardTitle className="flex items-center justify-between">
                    <div className="flex items-center gap-2 font-display">
                      {openLocations.has(locationIndex) ? <ChevronDown className="w-4 h-4" /> : <ChevronRight className="w-4 h-4" />}
                      <span>{location.name || `Location ${locationIndex + 1}`}</span>
                    </div>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={(e) => {
                        e.stopPropagation()
                        removeLocation(locationIndex)
                      }}
                      disabled={isSaving}
                    >
                      <Trash2 className="w-4 h-4" />
                    </Button>
                  </CardTitle>
                </CardHeader>
              </CollapsibleTrigger>

              <CollapsibleContent>
                <CardContent className="space-y-4 text-white">
                  <div className="grid grid-cols-2 gap-4 text-white">
                    <div>
                      <Label className="block text-sm font-medium font-mono text-primary-200/90 mb-1">Location Image</Label>
                      <ImageUpload
                        value={location.image}
                        onChange={(url) => updateLocation(locationIndex, "image", url)}
                        onRemove={() => updateLocation(locationIndex, "image", "")}
                        folder={`images/settings/${settingId}/locations`}
                      />
                    </div>

                    <div className="space-y-4">
                      <div>
                        <Label className="block text-sm font-medium font-mono text-primary-200/90 mb-1">Name</Label>
                        <Input value={location.name} onChange={(e) => updateLocation(locationIndex, "name", e.target.value)} placeholder="Location name..." disabled={isSaving} />
                      </div>
                    </div>
                  </div>

                  <div>
                    <Label className="block text-sm font-medium font-mono text-primary-200/90 mb-1">Description</Label>
                    <Textarea
                      value={location.description}
                      onChange={(e) => updateLocation(locationIndex, "description", e.target.value)}
                      placeholder="Describe this location..."
                      rows={3}
                      disabled={isSaving}
                    />
                  </div>

                  <div>
                    <Label className="block text-sm font-medium font-mono text-primary-200/90 mb-1">History</Label>
                    <Textarea
                      value={location.history}
                      onChange={(e) => updateLocation(locationIndex, "history", e.target.value)}
                      placeholder="Historical background of this location..."
                      rows={3}
                      disabled={isSaving}
                    />
                  </div>

                  <div>
                    <Label className="block text-sm font-medium font-mono text-primary-200/90 mb-1">Inhabitants</Label>
                    <Textarea
                      value={location.inhabitants}
                      onChange={(e) => updateLocation(locationIndex, "inhabitants", e.target.value)}
                      placeholder="Who lives in this location..."
                      rows={3}
                      disabled={isSaving}
                    />
                  </div>

                  <div className="space-y-4">
                    <div className="flex items-center justify-between">
                      <h4 className="text-lg font-display font-bold text-primary-200">Organizations</h4>
                      <Button onClick={() => addOrganization(locationIndex)} size="sm" variant="outline" disabled={isSaving}>
                        <Plus className="w-4 h-4 mr-2" />
                        Add Organization
                      </Button>
                    </div>

                    <div className="space-y-2">
                      {location.organizations.map((org, orgIndex) => (
                        <Card key={orgIndex} className="bg-black/30 border-white/5">
                          <Collapsible open={openOrganizations.has(`${locationIndex}-${orgIndex}`)} onOpenChange={() => toggleOrganization(locationIndex, orgIndex)}>
                            <CollapsibleTrigger asChild>
                              <CardHeader className="cursor-pointer hover:text-amber-300 text-white transition-colors py-3">
                                <CardTitle className="flex items-center justify-between text-base">
                                  <div className="flex items-center gap-2">
                                    {openOrganizations.has(`${locationIndex}-${orgIndex}`) ? <ChevronDown className="w-3 h-3" /> : <ChevronRight className="w-3 h-3" />}
                                    <span>{org.name || `Organization ${orgIndex + 1}`}</span>
                                  </div>
                                  <Button
                                    variant="ghost"
                                    size="sm"
                                    onClick={(e) => {
                                      e.stopPropagation()
                                      removeOrganization(locationIndex, orgIndex)
                                    }}
                                    disabled={isSaving}
                                  >
                                    <Trash2 className="w-3 h-3" />
                                  </Button>
                                </CardTitle>
                              </CardHeader>
                            </CollapsibleTrigger>

                            <CollapsibleContent>
                              <CardContent className="space-y-4 pt-0 text-white">
                                <div className="grid grid-cols-2 gap-4 text-white">
                                  <div>
                                    <Label className="block text-sm font-medium font-mono text-primary-200/90 mb-1">Organization Image</Label>
                                    <ImageUpload
                                      value={org.image}
                                      onChange={(url) => updateOrganization(locationIndex, orgIndex, "image", url)}
                                      onRemove={() => updateOrganization(locationIndex, orgIndex, "image", "")}
                                      folder={`images/settings/${settingId}/organizations`}
                                    />
                                  </div>

                                  <div>
                                    <Label className="block text-sm font-medium font-mono text-primary-200/90 mb-1">Name</Label>
                                    <Input
                                      value={org.name}
                                      onChange={(e) => updateOrganization(locationIndex, orgIndex, "name", e.target.value)}
                                      placeholder="Organization name..."
                                      disabled={isSaving}
                                    />
                                  </div>
                                </div>

                                <div className="text-white">
                                  <Label className="block text-sm font-medium font-mono text-primary-200/90 mb-1">Description</Label>
                                  <Textarea
                                    value={org.description}
                                    onChange={(e) => updateOrganization(locationIndex, orgIndex, "description", e.target.value)}
                                    placeholder="Describe this organization..."
                                    rows={3}
                                    disabled={isSaving}
                                  />
                                </div>
                              </CardContent>
                            </CollapsibleContent>
                          </Collapsible>
                        </Card>
                      ))}
                    </div>
                  </div>
                </CardContent>
              </CollapsibleContent>
            </Collapsible>
          </Card>
        ))}

        {locations.length === 0 && (
          <Card className="bg-black/20 border-white/10 border-dashed">
            <CardContent className="flex flex-col items-center justify-center py-12">
              <p className="text-gray-400 mb-4">No locations added yet.</p>
              <Button onClick={addLocation} disabled={isSaving}>
                <Plus className="w-4 h-4 mr-2" />
                Add Your First Location
              </Button>
            </CardContent>
          </Card>
        )}
      </div>
    </div>
  )
}


/*
  File: components/typography/heading.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/typography/heading.tsx
  Directory: components/typography
*/

--- File: components/typography/heading.tsx ---

import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const headingVariants = cva("text-balance font-extrabold", {
  variants: {
    variant: {
      h1: "text-4xl sm:text-5xl md:text-7xl scale-x-110 tracking-wide",
      h2: "text-3xl sm:text-5xl font-extrabold",
      h3: "text-2xl sm:text-4xl font-extrabold text-primary",
      h4: "text-xl sm:text-2xl font-bold",
      h5: "text-lg sm:text-xl font-bold",
      h6: "text-base sm:text-lg font-bold",
    },
  },
  defaultVariants: {
    variant: "h1",
  },
})

type HeadingVariant = "h1" | "h2" | "h3" | "h4" | "h5" | "h6"

interface HeadingProps extends Omit<React.HTMLAttributes<HTMLHeadingElement>, "className">, Omit<VariantProps<typeof headingVariants>, "as"> {
  variant: HeadingVariant
  as?: HeadingVariant
  className?: string
}

export function Heading({ className, variant, as, ...props }: HeadingProps) {
  const Tag = as || variant

  return (
    <Tag
      className={cn(
        headingVariants({
          variant,
          className,
        })
      )}
      {...props}
    />
  )
}


/*
  File: components/typography/markdown.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/typography/markdown.tsx
  Directory: components/typography
*/

--- File: components/typography/markdown.tsx ---

import ReactMarkdown from "react-markdown"

const Markdown = ReactMarkdown as unknown as React.FC<{ children: string }>

export { Markdown }


/*
  File: components/typography/styles.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/typography/styles.ts
  Directory: components/typography
*/

--- File: components/typography/styles.ts ---

export const textShadow = {
  textShadow: "0 0 2px #000, 0 0 2px #000, 0 0 2px #000, 0 0 2px #000, 0 0 2px #000, 0 0 2px #000",
}

export const textShadowSpread = {
  textShadow: "0 0 2px #000, 0 0 2px #000, 0 0 4px #000, 0 0 8px #000, 0 0 16px #000, 0 0 32px #000, 0 0 64px #000, 0 0 128px #000",
}

export const textShadowSpreadLight = {
  textShadow:
    "0 0 2px #000, 0 0 2px rgba(0,0,0,0.5), 0 0 4px rgba(0,0,0,0.5), 0 0 8px rgba(0,0,0,0.5), 0 0 16px rgba(0,0,0,0.5), 0 0 32px rgba(0,0,0,0.5), 0 0 64px rgba(0,0,0,0.5), 0 0 128px rgba(0,0,0,0.5)",
}


/*
  File: components/ui/accordion.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/accordion.tsx
  Directory: components/ui
*/

--- File: components/ui/accordion.tsx ---

"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDownIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Accordion({ ...props }: React.ComponentProps<typeof AccordionPrimitive.Root>) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />
}

function AccordionItem({ className, ...props }: React.ComponentProps<typeof AccordionPrimitive.Item>) {
  return <AccordionPrimitive.Item data-slot="accordion-item" className={cn("border-b last:border-b-0", className)} {...props} />
}

function AccordionTrigger({ className, children, ...props }: React.ComponentProps<typeof AccordionPrimitive.Trigger>) {
  return (
    <AccordionPrimitive.Header className="flex">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn(
          "focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 items-start justify-between gap-4 rounded-md py-4 text-left text-sm font-medium transition-all outline-none focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180 cursor-pointer",
          className
        )}
        {...props}
      >
        {children}
        <ChevronDownIcon className="text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0.5 transition-transform duration-200" />
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  )
}

function AccordionContent({ className, children, ...props }: React.ComponentProps<typeof AccordionPrimitive.Content>) {
  return (
    <AccordionPrimitive.Content data-slot="accordion-content" className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm" {...props}>
      <div className={cn("pt-0 pb-4", className)}>{children}</div>
    </AccordionPrimitive.Content>
  )
}

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }


/*
  File: components/ui/alert-dialog.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/alert-dialog.tsx
  Directory: components/ui
*/

--- File: components/ui/alert-dialog.tsx ---

"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"
import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<React.ElementRef<typeof AlertDialogPrimitive.Overlay>, React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>>(
  ({ className, ...props }, ref) => (
    <AlertDialogPrimitive.Overlay
      className={cn("fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0", className)}
      {...props}
      ref={ref}
    />
  )
)
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<React.ElementRef<typeof AlertDialogPrimitive.Content>, React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>>(
  ({ className, ...props }, ref) => (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        ref={ref}
        className={cn(
          "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border border-primary-500 ring-[6px] ring-black/70 bg-black p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
)
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => <div className={cn("flex flex-col space-y-2 text-center sm:text-left", className)} {...props} />
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)} {...props} />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<React.ElementRef<typeof AlertDialogPrimitive.Title>, React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title ref={ref} className={cn("text-lg font-display text-white", className)} {...props} />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<React.ElementRef<typeof AlertDialogPrimitive.Description>, React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>>(
  ({ className, ...props }, ref) => <AlertDialogPrimitive.Description ref={ref} className={cn("text-sm text-gray-300", className)} {...props} />
)
AlertDialogDescription.displayName = AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<React.ElementRef<typeof AlertDialogPrimitive.Action>, React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action ref={ref} className={cn(buttonVariants(), className)} {...props} />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<React.ElementRef<typeof AlertDialogPrimitive.Cancel>, React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel ref={ref} className={cn(buttonVariants({ variant: "ghost" }), "mt-2 hover:bg-neutral-800/50 hover:text-white sm:mt-0", className)} {...props} />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}


/*
  File: components/ui/alert.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/alert.tsx
  Directory: components/ui
*/

--- File: components/ui/alert.tsx ---

import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-black text-white",
        destructive: "bg-black/30 ring-4 ring-black border-red-700/50 text-red-500 [&>svg]:text-current *:data-[slot=alert-description]:text-red-500",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Alert({ className, variant, ...props }: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return <div data-slot="alert" role="alert" className={cn(alertVariants({ variant }), className)} {...props} />
}

function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="alert-title" className={cn("col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight", className)} {...props} />
}

function AlertDescription({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="alert-description" className={cn("text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed", className)} {...props} />
}

export { Alert, AlertTitle, AlertDescription }


/*
  File: components/ui/animate-in.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/animate-in.tsx
  Directory: components/ui
*/

--- File: components/ui/animate-in.tsx ---

import React, { useEffect, useState } from "react"
import type { JSX } from "react"
import { cn } from "@/lib/utils"

const AnimateIn = ({
  children,
  delay = 0,
  duration = 500,
  className = "",
  from,
  to,
  style,
  as = "div",
}: {
  from: string
  to: string
  children?: React.ReactNode
  delay?: number
  duration?: number
  className?: string
  style?: React.CSSProperties
  as?: keyof JSX.IntrinsicElements
}) => {
  const [animate, setAnimate] = useState(from)
  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false)

  useEffect(() => {
    const mediaQuery = window.matchMedia("(prefers-reduced-motion: reduce)")

    const mediaQueryChangeHandler = (e: MediaQueryListEvent) => {
      setPrefersReducedMotion(e.matches)
    }

    setPrefersReducedMotion(mediaQuery.matches)
    mediaQuery.addEventListener("change", mediaQueryChangeHandler)

    return () => {
      mediaQuery.removeEventListener("change", mediaQueryChangeHandler)
    }
  }, [])

  useEffect(() => {
    if (prefersReducedMotion) {
      // If the user prefers reduced motion, skip the animation
      setAnimate(to)
      return
    }

    const timer = setTimeout(() => {
      setAnimate(to)
    }, delay)

    return () => clearTimeout(timer)
  }, [delay, to, prefersReducedMotion])

  return React.createElement(
    as,
    {
      className: cn("transition-all ease-in-out", className, animate),
      style: { transitionDuration: prefersReducedMotion ? "0ms" : `${duration}ms`, ...style },
    },
    children
  )
}

export default AnimateIn


/*
  File: components/ui/avatar.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/avatar.tsx
  Directory: components/ui
*/

--- File: components/ui/avatar.tsx ---

"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const AvatarContext = React.createContext<{ hasError: boolean; setHasError: (error: boolean) => void }>({
  hasError: false,
  setHasError: () => {},
})

function Avatar({ className, ...props }: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  const [hasError, setHasError] = React.useState(false)

  return (
    <AvatarContext.Provider value={{ hasError, setHasError }}>
      <AvatarPrimitive.Root data-slot="avatar" className={cn("relative flex size-8 shrink-0 overflow-hidden rounded-full", className)} {...props} />
    </AvatarContext.Provider>
  )
}

function AvatarImage({ className, ...props }: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  const { setHasError } = React.useContext(AvatarContext)
  const [isLoaded, setIsLoaded] = React.useState(false)

  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full transition-opacity duration-300", isLoaded ? "opacity-100" : "opacity-0", className)}
      onLoad={() => setIsLoaded(true)}
      onError={() => {
        setHasError(true)
        setIsLoaded(false)
      }}
      {...props}
    />
  )
}

function AvatarFallback({ className, ...props }: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  const { hasError } = React.useContext(AvatarContext)

  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn("bg-muted flex size-full items-center justify-center rounded-full transition-opacity duration-200", !hasError && "hidden", className)}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }


/*
  File: components/ui/badge.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/badge.tsx
  Directory: components/ui
*/

--- File: components/ui/badge.tsx ---

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }


/*
  File: components/ui/button.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/button.tsx
  Directory: components/ui
*/

--- File: components/ui/button.tsx ---

import React, { forwardRef } from "react"
import { cn } from "@/lib/utils"
import { emboss } from "../graphics/styles"
import { textShadow } from "../typography/styles"
import { cva } from "class-variance-authority"
import { SparklesIcon } from "@heroicons/react/24/outline"

export interface ButtonProps {
  id?: string
  children: React.ReactNode
  onClick?: (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void
  type?: "button" | "submit" | "reset"
  className?: string
  size?: "default" | "lg" | "sm" | "icon"
  variant?: "epic" | "brick" | "emboss" | "outline" | "ghost" | "ai" | "sparkle" | "destructive"
  disabled?: boolean
  ariaLabel?: string
  asChild?: boolean
  style?: React.CSSProperties
  formAction?: (formData: FormData) => Promise<void>
  role?: string
}

const outline =
  "bg-transparent border-2 bg-blue-950/70 hover:bg-blue-950/80 border-blue-600/90 text-base px-3 py-1 bg-transparent bg-blue-950/70 hover:bg-blue-950/80 border-2 border-blue-600/90 text-base px-3 py-1 disabled:opacity-100 disabled:saturate-0 disabled:brightness-50"

export const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 disabled:border-transparent select-none",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline,
        secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
        sparkle: cn(outline, "scale-90 sm:scale-100 -left-1 sm:left-0"),
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export const baseButtonClass =
  "inline-flex gap-1 items-center justify-center transition-all ease-in-out duration-500 text-blue-50 hover:text-white hover:scale-105 active:scale-100 disabled:bg-gray-600 disabled:opacity-50 disabled:pointer-events-none px-3 rounded-md py-1 disabled:border-transparent select-none"
export const epicButtonClass = cn(
  baseButtonClass,
  "px-8 py-3 bg-blue-600 font-bold brightness-110 saturate-[1.2] scale-105 active:scale-100 hover:scale-110 border-[rgba(0,0,0,.66)] disabled:opacity-90 border-4 rounded-full font-display tracking-widest bg-[url('/images/app/backgrounds/buried.png')]"
)
export const aiButtonClass = cn(
  baseButtonClass,
  "bg-black/10 hover:bg-black/20 hover:scale-100 mix-blend-hard-light text-lg sm:text-2xl border-double border-8 px-6 rounded-full border-white/20 hover:border-white/30 font-mono"
)

export const epicButtonStyle = {
  ...textShadow,
  boxShadow: "-4px -8px 0px 0px #0006 inset, 4px 4px 0px 0px #FFF7 inset, -4px -8px 36px 0px rgba(0,0,0,.5) inset, -3px -3px 6px 1px rgba(255,255,255,0.5) inset",
}
export const brickButtonClass =
  "font-serif bg-blue-600 saturate-[1.2] brightness-110 rounded-2xl border-4 border-blue-900 text-white ml-[2px] px-2 py-[2px] rounded text-sm transition-all ease-in-out hover:scale-105 active:scale-95 bg-[url('/images/app/backgrounds/buried.png')]"

const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ id, ariaLabel, role, children, formAction, onClick, type = "button", className = "transition-all ease-in-out", size = "base", variant = "", disabled, asChild, style }, ref) => {
    let sizeClass = ""
    if (size === "large") {
      sizeClass = "text-3xl py-6"
    } else if (size === "small") {
      sizeClass = "text-lg py-2"
    } else if (size === "icon") {
      sizeClass = "h-9 w-9"
    }

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let buttonStyle: any

    let variantClass = ""
    if (variant === "epic") {
      variantClass = epicButtonClass
      buttonStyle = epicButtonStyle
    }
    if (variant === "brick") {
      variantClass = brickButtonClass
    }
    if (variant === "emboss") {
      variantClass = emboss.className
      buttonStyle = emboss.style
    }
    if (variant === "ai") {
      variantClass = aiButtonClass
      buttonStyle = { boxShadow: "0px 0px 10px 2px rgba(0,0,0,.5) inset" }
    }

    if (variant === "outline" || variant === "sparkle") {
      variantClass = "bg-transparent bg-blue-950/70 hover:bg-blue-950/80 border-2 border-blue-200/20 text-base px-3 py-1.5 select-none"
    }

    if (variant === "sparkle") {
      variantClass = cn(variantClass, "text-[11px] sm:text-xs")
    }

    if (variant === "ghost") {
      variantClass = "bg-transparent border-2 border-transparent px-2 py-1"
    }

    if (variant === "destructive") {
      variantClass = "bg-red-600 text-white shadow-sm hover:bg-red-700"
    }

    if (asChild && React.isValidElement(children)) {
      // For asChild mode, only pass props that are valid for the child element
      const childProps: Record<string, unknown> = {
        onClick,
        className: cn(baseButtonClass, sizeClass, variantClass, className),
        style: style || buttonStyle,
      }

      if (ariaLabel) {
        childProps["aria-label"] = ariaLabel
      }

      return React.cloneElement(children, childProps)
    }

    return (
      <button
        ref={ref}
        id={id}
        role={role}
        formAction={formAction}
        aria-label={ariaLabel}
        disabled={disabled}
        type={type}
        onClick={onClick}
        className={cn(baseButtonClass, variantClass, sizeClass, className)}
        style={style || buttonStyle}
      >
        {variant === "sparkle" && <SparklesIcon className="w-4 h-4 text-amber-200" />}
        {children}
      </button>
    )
  }
)

Button.displayName = "Button"

export { Button }


/*
  File: components/ui/calendar.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/calendar.tsx
  Directory: components/ui
*/

--- File: components/ui/calendar.tsx ---

"use client"

import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({ className, classNames, showOutsideDays = true, ...props }: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(buttonVariants({ variant: "outline" }), "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell: "text-muted-foreground rounded-md w-8 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: cn(
          "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([aria-selected])]:bg-accent [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected].day-range-end)]:rounded-r-md",
          props.mode === "range"
            ? "[&:has(>.day-range-end)]:rounded-r-md [&:has(>.day-range-start)]:rounded-l-md first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md"
            : "[&:has([aria-selected])]:rounded-md"
        ),
        day: cn(buttonVariants({ variant: "ghost" }), "h-8 w-8 p-0 font-normal aria-selected:opacity-100"),
        day_range_start: "day-range-start",
        day_range_end: "day-range-end",
        day_selected: "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside: "day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle: "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => <ChevronLeft className={cn("h-4 w-4", className)} {...props} />,
        IconRight: ({ className, ...props }) => <ChevronRight className={cn("h-4 w-4", className)} {...props} />,
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }


/*
  File: components/ui/card.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/card.tsx
  Directory: components/ui
*/

--- File: components/ui/card.tsx ---

import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="card" className={cn("bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-xs", className)} {...props} />
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="card-header" className={cn("flex flex-col gap-1.5 px-6", className)} {...props} />
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="card-title" className={cn("leading-none font-semibold", className)} {...props} />
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="card-description" className={cn("text-muted-foreground text-sm", className)} {...props} />
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="card-content" className={cn("px-6 grow", className)} {...props} />
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="card-footer" className={cn("flex items-center px-6", className)} {...props} />
}

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }


/*
  File: components/ui/checkbox.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/checkbox.tsx
  Directory: components/ui
*/

--- File: components/ui/checkbox.tsx ---

"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-2xs transition-shadow outline-hidden focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }


/*
  File: components/ui/collapsible.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/collapsible.tsx
  Directory: components/ui
*/

--- File: components/ui/collapsible.tsx ---

"use client"

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

function Collapsible({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.Root>) {
  return <CollapsiblePrimitive.Root data-slot="collapsible" {...props} />
}

function CollapsibleTrigger({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleTrigger>) {
  return (
    <CollapsiblePrimitive.CollapsibleTrigger
      data-slot="collapsible-trigger"
      {...props}
    />
  )
}

function CollapsibleContent({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleContent>) {
  return (
    <CollapsiblePrimitive.CollapsibleContent
      data-slot="collapsible-content"
      {...props}
    />
  )
}

export { Collapsible, CollapsibleTrigger, CollapsibleContent }


/*
  File: components/ui/container.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/container.tsx
  Directory: components/ui
*/

--- File: components/ui/container.tsx ---

import { cn } from "@/lib/utils"

export function Container({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
  return <div className={cn("mx-auto w-full max-w-7xl px-6 lg:px-8", className)} {...props} />
}


/*
  File: components/ui/copy-oneliner.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/copy-oneliner.tsx
  Directory: components/ui
*/

--- File: components/ui/copy-oneliner.tsx ---

"use client"
import { Copy, Terminal } from "lucide-react"
import { cn } from "@/lib/utils"
import { useState } from "react"
import { Check } from "lucide-react"

interface CopyOnelinerProps {
  children: string
  className?: string
  iconClassName?: string
}

export function CopyOneliner({ children, className, iconClassName }: CopyOnelinerProps) {
  const [copied, setCopied] = useState(false)

  const copyToClipboard = async () => {
    try {
      await navigator.clipboard.writeText(children)
      setCopied(true)
      setTimeout(() => setCopied(false), 2000)
    } catch (err) {
      console.error("Failed to copy text: ", err)
    }
  }

  return (
    <div onClick={copyToClipboard} className={cn("relative text-sm py-3 px-3 flex items-center gap-2 rounded-md border text-left mx-auto -mt-4 font-mono", "cursor-pointer", className)}>
      <Terminal className={cn("w-4 h-4 opacity-50", iconClassName)} />
      <div className="flex-1">{children}</div>
      {copied ? <Check className="w-5 h-5 mr-1 scale-125 text-green-600" /> : <Copy className="w-5 h-5 mr-1 opacity-50" />}
    </div>
  )
}


/*
  File: components/ui/copy-to-clipboard.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/copy-to-clipboard.tsx
  Directory: components/ui
*/

--- File: components/ui/copy-to-clipboard.tsx ---

"use client"

import { useState } from "react"
import { cn } from "@/lib/utils"
import { Check, Copy } from "lucide-react"

interface CopyToClipboardProps {
  children: string
  className?: string
  iconClassName?: string
  timeout?: number
  position?: "top-right" | "top-left" | "bottom-right" | "bottom-left"
  hideContent?: boolean
}

const positionClasses = {
  "top-right": "right-5 top-5",
  "top-left": "left-5 top-5",
  "bottom-right": "right-5 bottom-5",
  "bottom-left": "left-5 bottom-5",
}

export function CopyToClipboard({ children, className, iconClassName, timeout = 1000, position = "top-right", hideContent = false }: CopyToClipboardProps) {
  const [copied, setCopiedState] = useState(false)

  const handleCopy = () => {
    if (copied) return
    navigator.clipboard.writeText(children)
    setCopiedState(true)
    setTimeout(() => {
      setCopiedState(false)
    }, timeout)
  }

  return (
    <>
      <button
        className={cn("absolute p-1.5 border dark:border-neutral-800 rounded-md z-[2] backdrop-blur-2xl cursor-pointer", positionClasses[position], copied && "text-green-500", className)}
        onClick={handleCopy}
      >
        {copied ? <Check className={cn("w-4.5 h-4.5 scale-110", iconClassName)} /> : <Copy className={cn("w-4.5 h-4.5", iconClassName)} />}
      </button>
      {!hideContent && children}
    </>
  )
}


/*
  File: components/ui/date-picker.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/date-picker.tsx
  Directory: components/ui
*/

--- File: components/ui/date-picker.tsx ---

"use client"

import * as React from "react"
import { format } from "date-fns"
import { Calendar as CalendarIcon } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Calendar } from "@/components/ui/calendar"
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover"

interface DatePickerProps {
  date: Date | undefined
  setDate: (date: Date | undefined) => void
  label?: string
  className?: string
}

export function DatePicker({ date, setDate, label = "Pick a date", className }: DatePickerProps) {
  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button variant={"outline"} className={cn("w-full justify-start text-left font-normal", !date && "text-muted-foreground", className)}>
          <CalendarIcon className="mr-2 h-4 w-4" />
          {date ? format(date, "PPP") : <span>{label}</span>}
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-auto p-0" align="start">
        <Calendar mode="single" selected={date} onSelect={setDate} initialFocus />
      </PopoverContent>
    </Popover>
  )
}

export function DateRangePicker({
  startDate,
  endDate,
  setStartDate,
  setEndDate,
  startLabel = "Start date",
  endLabel = "End date",
  className,
}: {
  startDate: Date | undefined
  endDate: Date | undefined
  setStartDate: (date: Date | undefined) => void
  setEndDate: (date: Date | undefined) => void
  startLabel?: string
  endLabel?: string
  className?: string
}) {
  return (
    <div className={cn("flex flex-col space-y-2 sm:flex-row sm:space-x-2 sm:space-y-0", className)}>
      <DatePicker date={startDate} setDate={setStartDate} label={startLabel} className="flex-1" />
      <DatePicker date={endDate} setDate={setEndDate} label={endLabel} className="flex-1" />
    </div>
  )
}


/*
  File: components/ui/dialog.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/dialog.tsx
  Directory: components/ui
*/

--- File: components/ui/dialog.tsx ---

"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/80",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}


/*
  File: components/ui/dice-roll.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/dice-roll.tsx
  Directory: components/ui
*/

--- File: components/ui/dice-roll.tsx ---

"use client"
import React, { useState, useRef } from "react"
import { Button } from "./button"
import Image from "next/image"
import { cn, rollD20 } from "@/lib/utils"
import { textShadow } from "../typography/styles"
import DiceRollResult from "@/components/adventure/dice-roll-result"

const ROLL_ANIMATION_DURATION = 1200 // ms
const ROLL_ANIMATION_INTERVAL = 60 // ms

export default function DiceRoll({
  className,
  icon = "/images/app/dice/d20.svg",
  iconSize = 42,
  id,
  onRoll,
}: {
  className?: string
  icon?: string
  iconSize?: number
  id?: string
  onRoll?: (result: number) => void
}) {
  const [rolling, setRolling] = useState(false)
  const [result, setResult] = useState<number | null>(null)
  const [display, setDisplay] = useState<number | null>(null)
  const intervalRef = useRef<NodeJS.Timeout | null>(null)

  const handleRoll = () => {
    setRolling(true)
    setResult(null)
    let elapsed = 0
    intervalRef.current = setInterval(() => {
      const animRoll = rollD20()
      setDisplay(animRoll)
      elapsed += ROLL_ANIMATION_INTERVAL
      if (elapsed >= ROLL_ANIMATION_DURATION) {
        if (intervalRef.current) clearInterval(intervalRef.current)
        const final = rollD20()
        setDisplay(final)
        setResult(final)
        setRolling(false)
        if (onRoll) {
          onRoll(final)
        }
      }
    }, ROLL_ANIMATION_INTERVAL)
  }

  // Clean up interval on unmount
  React.useEffect(() => {
    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current)
    }
  }, [])

  if (result !== null) {
    return <DiceRollResult result={result} />
  }

  return (
    <Button
      ariaLabel="Roll D20"
      className={cn(
        "group text-2xl brightness-125 contrast-150 font-display flex gap-[7px] justify-center items-center pt-[2px] pb-0 px-3 bg-blue-600 rounded-full ring-4 ring-blue-800 border border-blue-400/50 transition-all ease-in-out duration-500 bg-[url('/images/app/backgrounds/buried.png')]",
        className,
        rolling && "pointer-events-none"
      )}
      id={id}
      onClick={handleRoll}
    >
      <span style={textShadow} className="pt-[2px]">
        Roll
      </span>
      <Image
        style={{ transform: rolling ? "rotate(720deg)" : undefined, transition: "transform 1.2s cubic-bezier(.22,1,.36,1)" }}
        className="inline-block border border-[rgba(255,255,255,.33)] ring-4 ring-blue-600 group-disabled:ring-gray-600 shadow-inner shadow-black rounded-full overflow-hidden p-[2px] transition-all ease-in-out delay-100 duration-[2s]"
        src={icon}
        width={iconSize}
        height={iconSize}
        alt=""
      />
      <span style={textShadow} className="pt-[2px] w-16 text-center">
        {rolling ? (display ?? "") : "D20"}
      </span>
    </Button>
  )
}


/*
  File: components/ui/dropdown-menu.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/dropdown-menu.tsx
  Directory: components/ui
*/

--- File: components/ui/dropdown-menu.tsx ---

"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive-foreground data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/40 data-[variant=destructive]:focus:text-destructive-foreground [svg]:*:data-[variant=destructive]:text-destructive-foreground! [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-disabled:pointer-events-none data-disabled:opacity-50 data-inset:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-disabled:pointer-events-none data-disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-disabled:pointer-events-none data-disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-inset:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-inset:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}


/*
  File: components/ui/hover-card.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/hover-card.tsx
  Directory: components/ui
*/

--- File: components/ui/hover-card.tsx ---

"use client"

import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/lib/utils"

function HoverCard({ ...props }: React.ComponentProps<typeof HoverCardPrimitive.Root>) {
  return <HoverCardPrimitive.Root data-slot="hover-card" {...props} />
}

function HoverCardTrigger({ ...props }: React.ComponentProps<typeof HoverCardPrimitive.Trigger>) {
  return <HoverCardPrimitive.Trigger data-slot="hover-card-trigger" {...props} />
}

function HoverCardContent({ className, align = "center", sideOffset = 4, ...props }: React.ComponentProps<typeof HoverCardPrimitive.Content>) {
  return (
    <HoverCardPrimitive.Portal data-slot="hover-card-portal">
      <HoverCardPrimitive.Content
        data-slot="hover-card-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-64 origin-(--radix-hover-card-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </HoverCardPrimitive.Portal>
  )
}

export { HoverCard, HoverCardTrigger, HoverCardContent }


/*
  File: components/ui/image-header.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/image-header.tsx
  Directory: components/ui
*/

--- File: components/ui/image-header.tsx ---

"use client"

import React, { useState } from "react"
import Image from "next/image"
import Parchment from "@/components/graphics/background/Parchment"
import { textShadow, textShadowSpread } from "../typography/styles"
import { cn } from "@/lib/utils"

interface ImageHeaderProps {
  imageUrl: string
  children?: React.ReactNode
  title?: string
  subtitle?: string
  overlayContent?: React.ReactNode
  imageAlt?: string
  variant?: "default" | "semicompact" | "compact"
  topBorder?: boolean
}

export default function ImageHeader({ imageUrl, children, title, subtitle, imageAlt, variant = "default", topBorder }: ImageHeaderProps) {
  const [imageLoaded, setImageLoaded] = useState(false)

  return (
    <>
      <div className={cn("absolute left-0 right-0 w-full aspect-video min-h-[480px]", variant === "semicompact" && "aspect-[2.25]", variant === "compact" && "aspect-[3]")}>
        {topBorder && (
          <>
            <div className="absolute top-0 left-0 right-0 h-2 bg-black/30 z-10" />
            <div id="top-border" className="absolute top-2 left-0 right-0 z-10 w-full h-[1px] bg-blend-lighten -mb-px overflow-hidden opacity-70 bg-[url('/images/app/art/texture-line.png')]" />
          </>
        )}
        <Image
          className={cn("object-cover transition-opacity duration-1000 ease-in-out", imageLoaded ? "opacity-100" : "opacity-0")}
          fill
          src={imageUrl}
          alt={imageAlt || title || ""}
          onLoad={() => setImageLoaded(true)}
        />
        {title && (
          <div className="absolute bottom-44 sm:bottom-54 px-4 w-full flex flex-col items-center">
            {children}
            <h2 className="text-2xl sm:text-4xl md:text-5xl font-display text-center mt-12" style={textShadowSpread}>
              {title}
            </h2>
          </div>
        )}
        <div className="absolute bottom-32 sm:bottom-36 left-0 right-0 flex justify-center">
          {subtitle && (
            <h3 className="relative border border-white/20 rounded-sm bg-gradient-to-t from-amber-950 via-amber-950 to-amber-800 font-display sm:text-lg md:text-xl font-bold px-6 sm:px-8 py-1 sm:py-2 ring-4 sm:ring-8 ring-black z-[11] contrast-[1.2] saturate-[.4]">
              <Parchment />
              <span style={textShadow}>{subtitle}</span>
            </h3>
          )}
        </div>
        <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black to-transparent h-1/3 rounded-b-lg" />
        <div className="absolute bottom-6 sm:bottom-12 left-0 right-0 w-full h-32 bg-gradient-to-b from-black/50 to-transparent"></div>
        <div className="absolute bottom-36 sm:bottom-42 left-0 right-0 w-full h-[1px] bg-blend-lighten -mb-px overflow-hidden opacity-50 bg-[url('/images/app/art/texture-line.png')]" />
      </div>
      <div className={cn("w-full aspect-video -mb-16 -mb-12 min-h-[480px]", variant === "semicompact" && "aspect-[2.25]", variant === "compact" && "aspect-[3]")} />
    </>
  )
}


/*
  File: components/ui/image-upload.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/image-upload.tsx
  Directory: components/ui
*/

--- File: components/ui/image-upload.tsx ---

"use client"

import { useCallback, useState, useEffect } from "react"
import { Button } from "@/components/ui/button"
import { ImagePlus, X, Loader } from "lucide-react"
import Image from "next/image"
import { toast } from "sonner"
import { useFileUpload } from "@/lib/upload-utils"
import { cn } from "@/lib/utils"
import { IMAGE_HOST } from "@/lib/config"

interface ImageUploadProps {
  value: string
  onChange: (url: string) => void
  onRemove: () => void
  folder?: string
  id?: string
  className?: string
}

// Helper function to strip the image host domain from a URL to get the relative path
function stripImageHost(url: string): string {
  if (!url) return url

  // Remove the IMAGE_HOST domain if present
  if (url.startsWith(IMAGE_HOST)) {
    return url.replace(IMAGE_HOST, "").replace(/^\/+/, "") // Remove leading slashes
  }

  // Also handle the case where the URL might be from the CloudFront domain directly
  // Extract domain from IMAGE_HOST to handle both with and without protocols
  const imageHostDomain = IMAGE_HOST.replace(/^https?:\/\//, "")
  if (url.startsWith(`https://${imageHostDomain}/`)) {
    return url.replace(`https://${imageHostDomain}/`, "")
  }
  if (url.startsWith(`http://${imageHostDomain}/`)) {
    return url.replace(`http://${imageHostDomain}/`, "")
  }

  // If it's already a relative path, return as-is
  if (!url.startsWith("http://") && !url.startsWith("https://")) {
    return url
  }

  return url
}

// Helper function to construct the full URL for display
function getDisplayUrl(value: string): string {
  if (!value) return value

  // If it's already a full URL, use it as-is
  if (value.startsWith("http://") || value.startsWith("https://")) {
    return value
  }

  // If it's a relative path, prepend the IMAGE_HOST
  return `${IMAGE_HOST}/${value.replace(/^\/+/, "")}`
}

export function ImageUpload({ id, value, onChange, onRemove, folder = "uploads", className }: ImageUploadProps) {
  const [isUploading, setIsUploading] = useState(false)

  useEffect(() => {
    console.log("ImageUpload: Received value prop:", value)
  }, [value])

  const { upload } = useFileUpload({
    folder,
    allowedTypes: ["image/jpeg", "image/png", "image/webp", "image/gif"],
  })

  const handleUpload = useCallback(
    async (e: React.ChangeEvent<HTMLInputElement>) => {
      try {
        const file = e.target.files?.[0]
        if (!file) return

        setIsUploading(true)
        console.log(`ImageUpload: Uploading file: ${file.name} to folder: ${folder}`)
        const imageUrl = await upload(file)
        console.log("ImageUpload: Upload successful, imageUrl received:", imageUrl)

        // Strip the image host domain before storing the path
        const relativePath = stripImageHost(imageUrl)
        console.log("ImageUpload: Storing relative path:", relativePath)
        onChange(relativePath)

        toast.success("Image uploaded successfully!")
      } catch (error) {
        console.error("ImageUpload: Error during upload process:", error)
        toast.error(error instanceof Error ? error.message : "Failed to upload image")
      } finally {
        setIsUploading(false)
      }
    },
    [onChange, upload, folder]
  )

  // Get the display URL for showing the image
  const displayUrl = getDisplayUrl(value)
  const isUsableUrl = displayUrl && (displayUrl.startsWith("http://") || displayUrl.startsWith("https://") || displayUrl.startsWith("/"))

  return (
    <div className="flex flex-col items-center gap-4">
      <div className={cn("relative aspect-video w-full overflow-hidden rounded-lg border border-white/20", className)}>
        {isUsableUrl ? (
          <>
            <Image src={displayUrl} alt="" fill className="object-cover" />
            <Button variant="ghost" size="icon" className="absolute h-6 w-6 p-0 right-2 top-2 text-red-500 hover:text-red-500 bg-black/50 hover:bg-black/60" onClick={onRemove}>
              <X className="h-4 w-4" />
            </Button>
          </>
        ) : (
          <>
            {value && !isUsableUrl && <p className="text-xs text-red-500 p-2 text-center">Image path appears invalid for display: {value}. Please re-upload or ensure the path is an absolute URL.</p>}
            <label className={`flex h-full w-full cursor-pointer items-center justify-center bg-gradient-to-tl from-white/10 to-transparent ${value && !isUsableUrl ? "pt-2" : ""}`}>
              <div className="flex flex-col items-center gap-2 text-primary">
                {isUploading ? <Loader className="h-8 w-8 animate-spin" /> : <ImagePlus className="h-8 w-8" />}
                <span className="text-sm font-mono">{isUploading ? "Uploading..." : "Upload Image"}</span>
              </div>
              <input id={id} type="file" accept="image/*" className="hidden" onChange={handleUpload} disabled={isUploading} />
            </label>
          </>
        )}
      </div>
    </div>
  )
}


/*
  File: components/ui/input.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/input.tsx
  Directory: components/ui
*/

--- File: components/ui/input.tsx ---

import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "border-white/20 file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-2xs transition-[color,box-shadow] outline-hidden file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }


/*
  File: components/ui/label.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/label.tsx
  Directory: components/ui
*/

--- File: components/ui/label.tsx ---

"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }


/*
  File: components/ui/loading-animation.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/loading-animation.tsx
  Directory: components/ui
*/

--- File: components/ui/loading-animation.tsx ---

"use client"
import React, { useEffect, useRef } from "react"
import Image from "next/image"
import AnimateIn from "./animate-in"
import { cn } from "@/lib/utils"

const spin = `@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  80% {
    transform: rotate(360deg);
  }
  99.99% {
    transform: rotate(360deg);
  }
}`

const LoadingAnimation = ({ className, children, containerClassName }: { className?: string; containerClassName?: string; children?: React.ReactNode }) => {
  const containerRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    containerRef.current?.scrollIntoView({ behavior: "smooth", block: "center" })
  }, [])

  return (
    <div ref={containerRef} className={cn("flex flex-col items-center justify-center gap-2", containerClassName)}>
      <AnimateIn from="opacity-0 scale-0" to="opacity-50 scale-50" duration={1000} className={cn("w-full flex justify-center", className)}>
        <style>{spin}</style>
        <Image
          className="inline-block p-4 border-2 bg-black/90 border-indigo-400 rounded-full overflow-hidden transition-all ease-in-out animate-spin"
          src="/images/d20-white.svg"
          width={96}
          height={96}
          alt="Loading"
          style={{ animation: "spin 2s infinite ease-in-out" }}
        />
      </AnimateIn>
      {children && (
        <AnimateIn className="font-mono" style={{ textShadow: "0 2px 4px #000, 0 2px 16px #000" }} from="opacity-0" to="opacity-80" delay={1000}>
          {children}
        </AnimateIn>
      )}
    </div>
  )
}

export default LoadingAnimation


/*
  File: components/ui/pagination.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/pagination.tsx
  Directory: components/ui
*/

--- File: components/ui/pagination.tsx ---

import * as React from "react"
import { ChevronLeftIcon, ChevronRightIcon, MoreHorizontalIcon } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button, buttonVariants } from "@/components/ui/button"

function Pagination({ className, ...props }: React.ComponentProps<"nav">) {
  return <nav role="navigation" aria-label="pagination" data-slot="pagination" className={cn("mx-auto flex w-full justify-center", className)} {...props} />
}

function PaginationContent({ className, ...props }: React.ComponentProps<"ul">) {
  return <ul data-slot="pagination-content" className={cn("flex flex-row items-center gap-1 bg-gradient-to-tl from-black/50 to-black/30 rounded-lg px-1", className)} {...props} />
}

function PaginationItem({ ...props }: React.ComponentProps<"li">) {
  return <li className="flex items-center justify-center" data-slot="pagination-item" {...props} />
}

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<React.ComponentProps<typeof Button>, "size"> &
  React.ComponentProps<"a">

function PaginationLink({ className, isActive, size = "icon", ...props }: PaginationLinkProps) {
  return (
    <a
      aria-current={isActive ? "page" : undefined}
      data-slot="pagination-link"
      data-active={isActive}
      className={cn(
        buttonVariants({
          variant: "ghost",
          size,
        }),
        "px-2 h-7 w-auto hover:bg-black/70 transition-all duration-700 ease-in-out font-mono font-bold text-white hover:text-white",
        isActive && "border border-white/30",
        className
      )}
      {...props}
    />
  )
}

function PaginationPrevious({ className, ...props }: React.ComponentProps<typeof PaginationLink>) {
  return (
    <PaginationLink aria-label="Go to previous page" size="default" className={cn("w-8", className)} {...props}>
      <ChevronLeftIcon className="size-6" />
    </PaginationLink>
  )
}

function PaginationNext({ className, ...props }: React.ComponentProps<typeof PaginationLink>) {
  return (
    <PaginationLink aria-label="Go to next page" size="default" className={cn("w-8", className)} {...props}>
      <ChevronRightIcon className="size-6" />
    </PaginationLink>
  )
}

function PaginationEllipsis({ className, ...props }: React.ComponentProps<"span">) {
  return (
    <span aria-hidden data-slot="pagination-ellipsis" className={cn("flex size-9 items-center justify-center", className)} {...props}>
      <MoreHorizontalIcon className="size-4" />
      <span className="sr-only">More pages</span>
    </span>
  )
}

export { Pagination, PaginationContent, PaginationLink, PaginationItem, PaginationPrevious, PaginationNext, PaginationEllipsis }


/*
  File: components/ui/popover.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/popover.tsx
  Directory: components/ui
*/

--- File: components/ui/popover.tsx ---

"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

function Popover({ ...props }: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />
}

function PopoverTrigger({ ...props }: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />
}

function PopoverContent({ className, align = "center", sideOffset = 4, ...props }: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  )
}

function PopoverAnchor({ ...props }: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }


/*
  File: components/ui/progress.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/progress.tsx
  Directory: components/ui
*/

--- File: components/ui/progress.tsx ---

"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

function Progress({
  className,
  value,
  ...props
}: React.ComponentProps<typeof ProgressPrimitive.Root>) {
  return (
    <ProgressPrimitive.Root
      data-slot="progress"
      className={cn(
        "bg-primary/20 relative h-2 w-full overflow-hidden rounded-full",
        className
      )}
      {...props}
    >
      <ProgressPrimitive.Indicator
        data-slot="progress-indicator"
        className="bg-primary h-full w-full flex-1 transition-all"
        style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
      />
    </ProgressPrimitive.Root>
  )
}

export { Progress }


/*
  File: components/ui/radio-group.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/radio-group.tsx
  Directory: components/ui
*/

--- File: components/ui/radio-group.tsx ---

"use client"

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function RadioGroup({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Root>) {
  return (
    <RadioGroupPrimitive.Root
      data-slot="radio-group"
      className={cn("grid gap-3", className)}
      {...props}
    />
  )
}

function RadioGroupItem({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Item>) {
  return (
    <RadioGroupPrimitive.Item
      data-slot="radio-group-item"
      className={cn(
        "border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive aspect-square size-4 shrink-0 rounded-full border shadow-2xs transition-[color,box-shadow] outline-hidden focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator
        data-slot="radio-group-indicator"
        className="relative flex items-center justify-center"
      >
        <CircleIcon className="fill-primary absolute top-1/2 left-1/2 size-2 -translate-x-1/2 -translate-y-1/2" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
}

export { RadioGroup, RadioGroupItem }


/*
  File: components/ui/roll-button.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/roll-button.tsx
  Directory: components/ui
*/

--- File: components/ui/roll-button.tsx ---

"use client"
import React, { useState } from "react"
import { Button } from "./button"
import Image from "next/image"
import { cn } from "@/lib/utils"

const RollButton = ({
  className,
  onClick,
  isReroll,
  text1,
  text2,
  disabled,
  icon = "/images/app/dice/d20.svg",
  iconSize = 42,
  id,
}: {
  className?: string
  onClick: () => void
  isReroll?: boolean
  text1?: string
  text2?: string
  disabled?: boolean
  icon?: string
  iconSize?: number
  id?: string
}) => {
  const [count, setCount] = useState(0)

  const clickHandler = () => {
    setCount(count + 1)
    onClick()
  }

  return (
    <Button
      ariaLabel="Roll"
      className={cn(
        "group text-2xl brightness-125 contrast-150 font-display flex gap-[7px] justify-center items-center pt-[2px] pb-0 px-3 bg-blue-600 rounded-full ring-4 ring-blue-800 disabled:ring-gray-800 border border-blue-400/50 disabled:border-gray-400/50 transition-all ease-in-out duration-500 bg-[url('/images/app/backgrounds/buried.png')]",
        className
      )}
      id={id}
      onClick={clickHandler}
      disabled={disabled}
    >
      <span className="pt-[2px]">{text1 ? text1 : isReroll ? "re" : "Roll"}</span>
      <Image
        style={{ transform: `rotate(${count * 360}deg)` }}
        className="inline-block border border-[rgba(255,255,255,.33)] ring-4 ring-blue-600 group-disabled:ring-gray-600 shadow-inner shadow-black rounded-full overflow-hidden p-[2px] transition-all ease-in-out delay-100 duration-[2s]"
        src={icon}
        width={iconSize}
        height={iconSize}
        alt=""
      />
      <span className="pt-[2px]">{text2 ? text2 : isReroll ? "roll" : "D20"}</span>
    </Button>
  )
}

export default RollButton


/*
  File: components/ui/scroll-area.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/scroll-area.tsx
  Directory: components/ui
*/

--- File: components/ui/scroll-area.tsx ---

"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }


/*
  File: components/ui/select.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/select.tsx
  Directory: components/ui
*/

--- File: components/ui/select.tsx ---

"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger>) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive flex h-9 w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("px-2 py-1.5 text-sm font-medium", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}


/*
  File: components/ui/separator.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/separator.tsx
  Directory: components/ui
*/

--- File: components/ui/separator.tsx ---

"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }


/*
  File: components/ui/sheet.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/sheet.tsx
  Directory: components/ui
*/

--- File: components/ui/sheet.tsx ---

"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/80",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}


/*
  File: components/ui/sonner.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/sonner.tsx
  Directory: components/ui
*/

--- File: components/ui/sonner.tsx ---

"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground font-medium",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground font-medium",
        },
      }}
      {...props}
    />
  )
}

export { Toaster }


/*
  File: components/ui/switch.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/switch.tsx
  Directory: components/ui
*/

--- File: components/ui/switch.tsx ---

"use client"

import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }


/*
  File: components/ui/table.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/table.tsx
  Directory: components/ui
*/

--- File: components/ui/table.tsx ---

"use client"

import * as React from "react"

import { cn } from "@/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-muted-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}


/*
  File: components/ui/tabs.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/tabs.tsx
  Directory: components/ui
*/

--- File: components/ui/tabs.tsx ---

"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return <TabsPrimitive.Root data-slot="tabs" className={cn("flex flex-col gap-2", className)} {...props} />
}

function TabsList({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.List>) {
  return <TabsPrimitive.List data-slot="tabs-list" className={cn("bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-1", className)} {...props} />
}

function TabsTrigger({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring inline-flex flex-1 items-center justify-center gap-1.5 rounded-md px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-xs [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 cursor-pointer",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return <TabsPrimitive.Content data-slot="tabs-content" className={cn("flex-1 outline-hidden", className)} {...props} />
}

export { Tabs, TabsList, TabsTrigger, TabsContent }


/*
  File: components/ui/textarea.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/textarea.tsx
  Directory: components/ui
*/

--- File: components/ui/textarea.tsx ---

import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-white/20 placeholder:text-white/70 placeholder:italic focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }


/*
  File: components/ui/utils.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/ui/utils.ts
  Directory: components/ui
*/

--- File: components/ui/utils.ts ---

export function scrollToTop() {
  window.scrollTo({ top: 0, behavior: "smooth" })
}

export function scrollToBottom() {
  window.scrollTo({ top: document.body.scrollHeight, behavior: "smooth" })
}

/*
  File: components/views/adventure-home-content.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/views/adventure-home-content.tsx
  Directory: components/views
*/

--- File: components/views/adventure-home-content.tsx ---

"use client"

import React, { useEffect, useState } from "react"
import ImageHeader from "@/components/ui/image-header"
import { Adventure } from "@/types/adventure"
import Turn from "@/components/adventure/turn"
import { useTurn } from "@/lib/context/TurnContext"
import { useParams } from "next/navigation"
import { ensureNpcProcessed } from "@/app/_actions/ensure-npc-processed"
import { getEncounterImage } from "@/app/_actions/get-encounter-image"
import type { Id } from "@/convex/_generated/dataModel"
import wait from "waait"
import { scrollToTop } from "../ui/utils"
import AdventureLobby from "@/components/adventure/adventure-lobby"
import type { AdventurePlan } from "@/types/adventure-plan"
import { getImageUrl } from "@/lib/utils"

export const dynamic = "force-dynamic"

function AdventureHomeContent({ initialImage, adventure, adventurePlan }: { initialImage: string; initialSubtitle: string; adventure: Adventure; adventurePlan?: AdventurePlan }) {
  const { adventurePlanId, settingId } = useParams()
  const [image, setImage] = useState(initialImage)
  const [initialCheckDone, setInitialCheckDone] = useState(false)
  const [lastEncounterId, setLastEncounterId] = useState<string | null>(null)

  console.log("[AdventureHomeContent] adventure", JSON.stringify(adventure, null, 2))

  const turn = useTurn()

  useEffect(() => {
    // Only update image if the encounter actually changed
    if (turn && turn.encounterId && turn.encounterId !== lastEncounterId) {
      getEncounterImage(adventurePlanId as string, turn.encounterId)
        .then((encounterImage) => {
          if (encounterImage) {
            setImage(encounterImage)
          } else {
            const fallbackImage = `images/settings/${settingId}/${adventurePlanId}/${turn.encounterId}.png`
            setImage(fallbackImage)
          }
          setLastEncounterId(turn.encounterId)

          wait(500).then(() => {
            scrollToTop()
          })
        })
        .catch((error) => {
          console.error("[AdventureHomeContent] Error getting encounter image:", error)
          // Fallback to simple path pattern
          const fallbackImage = `images/settings/${settingId}/${adventurePlanId}/${turn.encounterId}.png`
          console.log("[AdventureHomeContent] Using fallback image after error:", fallbackImage)
          setImage(fallbackImage)
          setLastEncounterId(turn.encounterId)

          wait(500).then(() => {
            scrollToTop()
          })
        })
    }
  }, [turn?.encounterId, settingId, adventurePlanId, lastEncounterId])

  // Set initial lastEncounterId when component first loads
  useEffect(() => {
    if (turn?.encounterId && !lastEncounterId) {
      setLastEncounterId(turn.encounterId)
    }
  }, [turn?.encounterId, lastEncounterId])

  useEffect(() => {
    if (turn && turn.id && !initialCheckDone) {
      setInitialCheckDone(true)

      const characters = turn.characters || []
      const sortedCharacters = [...characters].sort((a, b) => (b.initiative ?? 0) - (a.initiative ?? 0))
      const currentActor = sortedCharacters.find((c) => !c.isComplete)

      if (currentActor && currentActor.type === "npc" && !currentActor.hasReplied) {
        console.log(`[AdventureHomeContent] Initial turn load: NPC (${currentActor.id}) waiting for turn ${turn.id}. Triggering check.`)
        ensureNpcProcessed(turn.id as Id<"turns">)
          .then((result) => {
            console.log(`[AdventureHomeContent] ensureNpcProcessed result:`, result)
          })
          .catch((error) => {
            console.error(`[AdventureHomeContent] Error calling ensureNpcProcessed:`, error)
          })
      }
    }
  }, [turn, initialCheckDone])

  const imageUrl = getImageUrl(image)

  return (
    <>
      <div className="flex flex-col items-center min-h-screen relative">
        <ImageHeader variant={turn ? "default" : "compact"} imageUrl={imageUrl} title={adventure.title} subtitle={turn?.title} imageAlt={turn?.title || adventure.title} />
        {turn ? <Turn /> : <AdventureLobby adventure={adventure} adventurePlan={adventurePlan} />}
      </div>
    </>
  )
}

export default AdventureHomeContent


/*
  File: components/views/adventure-home.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components/views/adventure-home.tsx
  Directory: components/views
*/

--- File: components/views/adventure-home.tsx ---

"use client"

import React from "react"
import { Adventure } from "@/types/adventure"
import type { Turn as TurnType } from "@/types/adventure"
import type { AdventurePlan } from "@/types/adventure-plan"
import { TurnProvider } from "@/lib/context/TurnContext"
import { AdventureProvider } from "@/lib/context/AdventureContext"
import AdventureHomeContent from "@/components/views/adventure-home-content"

function AdventureHome({
  adventurePlanId,
  settingId,
  adventure,
  encounterImage,
  currentTurn,
  adventurePlan,
  disableSSE = false,
}: {
  adventurePlanId: string
  settingId: string
  adventure: Adventure
  encounterImage: string
  currentTurn: TurnType | null
  adventurePlan?: AdventurePlan
  disableSSE?: boolean
}) {
  return (
    <AdventureProvider settingId={settingId} adventurePlanId={adventurePlanId} adventure={adventure}>
      <TurnProvider adventureId={adventure?.id ?? ""} initialTurn={currentTurn} disableSSE={disableSSE}>
        <AdventureHomeContent initialImage={encounterImage} initialSubtitle={currentTurn?.title || ""} adventure={adventure} adventurePlan={adventurePlan} />
      </TurnProvider>
    </AdventureProvider>
  )
}

export default AdventureHome


/*
  File: components.json
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/components.json
  Directory: .
*/

--- File: components.json ---

{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

/*
  File: convex/README.md
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/convex/README.md
  Directory: convex
*/

--- File: convex/README.md ---

# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// functions.js
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.functions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// functions.js
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get(id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.functions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.


/*
  File: convex/adventure.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/convex/adventure.ts
  Directory: convex
*/

--- File: convex/adventure.ts ---

import { query, mutation, action, internalMutation } from "./_generated/server";
import { v } from "convex/values";
import type { Doc, Id } from "./_generated/dataModel";

// Create a new adventure
export const createAdventure = mutation({
  args: {
    planId: v.string(),
    settingId: v.string(),
    ownerId: v.string(),
    playerIds: v.array(v.string()),
    players: v.optional(v.array(v.object({
      userId: v.string(),
      characterId: v.string(),
    }))),
    status: v.optional(v.union(
      v.literal("waitingForPlayers"),
      v.literal("active"),
      v.literal("completed")
    )),
    title: v.string(),
    startedAt: v.number(),
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    const adventureId = await ctx.db.insert("adventures", {
      planId: args.planId,
      settingId: args.settingId,
      ownerId: args.ownerId,
      playerIds: args.playerIds,
      players: args.players,
      status: args.status,
      startedAt: args.startedAt,
      endedAt: undefined,
      currentTurnId: undefined,
      title: args.title,
      createdAt: now,
      updatedAt: now,
    });
    return adventureId;
  },
});

// Join an existing adventure
export const joinAdventure = mutation({
  args: {
    adventureId: v.id("adventures"),
    userId: v.string(),
    characterId: v.string(),
  },
  handler: async (ctx, args) => {
    const adventure = await ctx.db.get(args.adventureId);
    if (!adventure) throw new Error("Adventure not found");
    
    // Check if user is already in the adventure
    const existingPlayer = adventure.players?.find(p => p.userId === args.userId);
    if (existingPlayer) {
      throw new Error("User is already in this adventure");
    }
    
    // Check if character is already taken
    const characterTaken = adventure.players?.find(p => p.characterId === args.characterId);
    if (characterTaken) {
      throw new Error("Character is already taken");
    }
    
    // Add the player to the adventure
    const updatedPlayers = [...(adventure.players || []), {
      userId: args.userId,
      characterId: args.characterId,
    }];
    
    const now = Date.now();
    
    await ctx.db.patch(args.adventureId, {
      players: updatedPlayers,
      playerIds: [...adventure.playerIds, args.userId],
      updatedAt: now,
    });
    
    return true;
  },
});

// Create a new turn for an adventure
export const createTurn = mutation({
  args: {
    adventureId: v.id("adventures"),
    encounterId: v.string(),
    title: v.string(),
    narrative: v.string(),
    characters: v.array(v.any()), // Should match character object
    order: v.number(),
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    const turnId = await ctx.db.insert("turns", {
      adventureId: args.adventureId,
      encounterId: args.encounterId,
      title: args.title,
      narrative: args.narrative,
      characters: args.characters,
      order: args.order,
      createdAt: now,
      updatedAt: now,
    });
    // Update adventure's currentTurnId
    await ctx.db.patch(args.adventureId, { currentTurnId: turnId, updatedAt: now });
    return turnId;
  },
});

// Update a turn (narrative or characters)
export const updateTurn = mutation({
  args: {
    turnId: v.id("turns"),
    narrative: v.optional(v.string()),
    characters: v.optional(v.array(v.any())),
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    const patch: Partial<Doc<"turns">> = { updatedAt: now };
    if (args.narrative !== undefined) patch.narrative = args.narrative;
    if (args.characters !== undefined) patch.characters = args.characters as Doc<"turns">["characters"];
    await ctx.db.patch(args.turnId, patch);
    return true;
  },
});

// Query: Get current adventure and its current turn
export const getCurrentAdventure = query({
  args: { adventureId: v.id("adventures"), refreshKey: v.optional(v.number()) },
  handler: async (ctx, args) => {
    const adventure = await ctx.db.get(args.adventureId);
    if (!adventure) return null;
    let currentTurn = null;
    if (adventure.currentTurnId) {
      currentTurn = await ctx.db.get(adventure.currentTurnId as Id<"turns">);
      console.log("[getCurrentAdventure] loaded currentTurn:", JSON.stringify(currentTurn, null, 2));
    } else {
      console.log("[getCurrentAdventure] No currentTurnId on adventure");
    }
    return { adventure, currentTurn };
  },
});

// Mutation: Get current adventure and process NPC turn if needed
export const getCurrentAdventureWithNpcProcessing = mutation({
  args: { adventureId: v.id("adventures"), refreshKey: v.optional(v.number()) },
  handler: async (ctx, args) => {
    const adventure = await ctx.db.get(args.adventureId);
    if (!adventure) return null;
    let currentTurn = null;
    if (adventure.currentTurnId) {
      currentTurn = await ctx.db.get(adventure.currentTurnId as Id<"turns">);
    } else {
      console.log("[getCurrentAdventureWithNpcProcessing] No currentTurnId on adventure");
    }
    return { adventure, currentTurn };
  },
});

export const createAdventureWithFirstTurn = mutation({
  args: {
    planId: v.string(),
    settingId: v.string(),
    ownerId: v.string(),
    playerIds: v.array(v.string()),
    title: v.string(),
    startedAt: v.number(),
    playerInput: v.string(),
    turn: v.object({
      encounterId: v.string(),
      title: v.string(),
      narrative: v.string(),
      characters: v.array(v.any()),
      order: v.number(),
    }),
    rollRequirement: v.optional(v.any()),
  },
  handler: async (ctx, args) => {
    console.log("[createAdventureWithFirstTurn] CALLED");
    const now = Date.now();
    const adventureId = await ctx.db.insert("adventures", {
      planId: args.planId,
      settingId: args.settingId,
      ownerId: args.ownerId,
      playerIds: args.playerIds,
      startedAt: args.startedAt,
      title: args.title,
      createdAt: now,
      updatedAt: now,
    });

    // --- Use rollRequirement from args, no AI calls here ---
    const turn = { ...args.turn };
    if (args.rollRequirement && turn.characters.length > 0) {
      const actor = turn.characters[0];
      turn.characters = turn.characters.map((c) =>
        c.id === actor.id
          ? {
              ...c,
              hasReplied: true,
              isComplete: !args.rollRequirement,
              rollRequired: args.rollRequirement || undefined,
              rollResult: undefined,
            }
          : c
      );
    }
    // Log just before insert
    console.log("[createAdventureWithFirstTurn] INSERT turn:", JSON.stringify(turn, null, 2));

    const turnId = await ctx.db.insert("turns", {
      adventureId,
      ...turn,
      createdAt: now,
      updatedAt: now,
    });
    await ctx.db.patch(adventureId, { currentTurnId: turnId, updatedAt: now });
    return { adventureId, turnId };
  },
});

// Action: AI rewrite of reply (no DB access)
export const aiRewriteReply = action({
  args: {
    characterName: v.string(),
    playerInput: v.string(),
    narrativeContext: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    // TODO: Call your AI service here (Google Gemini, etc.)
    // For now, just return the playerInput as a placeholder
    return args.playerInput;
  },
});

// Mutation: Submit reply (updates turn with AI result)
export const submitReply = mutation({
  args: {
    turnId: v.id("turns"),
    characterId: v.string(),
    narrativeAction: v.string(),
    rollRequirement: v.optional(v.any()),
  },
  handler: async (ctx, args) => {
    const turn = await ctx.db.get(args.turnId);
    if (!turn) throw new Error("Turn not found");
    const character = turn.characters.find((c) => c.id === args.characterId);
    if (!character) throw new Error("Character not found");
    const prev = turn.narrative || "";
    const narrative = prev ? `${prev}\n\n${args.narrativeAction}` : args.narrativeAction;

    // Use rollRequirement from args, do not call AI here!
    const updatedCharacters = turn.characters.map((c) =>
      c.id === args.characterId
        ? {
            ...c,
            hasReplied: true,
            isComplete: !args.rollRequirement,
            rollRequired: args.rollRequirement || undefined,
            rollResult: undefined,
          }
        : c
    );

    await ctx.db.patch(args.turnId, {
      narrative,
      characters: updatedCharacters,
    });
    return await ctx.db.get(args.turnId);
  },
});

// Internal query: Get a turn by ID
export const getTurnById = query({
  args: { turnId: v.id("turns") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.turnId);
  },
});

// Query: Get a turn by adventure ID and order
export const getTurnByOrder = query({
  args: { 
    adventureId: v.id("adventures"), 
    order: v.number() 
  },
  handler: async (ctx, args) => {
    const turn = await ctx.db
      .query("turns")
      .withIndex("by_adventure", (q) => q.eq("adventureId", args.adventureId))
      .filter((q) => q.eq(q.field("order"), args.order))
      .first();
    return turn;
  },
});

// Query: Get all turns for an adventure ordered by turn order
export const getTurnsByAdventure = query({
  args: { adventureId: v.id("adventures") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("turns")
      .withIndex("by_adventure", (q) => q.eq("adventureId", args.adventureId))
      .order("asc")
      .collect();
  },
});

// Internal mutation: Patch a turn by ID
export const patchTurn = internalMutation({
  args: {
    turnId: v.id("turns"),
    patch: v.object({
      narrative: v.optional(v.string()),
      characters: v.optional(v.array(v.any())),
      updatedAt: v.optional(v.number()),
    }),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.turnId, args.patch);
    return true;
  },
});

// Action: Get encounter context (intro/instructions)
export const getEncounterContext = action({
  args: { encounterId: v.string() },
  handler: async () => {
    // TODO: Implement real logic to fetch encounter context
    // Placeholder
    return {
      intro: "Encounter intro goes here.",
      instructions: "Encounter instructions go here.",
    };
  },
});

// Query: Get adventure by ID
export const getAdventureById = query({
  args: { adventureId: v.id("adventures") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.adventureId);
  },
});

// Internal mutation: Patch an adventure by ID
export const patchAdventure = internalMutation({
  args: {
    adventureId: v.id("adventures"),
    patch: v.object({
      currentTurnId: v.optional(v.id("turns")),
      updatedAt: v.optional(v.number()),
      endedAt: v.optional(v.number()),
      // Add other fields as needed
    }),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.adventureId, args.patch);
    return true;
  },
});

// Query: Get turn navigation info (efficient - minimal data transfer)
export const getTurnNavigationInfo = query({
  args: { adventureId: v.id("adventures") },
  handler: async (ctx, args) => {
    // Get adventure with current turn info
    const adventure = await ctx.db.get(args.adventureId);
    if (!adventure) return null;

    // Count total turns efficiently
    const turns = await ctx.db
      .query("turns")
      .withIndex("by_adventure", (q) => q.eq("adventureId", args.adventureId))
      .collect();
    
    const totalTurns = turns.length;

    // Get current turn order if exists
    let currentTurnOrder = null;
    if (adventure.currentTurnId) {
      const currentTurn = await ctx.db.get(adventure.currentTurnId as Id<"turns">);
      currentTurnOrder = currentTurn?.order || null;
    }

    return {
      totalTurns,
      currentTurnOrder
    };
  },
});

/*
  File: convex/mailingList.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/convex/mailingList.ts
  Directory: convex
*/

--- File: convex/mailingList.ts ---

import { v } from "convex/values";
import { mutation, query } from "./_generated/server";
import { Doc } from "./_generated/dataModel";

// Types
export type MailingListSubscription = Doc<"mailing_list_subscriptions">;

// Queries
export const getSubscriptions = query({
  handler: async (ctx) => {
    try {
      return await ctx.db
        .query("mailing_list_subscriptions")
        .order("desc")
        .collect();
    } catch (error) {
      console.error("Error getting subscriptions:", error);
      throw error;
    }
  },
});

export const getSubscriptionByEmail = query({
  args: { email: v.string() },
  handler: async (ctx, args) => {
    try {
      return await ctx.db
        .query("mailing_list_subscriptions")
        .withIndex("by_email", (q) => q.eq("email", args.email))
        .first();
    } catch (error) {
      console.error("Error getting subscription by email:", error);
      throw error;
    }
  },
});

// Mutations
export const subscribe = mutation({
  args: {
    userId: v.string(),
    email: v.string(),
    name: v.optional(v.string()),
    preferences: v.optional(v.object({
      marketing: v.boolean(),
      updates: v.boolean(),
    })),
  },
  handler: async (ctx, args) => {
    try {
      // Check if email already exists
      const existing = await ctx.db
        .query("mailing_list_subscriptions")
        .withIndex("by_email", (q) => q.eq("email", args.email))
        .first();

      if (existing) {
        // If already subscribed, perhaps update their info or just return existing?
        // For a waitlist, re-subscribing might just confirm their interest.
        // Or, if they were unsubscribed, re-subscribe them.
        // For now, throwing error if active. If unsubscribed, allow re-subscribe.
        if (!existing.unsubscribedAt) {
          throw new Error("Email already subscribed");
        }
        // If they are re-subscribing after being unsubscribed:
        const now = Date.now();
        return await ctx.db.patch(existing._id, {
            name: args.name,
            preferences: args.preferences ?? { marketing: false, updates: false },
            unsubscribedAt: null, // Re-subscribe
            updatedAt: now,
            // Note: subscribedAt and createdAt remain from original subscription
        });
      }

      const now = Date.now();
      const subscription = {
        userId: args.userId,
        email: args.email,
        name: args.name,
        preferences: args.preferences ?? { marketing: false, updates: false }, // Default if not provided
        subscribedAt: now,
        unsubscribedAt: null,
        createdAt: now,
        updatedAt: now,
      };

      const id = await ctx.db.insert("mailing_list_subscriptions", subscription);
      return await ctx.db.get(id);
    } catch (error) {
      console.error("Error subscribing:", error);
      throw error;
    }
  },
});

export const unsubscribe = mutation({
  args: { 
    email: v.string(),
  },
  handler: async (ctx, args) => {
    try {
      console.log('[unsubscribe] Attempting to unsubscribe email:', args.email);
      const subscription = await ctx.db
        .query("mailing_list_subscriptions")
        .withIndex("by_email", (q) => q.eq("email", args.email))
        .first();
      console.log('[unsubscribe] Subscription found:', subscription);
      if (!subscription) {
        throw new Error("Subscription not found");
      }
      const now = Date.now();
      await ctx.db.patch(subscription._id, {
        unsubscribedAt: now,
        updatedAt: now,
      });
      return true;
    } catch (error) {
      console.error("Error unsubscribing:", error);
      throw error;
    }
  },
});

export const deleteSubscription = mutation({
  args: { id: v.id("mailing_list_subscriptions") },
  handler: async (ctx, args) => {
    await ctx.db.delete(args.id);
  },
}); 

/*
  File: convex/schema.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/convex/schema.ts
  Directory: convex
*/

--- File: convex/schema.ts ---

import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

// Define your schema
export default defineSchema({
  visits: defineTable({
    path: v.string(),
    userId: v.union(v.string(), v.null()),
    metadata: v.any(),
    createdAt: v.number(),
    updatedAt: v.number(),
  }).index("by_user", ["userId"])
    .index("by_path", ["path"])
    .index("by_created", ["createdAt"]),

  mailing_list_subscriptions: defineTable({
    userId: v.string(),
    email: v.string(),
    name: v.optional(v.string()),
    preferences: v.object({
      marketing: v.boolean(),
      updates: v.boolean(),
    }),
    subscribedAt: v.number(),
    unsubscribedAt: v.union(v.number(), v.null()),
    createdAt: v.number(),
    updatedAt: v.number(),
  }).index("by_email", ["email"])
    .index("by_user", ["userId"])
    .index("by_subscribed", ["subscribedAt"]),

  // Multiplayer Adventure Tables
  adventures: defineTable({
    planId: v.string(),
    settingId: v.string(),
    ownerId: v.string(),
    playerIds: v.array(v.string()),
    players: v.optional(v.array(v.object({
      userId: v.string(),
      characterId: v.string(),
    }))),
    status: v.optional(v.union(
      v.literal("waitingForPlayers"),
      v.literal("active"),
      v.literal("completed")
    )),
    startedAt: v.number(),
    endedAt: v.optional(v.number()),
    currentTurnId: v.optional(v.id("turns")),
    title: v.string(),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_owner", ["ownerId"])
    .index("by_player", ["playerIds"])
    .index("by_started", ["startedAt"]),

  turns: defineTable({
    adventureId: v.id("adventures"),
    encounterId: v.string(),
    title: v.string(),
    narrative: v.string(),
    characters: v.array(
      v.object({
        id: v.string(),
        name: v.string(),
        type: v.string(), // "pc" | "npc"
        userId: v.optional(v.string()),
        initiative: v.number(),
        isComplete: v.boolean(),
        hasReplied: v.boolean(),
        rollRequired: v.optional(v.any()),
        rollResult: v.optional(v.number()),
        healthPercent: v.optional(v.number()),
        image: v.optional(v.string()),
        gender: v.optional(v.string()),
        race: v.optional(v.string()),
        archetype: v.optional(v.string()),
        // Added fields for AI/gameplay context
        appearance: v.optional(v.string()),
        background: v.optional(v.string()),
        behavior: v.optional(v.string()),
        motivation: v.optional(v.string()),
        personality: v.optional(v.string()),
        skills: v.optional(v.array(v.string())),
        equipment: v.optional(v.array(v.object({
          name: v.string(),
          description: v.optional(v.string()),
        }))),
        attributes: v.optional(
          v.object({
            strength: v.optional(v.number()),
            dexterity: v.optional(v.number()),
            constitution: v.optional(v.number()),
            intelligence: v.optional(v.number()),
            wisdom: v.optional(v.number()),
            charisma: v.optional(v.number()),
          })
        ),
        spells: v.optional(v.array(v.object({
          name: v.string(),
          description: v.string(),
          isUsed: v.boolean(),
        }))),
        specialAbilities: v.optional(v.array(v.string())),
        status: v.optional(v.string()),
      })
    ),
    order: v.number(),
    isFinalEncounter: v.optional(v.boolean()),
    createdAt: v.number(),
    updatedAt: v.optional(v.number()),
  })
    .index("by_adventure", ["adventureId"])
    .index("by_encounter", ["encounterId"]),

  userTokenLedger: defineTable({
    userId: v.string(), // Clerk User ID
    alltimeTokens: v.number(), // Total tokens ever granted or purchased by the user
    tokensRemaining: v.number(), // Current spendable balance
    lastTokenUpdate: v.optional(v.number()), // Timestamp of the last update to token fields
  }).index("by_userId", ["userId"]),

  tokenTransactionHistory: defineTable({
    userId: v.string(), // Clerk User ID, to link to userTokenLedger
    type: v.union( // Type of transaction
      v.literal("initial_grant"),
      v.literal("purchase"),
      v.literal("usage_generate_text"),
      v.literal("usage_generate_object"),
      v.literal("usage_image_upload"),
      v.literal("adjustment_manual") // For admin corrections or other types
    ),
    amount: v.number(), // Positive for additions (grants, purchases), negative for deductions (usage)
    timestamp: v.number(), // Timestamp of the transaction
    description: v.optional(v.string()), // Optional details about the transaction
    tokensRemainingAfterTransaction: v.optional(v.number()) // User's token balance after this transaction
  }).index("by_userId", ["userId"])
    .index("by_timestamp", ["timestamp"]),
}); 

/*
  File: convex/testing.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/convex/testing.ts
  Directory: convex
*/

--- File: convex/testing.ts ---

import { v } from "convex/values"
import { mutation, query } from "./_generated/server"

function isTestOrDevEnv() {
  return process.env.NODE_ENV === "test" || process.env.NODE_ENV === "development";
}

/**
 * Delete all documents from a table
 * This mutation should only be available in test environments
 */
export const deleteAll = mutation({
  args: { tableName: v.union(
    v.literal("visits"),
    v.literal("mailing_list_subscriptions"),
    v.literal("adventures"),
    v.literal("turns")
  ) },
  handler: async (ctx, args) => {
    if (!isTestOrDevEnv()) {
      throw new Error("This operation is only allowed in test or development environments");
    }
    const documents = await ctx.db.query(args.tableName).collect()
    for (const doc of documents) {
      await ctx.db.delete(doc._id)
    }
    return { success: true }
  },
})

/**
 * Count documents in a table
 * This query should only be available in test environments
 */
export const countDocuments = query({
  args: { tableName: v.union(v.literal("visits"), v.literal("mailing_list_subscriptions")) },
  handler: async (ctx, args) => {
    if (!isTestOrDevEnv()) {
      throw new Error("This operation is only allowed in test or development environments");
    }
    const documents = await ctx.db.query(args.tableName).collect()
    return documents.length
  },
})

/**
 * Seed test data for visits and mailing_list_subscriptions
 * This mutation should only be available in test environments
 */
export const seedTestData = mutation({
  args: {},
  handler: async (ctx) => {
    if (!isTestOrDevEnv()) {
      throw new Error("This operation is only allowed in test or development environments");
    }
    // Seed visits
    await ctx.db.insert("visits", {
      path: "/test-path",
      userId: "test-user",
      metadata: { test: true },
      createdAt: Date.now(),
      updatedAt: Date.now(),
    });
    // Seed mailing list subscriptions
    await ctx.db.insert("mailing_list_subscriptions", {
      userId: "test-user",
      email: "test@example.com",
      name: "Test User",
      preferences: { marketing: true, updates: true },
      subscribedAt: Date.now(),
      unsubscribedAt: null,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    });
    return { success: true };
  },
}); 

/*
  File: convex/testinternal.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/convex/testinternal.ts
  Directory: convex
*/

--- File: convex/testinternal.ts ---

import { internalAction } from "./_generated/server";
import { v } from "convex/values";

export const testInternal = internalAction({
  args: { foo: v.string() },
  handler: async (ctx, args) => {
    console.log("[testInternal] called with foo:", args.foo);
    return args.foo;
  },
}); 

/*
  File: convex/tsconfig.json
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/convex/tsconfig.json
  Directory: convex
*/

--- File: convex/tsconfig.json ---

{
  /* This TypeScript project config describes the environment that
   * Convex functions run in and is used to typecheck them.
   * You can modify it, but some settings required to use Convex.
   */
  "compilerOptions": {
    /* These settings are not required by Convex and can be modified. */
    "allowJs": true,
    "strict": true,
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "skipLibCheck": true,
    "allowSyntheticDefaultImports": true,

    /* These compiler options are required by Convex */
    "target": "ESNext",
    "lib": ["ES2021", "dom"],
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "isolatedModules": true,
    "noEmit": true
  },
  "include": ["./**/*"],
  "exclude": ["./_generated"]
}


/*
  File: convex/turns.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/convex/turns.ts
  Directory: convex
*/

--- File: convex/turns.ts ---

import { mutation } from "./_generated/server";
import { v } from "convex/values";

// Minimal mutation: create a new turn
export const createTurn = mutation({
  args: {
    adventureId: v.id("adventures"),
    encounterId: v.string(),
    title: v.string(),
    narrative: v.string(),
    characters: v.array(v.any()),
    order: v.number(),
    isFinalEncounter: v.optional(v.boolean()),
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    return await ctx.db.insert("turns", {
      adventureId: args.adventureId,
      encounterId: args.encounterId,
      title: args.title,
      narrative: args.narrative,
      characters: args.characters,
      order: args.order,
      isFinalEncounter: args.isFinalEncounter,
      createdAt: now,
      updatedAt: now,
    });
  },
});

// Minimal mutation: update a turn (patch)
export const updateTurn = mutation({
  args: {
    turnId: v.id("turns"),
    patch: v.object({
      narrative: v.optional(v.string()),
      characters: v.optional(v.array(v.any())),
      updatedAt: v.optional(v.number()),
    }),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.turnId, args.patch);
    return true;
  },
});

// Minimal mutation: patch adventure
export const patchAdventure = mutation({
  args: {
    adventureId: v.id("adventures"),
    patch: v.object({
      currentTurnId: v.optional(v.id("turns")),
      updatedAt: v.optional(v.number()),
      endedAt: v.optional(v.number()),
    }),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.adventureId, args.patch);
    return true;
  },
}); 

/*
  File: convex/userTokenManagement.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/convex/userTokenManagement.ts
  Directory: convex
*/

--- File: convex/userTokenManagement.ts ---

import { mutation, query } from "./_generated/server";
import { v } from "convex/values";

const INITIAL_TOKEN_GRANT = 1000;

export const ensureUserTokenRecord = mutation({
  args: { userId: v.string() },
  handler: async (ctx, args) => {
    const existingRecord = await ctx.db
      .query("userTokenLedger")
      .withIndex("by_userId", (q) => q.eq("userId", args.userId))
      .unique();

    if (!existingRecord) {
      const now = Date.now();
      // Create the ledger entry
      const ledgerId = await ctx.db.insert("userTokenLedger", {
        userId: args.userId,
        alltimeTokens: INITIAL_TOKEN_GRANT,
        tokensRemaining: INITIAL_TOKEN_GRANT,
        lastTokenUpdate: now,
      });

      // Create the initial transaction history entry
      await ctx.db.insert("tokenTransactionHistory", {
        userId: args.userId,
        type: "initial_grant",
        amount: INITIAL_TOKEN_GRANT, // Positive for a grant
        timestamp: now,
        description: "Initial token grant upon account creation.",
        tokensRemainingAfterTransaction: INITIAL_TOKEN_GRANT,
      });

      return { 
        status: "created", 
        userId: args.userId,
        tokensRemaining: INITIAL_TOKEN_GRANT, 
        alltimeTokens: INITIAL_TOKEN_GRANT,
        ledgerId: ledgerId
      };
    }

    return { 
      status: "exists", 
      userId: args.userId, 
      tokensRemaining: existingRecord.tokensRemaining, 
      alltimeTokens: existingRecord.alltimeTokens ?? 0, // Handle case where it might be undefined due to migration
      ledgerId: existingRecord._id
    };
  },
});

export const decrementTokens = mutation({
  args: {
    userId: v.string(),
    tokensUsed: v.number(),
    transactionType: v.union(
      v.literal("usage_generate_text"),
      v.literal("usage_generate_object"),
      v.literal("usage_image_upload"),
      // Add other usage types as needed
    ),
    description: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    if (args.tokensUsed <= 0) {
      // No actual cost, or invalid input
      // Optionally log this or return a specific status if needed
      return { success: true, message: "No tokens to decrement or invalid amount.", tokensRemaining: null };
    }

    const userLedger = await ctx.db
      .query("userTokenLedger")
      .withIndex("by_userId", (q) => q.eq("userId", args.userId))
      .unique();

    if (!userLedger) {
      throw new Error(`User token ledger not found for userId: ${args.userId}. Cannot decrement tokens.`);
    }

    if (userLedger.tokensRemaining < args.tokensUsed) {
      // Not enough tokens. Log this attempt if desired.
      // For now, just throw an error. You could also create a transaction history entry for the failed attempt.
      await ctx.db.insert("tokenTransactionHistory", {
        userId: args.userId,
        type: args.transactionType, 
        amount: -args.tokensUsed, // Record the attempted usage as negative
        timestamp: Date.now(),
        description: args.description ? `${args.description} (Failed - Insufficient tokens)` : `Attempted ${args.transactionType} (Failed - Insufficient tokens)`,
        tokensRemainingAfterTransaction: userLedger.tokensRemaining, // Balance before this failed attempt
      });
      throw new Error(
        `Insufficient tokens for userId: ${args.userId}. ` +
        `Required: ${args.tokensUsed}, Available: ${userLedger.tokensRemaining}.`
      );
    }

    const now = Date.now();
    const newTokensRemaining = userLedger.tokensRemaining - args.tokensUsed;

    await ctx.db.patch(userLedger._id, {
      tokensRemaining: newTokensRemaining,
      lastTokenUpdate: now,
    });

    await ctx.db.insert("tokenTransactionHistory", {
      userId: args.userId,
      type: args.transactionType,
      amount: -args.tokensUsed, // Negative for a deduction
      timestamp: now,
      description: args.description,
      tokensRemainingAfterTransaction: newTokensRemaining,
    });

    return { 
      success: true, 
      tokensRemaining: newTokensRemaining, 
      alltimeTokens: userLedger.alltimeTokens ?? 0 
    };
  },
});

export const getTokenBalance = query({
  args: { userId: v.string() },
  handler: async (ctx, args) => {
    // It's generally better for the calling server action to call ensureUserTokenRecord first.
    // However, if we want this query to be self-sufficient in ensuring a record exists:
    // await ctx.runMutation(api.userTokenManagement.ensureUserTokenRecord, { userId: args.userId });
    // For now, we'll assume ensureUserTokenRecord is called by the server action before this query.

    const userLedger = await ctx.db
      .query("userTokenLedger")
      .withIndex("by_userId", (q) => q.eq("userId", args.userId))
      .unique();

    if (!userLedger) {
      // This case should ideally be handled by ensureUserTokenRecord being called first.
      // If not, the user effectively has 0 tokens until their record is created.
      return { tokensRemaining: 0, alltimeTokens: 0, needsInitialization: true };
    }

    return {
      tokensRemaining: userLedger.tokensRemaining,
      // Handle case where alltimeTokens might be undefined due to schema migration
      alltimeTokens: userLedger.alltimeTokens ?? 0, 
      needsInitialization: false,
    };
  },
}); 

/*
  File: convex/utils.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/convex/utils.ts
  Directory: convex
*/

--- File: convex/utils.ts ---

import { v } from "convex/values";
import { MutationCtx, QueryCtx } from "./_generated/server";
import { Doc, Id } from "./_generated/dataModel";

// Type for successful responses
type SuccessResponse<T> = {
  success: true;
  data?: T;
  id?: Id<any>;
};

// Type for error responses
type ErrorResponse = {
  success: false;
  error: string;
};

// Combined response type
export type ConvexResponse<T = void> = SuccessResponse<T> | ErrorResponse;

// Helper to get current timestamp
export const getCurrentTimestamp = () => Date.now();

// Helper to create base fields for new documents
export const getBaseFields = () => ({
  createdAt: getCurrentTimestamp(),
  updatedAt: getCurrentTimestamp(),
});

// Helper to update timestamp
export const getUpdateFields = () => ({
  updatedAt: getCurrentTimestamp(),
});

// Helper for error handling
export const handleError = (error: unknown): ErrorResponse => ({
  success: false,
  error: error instanceof Error ? error.message : "Unknown error",
});

// Helper for success response
export const handleSuccess = <T>(data?: T, id?: Id<any>): SuccessResponse<T> => ({
  success: true,
  ...(data && { data }),
  ...(id && { id }),
});

// Validation helper
export const validateId = (id: Id<any>) => {
  if (!id) throw new Error("Invalid ID");
  return id;
};

// Query helper for pagination
export type PaginationOptions = {
  limit?: number;
  cursor?: string;
};

// Helper for handling pagination in queries
export const handlePagination = (
  ctx: QueryCtx,
  query: any,
  options?: PaginationOptions
) => {
  if (options?.limit) {
    query = query.take(options.limit);
  }
  if (options?.cursor) {
    query = query.continuePaginationFrom(options.cursor);
  }
  return query;
}; 

/*
  File: convex/visits.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/convex/visits.ts
  Directory: convex
*/

--- File: convex/visits.ts ---

import { v } from "convex/values";
import { mutation, query } from "./_generated/server";
import { Doc, Id } from "./_generated/dataModel";

// Schema is defined in schema.ts
export type Visit = {
  path: string;
  userId: string | null;
  metadata: Record<string, any>;
  createdAt: number;
  updatedAt: number;
};

export const recordVisit = mutation({
  args: {
    path: v.string(),
    userId: v.union(v.string(), v.null()),
    metadata: v.any(),
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    return await ctx.db.insert("visits", {
      path: args.path,
      userId: args.userId,
      metadata: args.metadata,
      createdAt: now,
      updatedAt: now,
    });
  },
});

export const getVisits = query({
  args: {
    userId: v.optional(v.union(v.string(), v.null())),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const query = args.userId !== undefined
      ? await ctx.db
          .query("visits")
          .withIndex("by_user", (q) => q.eq("userId", args.userId as string | null))
          .collect()
      : await ctx.db
          .query("visits")
          .withIndex("by_created")
          .collect();

    return args.limit !== undefined ? query.slice(0, args.limit) : query;
  },
});

export const getVisitsByPath = query({
  args: {
    path: v.string(),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const results = await ctx.db
      .query("visits")
      .withIndex("by_path", (q) => q.eq("path", args.path))
      .collect();

    return args.limit !== undefined ? results.slice(0, args.limit) : results;
  },
});

export const deleteVisit = mutation({
  args: { id: v.id("visits") },
  handler: async (ctx, args) => {
    await ctx.db.delete(args.id);
  },
}); 

/*
  File: data/covert-cargo.json
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/data/covert-cargo.json
  Directory: data
*/

--- File: data/covert-cargo.json ---

{
  "id": "covert-cargo",
  "settingId": "realm-of-myr",
  "title": "Covert Cargo",
  "author": "D20Adventures",
  "version": "1716220800",
  "teaser": "Docked on a discrete pier on a quiet fork of the Mordava River just before dawn, a river boat bearing a secret shipment bound for Kordavos sets a clandestine plot in motion.",
  "overview": "Docked on a discrete pier on a quiet fork of the Mordava River, a river boat bearing a secret shipment bound for Kordavos sets a clandestine plot in motion.",
  "party": [
    2,
    2
  ],
  "tags": [
    "fantasy",
    "solo",
    "investigation",
    "forest",
    "mystery"
  ],
  "image": "https://d1dkwd3w4hheqw.cloudfront.net/images/settings/realm-of-myr/covert-cargo/0897705a-12e6-42d8-9d96-d38faa1063ca.png?t=1749244724241",
  "sections": [
    {
      "title": "Section One",
      "summary": "",
      "scenes": [
        {
          "title": "Quiet Pier at Dawn",
          "summary": "Reinhard and Silas are agents of the Blackthorn that have been sent to escort a new agent, Lyra Silvanus (a PC) to verify an exchange with their elven contact from a reclusive settlement in the Valkarr forest. \n\nSilas only knows that it the shipment is a crate containing some sort of enchanted relic of Old Valkara but that is all he knows. He has been instructed by his handler (a half-elf named Eamon Drakovan) to keep the crate sealed. Varius is simply his muscle. \n\nIt is their first such exchange and Silas knows establishing a relationship with the mysterious Aelar Moonglimmer is very important, so he and Reinhard will not ever engage in combat with the elves, even if things go wrong.\n\nTo avoid any possible scandal should this be some sort of trick by their rival clans, they hired an outsider (Lyra) to certify the authenticity of the shipment. After Lyra verbally gives confirmation, they are to take possession of the boat, while the elves return to the Valkarr forest on foot.\n\nAelar has no wish to spend any longer here than he needs to. He wishes for the the humans to accept the relic then he will depart with his companions.\n\nOnce the elves are gone, Silas will have Reinhard eliminate Lyra who knows too much. However, her bookish nature may have caused them to underestimate her skills. There is also the matter of Poppen Quickfoot, a halfling troublemaker who has stumbled onto their little secret interchange and might ruin their plans.",
          "encounters": [
            {
              "id": "the-shipment",
              "title": "The Shipment",
              "intro": "Docked on a discrete pier on a quiet fork of the Mordava River, a river boat bearing a shipment bound for Kordavos rests silently on the dark, placid water.\n\nThe air is cool and damp, thick with the scent of wet earth and the chirping of crickets. The only other sounds are the gentle lapping of water against the pier's aging pylons and the rustle of wind through the skeletal branches of the willow trees.\n\nLyra stands inside the boat, the mysterious cargo crate before her. Silas’s instructions were explicit. Her sole purpose is to verify the authenticity of a Valkaaran artifact using her arcane talents. She is to confirm its magical properties, give a simple nod, and her part will be done. She will be well compensated for her expertise and, more importantly, her discretion.\n\nFor her part, it was hard to resist getting the chance to interact with reclusive Faelendarian elves and also get a chance to be near a Valkaran relic. She had studied both at length, but there was a big difference between reading old dusty tomes and experiencing the real thing.\n\nShe did not know much of her two escorts. There was Reinhard, a large gruff soldier type who was in charge of security for this little mission. Silas had recruited her, noticing her frequent visits to the Old Valkaran Archives section at the Grand Library. Where Varius was a stone wall of presence, Silas was a whisper. He was slender, moving with a liquid grace that spoke of a life spent in shadows. \n\nMeanwhile, from his cleverly concealed vantage within a tangle of overgrown reeds, Poppen Quickfoot watched the scene unfold, a small smile playing on his lips. The cool water of the Mordava lapped just inches from his boots, but he remained utterly still, his senses stretched. Weeks of patient stakeouts had led him to this exact predawn hour, this quiet fork of the river, following the threads of rumor about a clandestine trade. His instinct, honed by a lifetime of seeking out hidden value, told him this was it—the score that would truly mark his arrival in Kordavos.\n\nHis keen hazel eyes, accustomed to discerning worth from a glint in the dark, tracked the three figures on the pier. The hulking soldier, the robed woman, and the whispering shadow-man. A professional crew, indeed; no sloppy thugs. This wasn't just any cargo; this was an item of importance, something worth securing. Poppen’s mind raced, not just with the thought of fencing such a treasure, but with the delicious social connections such a coup would bring.\n\nA soft creak of wood from the ship cuts through the night's quiet hum as the cabin door opened. A figure emerges with a silent, deliberate grace that was distinctly elven. He is tall and lithe, clad in dark, practical leather armor. Two other elves, equally silent and alert, could be seen on the boat's deck, one near the bow and another by the stern, both armed with bows.\n\nThe lead elf steps forward to the edge of his boat, his gaze settling on Lyra's escorts. His voice is low and clear, carrying easily across the water without being loud.\n\n\"You have the arrangement?\" asked the elf.\n\n“I have it here Aelar,” Silas replies, gliding from the shadows at the base of the pier. He removes a heavy scrollcase from its oilskin wrapping.\n\n\"Very well,\" Aelar says, turning to give an order in Elvish to one of his crew. \"The shipment is ready for your specialist's inspection.\"\n\n“Ok, let’s get on with it then,” says Reinhard, nodding at Lyra, eager to get her to inspect the shipment and have the matter concluded. The crate remained closed. No one was allowed to see what was inside.\n\nLyra had been contracted for one simple task, use her magecraft to determine that the contents of the shipment were indeed arcane in nature.",
              "instructions": "If Lyra asks questions or stalls in any way, Reinhard and Silas will be impatient and urge her to do what she was paid for. If Lyra tries to engage Aelar in conversation he will be evasive. If she continues to delay, then Silas will nod at Varius who will draw his sword and threaten her.\n\nIf Lyra successfully casts a spell on the crate to detect magic, she will be detect an ancient potent enchantment on an object within the crate. On a highly successful roll of 18 or higher, she will determine its purpose to be related to concepts of binding promises, loyalty, and solemn vows. On a 20, she will be able to name the item as the Verodynian Oath Stone of the First Clans.",
              "image": "https://d1dkwd3w4hheqw.cloudfront.net/images/settings/realm-of-myr/covert-cargo/encounters/the-shipment/dccea2c5-b22d-41e0-9467-95d8ea2301d5.png?t=1749244761507",
              "transitions": [
                {
                  "condition": "If Lyra verbally confirms the magic properties of the shipment",
                  "encounter": "the-transaction"
                },
                {
                  "condition": "If Lyra says the shipment has no magical properties",
                  "encounter": "the-fake"
                },
                {
                  "condition": "If Poppen causes a distraction or anyone notices his presence",
                  "encounter": "the-disturbance"
                },
                {
                  "condition": "If ",
                  "encounter": ""
                }
              ],
              "skipInitialNpcTurns": true,
              "npc": [
                {
                  "id": "npcs-1749163978757",
                  "behavior": "Determined to complete the mission to secure the artifact.",
                  "initialInitiative": 0
                },
                {
                  "id": "npcs-1749181492795",
                  "behavior": "Silas is the brains of the mission and is tasked to make sure everything goes as planned.",
                  "initialInitiative": 0
                },
                {
                  "id": "npcs-1749184389465",
                  "behavior": "Eager to have the shipment verified",
                  "initialInitiative": 0
                }
              ]
            },
            {
              "id": "the-transaction",
              "title": "The Transaction",
              "intro": "Silas glided from the shadows, extending the oilskin-wrapped scrollcase to the elf, \"As agreed.\" \n\nAelar Moonglimmer took the offering, his  grey eyes, sharp and observant, held the rogue’s gaze. \"The Circle is appreciative,\" Aelar replied, his own voice just as quiet and controlled. \"They trust this partnership will prove fruitful for all involved.\"\n\nWith the exchange made, Aelar gave a final, sharp nod, then he and his kin made a quick and graceful exit, stepping off the boat and onto the pier. They moved like shadows across the rickety wood, disappearing into the shadows of the treeline without a single backward glance.",
              "instructions": "",
              "image": "https://d1dkwd3w4hheqw.cloudfront.net/images/settings/realm-of-myr/covert-cargo/encounters/the-transaction/1c232871-8395-4892-bcf9-543a03bede80.png?t=1749243102836",
              "transitions": [
                {
                  "condition": "After this encounter, always transition immediately to the Battle on the Boat encounter.",
                  "encounter": "battle-on-the-boat"
                }
              ],
              "npc": [
                {
                  "id": "npcs-1749163978757",
                  "behavior": "Varius silently awaits Silas’s instructions but will not let Lyra leave (if she tries to)",
                  "initialInitiative": 0
                },
                {
                  "id": "npcs-1749181492795",
                  "behavior": "Silas is pleased, the mission is almost over.",
                  "initialInitiative": 0
                }
              ],
              "skipInitialNpcTurns": true,
              "resetHealth": false
            },
            {
              "id": "the-fake",
              "title": "The Fake",
              "intro": "A silence, sharp and cold as a shard of glass, fell over the boat’s cabin in the wake of the arcanist’s pronouncement.\n\nIt was Silas who moved first. In a single, fluid motion, he was no longer lounging by the door but standing before it, blocking the only exit. A dagger appeared in his hand, its point aimed steadily at Aelar. \"There seems to have been a misunderstanding,\" Silas said, his voice dropping to a silken threat. \"My employers do not appreciate being sold worthless trinkets.\"\n\nReinhard let out a low, guttural growl, his hand dropping to the hilt of the massive blade at his side. \"You have nerve, elf,\" he snarled, his cold, calculating eyes promising violence as he took a heavy step forward.\n\nAelar Moonglimmer recoiled, but it was with the shock of indignation, not fear. His professional calm fractured into unconcealed fury. \"Worthless?\" he spat, his gaze flicking with contempt toward the unseen specialist. \"Your arcanist is either a fool, or you mean to double-cross us!”",
              "instructions": "Unless charmed, Silas will try to detect if Lyra is lying. Reinhard will do whatever Silas commands.",
              "image": "https://d1dkwd3w4hheqw.cloudfront.net/images/settings/realm-of-myr/covert-cargo/encounters/the-fake/7b96ca3c-db72-4559-8f8d-59dacbba3185.png?t=1749300003015",
              "transitions": [
                {
                  "condition": "If Lyra or Poppen attack",
                  "encounter": "battle-on-the-boat"
                },
                {
                  "condition": "Ultimately Silas wants to make this deal even if he isn't sure about the relic's authenticity.",
                  "encounter": "the-transaction"
                }
              ],
              "npc": [
                {
                  "id": "npcs-1749163978757",
                  "behavior": "Reinhard will follow Silas’s lead and orders.",
                  "initialInitiative": 0
                },
                {
                  "id": "npcs-1749181492795",
                  "behavior": "Silas will want to figure out who is telling lies - Lyra or Aelar. He will not attack the elves under any circumstances. If he is out of options, he will simply accept the shipment and complete the Transaction.",
                  "initialInitiative": 0
                },
                {
                  "id": "npcs-1749184389465",
                  "behavior": "Aelar will vigorously defend his honor. He does not wish for a fight but will defend himself if necessary.",
                  "initialInitiative": 0
                }
              ],
              "skipInitialNpcTurns": false,
              "resetHealth": false
            },
            {
              "id": "battle-on-the-boat",
              "title": "Battle on the Boat",
              "intro": "Reinhard turned, a semblance of a smile touching his lips but not his cold eyes. \"Good work, mage,\" he said, his voice suddenly relaxed. \"Your service is most appreciated, but we have our orders.\" He took a slow step, his bulk seeming to shrink the confines of the cabin. \n\nThe cabin door clicks shut, the sound unnaturally loud in the sudden stillness. Silas stands before it, blocking the only exit, the faint whisper of steel on leather the only warning as two wicked-looking daggers appear in his hands.\n\n“No loose ends,” he states, flatly.",
              "instructions": "",
              "image": "https://d1dkwd3w4hheqw.cloudfront.net/images/settings/realm-of-myr/covert-cargo/encounters/battle-on-the-boat/088f0e14-cd0f-4312-821b-fac650a518f6.png?t=1749324854329",
              "transitions": [
                {
                  "condition": "If Poppen tries to cause a distraction outside the boat or gets spotted",
                  "encounter": "the-fake"
                },
                {
                  "condition": "If Lyra successfully flees and evades capture",
                  "encounter": "the-escape"
                },
                {
                  "condition": "If Lyra and/or Poppen overcome Silas and Reinhard",
                  "encounter": "the-crate"
                }
              ],
              "npc": [
                {
                  "id": "npcs-1749163978757",
                  "behavior": "Will attack",
                  "initialInitiative": 0
                },
                {
                  "id": "npcs-1749181492795",
                  "behavior": "Will watch and only interfere if Varius is killed or gravely wounded.",
                  "initialInitiative": 0
                }
              ],
              "skipInitialNpcTurns": false,
              "resetHealth": false
            },
            {
              "id": "the-disturbance",
              "title": "The Disturbance",
              "intro": "Suddenly, the clandestine meeting is thrown off course by a sudden disturbance.",
              "instructions": "Aelar will order his two elves to investigate. Everyone else will stay with the shipment.",
              "image": "https://d1dkwd3w4hheqw.cloudfront.net/images/settings/realm-of-myr/covert-cargo/encounters/the-disturbance/e304a481-79a3-4c8d-a8da-ba9044991495.png?t=1749676178186",
              "transitions": [
                {
                  "condition": "If Poppen successfully hides, then the transaction will proceed as Silas will be eager to have the matter concluded, even if he has to skip Lyra's verification.",
                  "encounter": "the-transaction"
                },
                {
                  "condition": "If the characters flee",
                  "encounter": "the-escape"
                },
                {
                  "condition": "If it turns into a battle",
                  "encounter": "battle-on-the-boat"
                }
              ],
              "npc": [
                {
                  "id": "npcs-1749243735467",
                  "behavior": "Will back up the Fighter, her bow drawn.",
                  "initialInitiative": 0
                },
                {
                  "id": "npcs-1749243869357",
                  "behavior": "Will take the lead in investigating the cause of the disturbance. If he sees Poppen, he will aggressively tell him to go away.",
                  "initialInitiative": 0
                },
                {
                  "id": "npcs-1749163978757",
                  "behavior": "Varius will keep his eye on the shipment and Lyra.",
                  "initialInitiative": 0
                },
                {
                  "id": "npcs-1749181492795",
                  "behavior": "Silas will look outside for any threats but will not engage.",
                  "initialInitiative": 0
                },
                {
                  "id": "npcs-1749184389465",
                  "behavior": "",
                  "initialInitiative": 0
                }
              ],
              "skipInitialNpcTurns": false,
              "resetHealth": false
            },
            {
              "id": "the-escape",
              "title": "The Escape",
              "intro": "",
              "instructions": "In the beginning of this turn describe the circumstances of the escape, what the PCs and NPCs are doing. This encounter happens if the PCs have successfully fled the scene of the river boat.",
              "image": "https://d1dkwd3w4hheqw.cloudfront.net/images/settings/realm-of-myr/covert-cargo/encounters/the-escape/26311198-03c5-4f40-9a79-e75e9c48c524.png?t=1749675141542",
              "transitions": [
                {
                  "condition": "If the players mention returning, the city or Kordovas",
                  "encounter": "return-to-the-city"
                },
                {
                  "condition": "If the players want to go into hidin",
                  "encounter": "the-end"
                }
              ],
              "npc": [],
              "skipInitialNpcTurns": false,
              "resetHealth": false
            },
            {
              "id": "the-crate",
              "title": "The Crate",
              "intro": "The mysterious crate sits before you.",
              "instructions": "The crate is sealed tight. They can break it open after concerted effort with equipment lying around the ship. Inside is the large heavy sitting stone. It cannot easily be moved as it weighs about 500 pounds. Though it is a powerful artifact for binding oaths, it is of no immediate use to Lyra or Poppen. Continue with this encounter until they have resolved what they wish to do.\n\nSuggest they return to the city, which is about 3 miles away.",
              "image": "https://d1dkwd3w4hheqw.cloudfront.net/images/settings/realm-of-myr/covert-cargo/encounters/the-crate/a3a863a9-dca9-48da-b3fe-e8c4ad90af3a.png?t=1749674703995",
              "transitions": [
                {
                  "condition": "If they decide to go back, return, city or Kordavos.",
                  "encounter": "return-to-the-city"
                },
                {
                  "condition": "If they decide to do anything other than go back, return, city or Kordavos.",
                  "encounter": "the-end"
                }
              ],
              "npc": [],
              "skipInitialNpcTurns": false,
              "resetHealth": false
            },
            {
              "id": "return-to-the-city",
              "title": "Return to the City",
              "intro": "Kordavos, the capital city of the March of Davos, is a three mile trek back through the forest. It is the middle of the Harvest Festival so there will be many visitors, making it easy to blend in amongst the eclectic travellers from far and wide.",
              "instructions": "",
              "image": "https://d1dkwd3w4hheqw.cloudfront.net/images/settings/realm-of-myr/covert-cargo/encounters/return-to-the-city/280cc3ba-f72d-4e91-b839-8cec3778791b.png?t=1749677694632",
              "transitions": [],
              "npc": [],
              "skipInitialNpcTurns": false,
              "resetHealth": false
            },
            {
              "id": "the-end",
              "title": "The End",
              "intro": "The path forward remains uncertain, but things cannot be undone. Events have been set in motion and now all that remains is to move forward into the unknown.",
              "instructions": "",
              "image": "https://d1dkwd3w4hheqw.cloudfront.net/images/settings/realm-of-myr/covert-cargo/encounters/the-end/68166163-ba2c-4387-bfb6-a98343c6c9d7.png?t=1749678027089",
              "transitions": [],
              "npc": [],
              "skipInitialNpcTurns": false,
              "resetHealth": false
            }
          ]
        }
      ]
    }
  ],
  "npcs": {
    "npcs-1749163978757": {
      "name": "Reinhard",
      "archetype": "Enforcer",
      "race": "Human",
      "gender": "Male",
      "appearance": "A burly human with a scarred face, close-cropped dark hair, and cold, calculating eyes. He often wears a heavy, dark leather coat that conceals several hidden weapons. His posture is always rigid, exuding an aura of quiet menace.",
      "personality": "Stoic, ruthless, and highly pragmatic. Reinhard values efficiency and loyalty above all else. He rarely shows emotion, preferring to let his actions speak. He is fiercely loyal to the Blackthorn clan and expects the same from his subordinates. He has a dry, sardonic wit that surfaces only in moments of extreme stress or rare amusement.",
      "background": "Reinhard grew up on the fringes of society, learning early that power was taken, not given. He joined the Blackthorn clan as a young man, quickly rising through the ranks due to his unwavering loyalty, brutal efficiency, and strategic mind. He's been involved in countless 'fixer' operations, cleaning up messes and ensuring the clan's interests are protected. He sees the clan as his true family and its prosperity as his life's purpose.",
      "motivation": "To ensure the Blackthorn clan's dominance and security. The current mission to secure the shipment is critical to maintaining their influence and resources, and Kaelen will stop at nothing to see it through successfully.",
      "behavior": "Direct and to the point, Reinhard prefers action over words. He is highly observant and rarely misses details. When challenged, he responds with calm, calculated aggression.",
      "healthPercent": 100,
      "equipment": [
        {
          "name": "Heavy Leather Coat and Armor",
          "description": "A durable, dark leather coat over studded leather armor, offering protection and concealing multiple weapons."
        },
        {
          "name": "Long Sword",
          "description": ""
        },
        {
          "name": "Throwing knives",
          "description": "A razor-sharp throwing daggers."
        }
      ],
      "skills": [
        "Intimidation",
        "Stealth",
        "Investigation",
        "Perception",
        "Streetwise",
        "Tactics"
      ],
      "status": "",
      "type": "npc",
      "attributes": {
        "strength": 16,
        "dexterity": 14,
        "constitution": 15,
        "intelligence": 13,
        "wisdom": 12,
        "charisma": 10
      },
      "id": "npcs-1749163978757",
      "image": "images/settings/realm-of-myr/covert-cargo/npcs/236683b0-4745-4a8c-ad9d-48ed3bbaf908.png?t=1749164549983"
    },
    "npcs-1749181492795": {
      "name": "Silas",
      "archetype": "Rogue",
      "race": "Human",
      "gender": "Male",
      "appearance": "Silas is a lean and wiry, observant grey eyes that constantly scan his surroundings. He moves with a quiet, almost predatory grace, his movements fluid and economical.",
      "personality": "Sly, cynical, and highly independent. Silas is a pragmatist who trusts few and relies on his own skills. He possesses a dry wit that surfaces occasionally, often in the form of sarcastic remarks.",
      "background": "Silas grew up in the grimy back alleys of the city, learning to survive by his wits and nimble fingers. He has developed into a ruthless pragrmatist.",
      "motivation": "",
      "behavior": "",
      "healthPercent": 100,
      "equipment": [
        {
          "name": "Two finely balanced daggers",
          "description": "One tucked into each boot, their blades honed to a razor's edge."
        },
        {
          "name": "Set of masterwork lockpicks",
          "description": "Kept in a small, leather pouch, these tools are his most prized possessions."
        },
        {
          "name": "Dark leather armor",
          "description": "Light and flexible, designed for stealth and minimal noise."
        },
        {
          "name": "Coin pouch",
          "description": "Contains a modest amount of gold and silver, enough for immediate needs."
        },
        {
          "name": "Grappling hook and rope",
          "description": "Compact and easily concealed, useful for scaling walls."
        }
      ],
      "skills": [
        "Stealth",
        "Sleight of Hand",
        "Acrobatics",
        "Perception",
        "Investigation",
        "Deception"
      ],
      "status": "",
      "type": "npc",
      "attributes": {
        "strength": 9,
        "dexterity": 16,
        "constitution": 10,
        "intelligence": 14,
        "wisdom": 13,
        "charisma": 12
      },
      "id": "npcs-1749181492795",
      "image": "images/settings/realm-of-myr/covert-cargo/npcs/3959ac3c-b63a-4e88-9cce-6a2d69f2bc52.png?t=1749182638807"
    },
    "npcs-1749184389465": {
      "name": "Aelar Moonglimmer",
      "archetype": "Operative",
      "race": "Elf",
      "gender": "Male",
      "appearance": "Aelar Moonglimmer is a lean and agile elf with sharp, observant grey eyes that seem to miss nothing. His movements are fluid and silent, often cloaked in practical, dark attire that blends seamlessly into shadows. His silver hair is usually tied back, and his features, while refined, bear the subtle lines of one who has seen much and trusts little.",
      "personality": "Pragmatic, highly disciplined, and exceptionally discreet. Aelar rarely shows emotion, preferring to analyze situations with cold logic. He is fiercely loyal to his faction and will go to great lengths to achieve his objectives, even if it means making difficult moral choices.",
      "background": "Hailing from the hidden elven enclaves of Faelendar, Aelar was trained from a young age in the arts of espionage, infiltration, and negotiation. He belongs to a clandestine faction dedicated to preserving elven influence and securing their future in a changing world. His current mission is one of the most critical: to exchange a powerful Valkaaran artifact, whose true nature is known only to a select few, for strategic resources that will bolster Faelendar's position against emerging threats.",
      "motivation": "To secure the future and prosperity of his people in Faelendar by acquiring vital strategic assets, ensuring their continued influence and survival.",
      "behavior": "Aelar is always alert, observing his surroundings and the people within them. He speaks concisely and directly, valuing efficiency over pleasantries. During negotiations, he remains calm and composed, rarely revealing his true intentions or emotions. He is wary of strangers and trusts only those who have proven themselves.",
      "healthPercent": 100,
      "equipment": [
        {
          "name": "Shadowsilk Cloak",
          "description": "A dark, lightweight cloak woven with shadowsilk, providing excellent camouflage and muffling sound."
        },
        {
          "name": "Moon-Forged Dagger",
          "description": "A finely crafted dagger with a razor-sharp edge, designed for silent takedowns."
        },
        {
          "name": "Master Lockpicks",
          "description": "A set of intricate tools capable of bypassing complex locks."
        },
        {
          "name": "Valkaaran Artifact",
          "description": "A small, intricately carved obsidian orb pulsating with faint, ancient energy. Its true power and purpose are a closely guarded secret."
        },
        {
          "name": "Concealed Communicator",
          "description": "A small, enchanted device allowing discreet communication with his faction."
        }
      ],
      "skills": [
        "Stealth",
        "Acrobatics",
        "Perception",
        "Diplomacy",
        "Investigation",
        "Negotiation",
        "Disguise"
      ],
      "status": "",
      "type": "npc",
      "attributes": {
        "strength": 10,
        "dexterity": 18,
        "constitution": 14,
        "intelligence": 16,
        "wisdom": 15,
        "charisma": 12
      },
      "id": "npcs-1749184389465",
      "image": "images/settings/realm-of-myr/covert-cargo/npcs/e8e02409-93a9-4936-8b2e-b5a3d083889d.png?t=1749226155922"
    },
    "npcs-1749243735467": {
      "name": "Elven Archer",
      "archetype": "Archer",
      "race": "Wood Elf",
      "gender": "Female",
      "appearance": "Tall, slender elf with keen, emerald eyes that constantly scan her surroundings. Her long, braided auburn hair is often adorned with forest leaves and small feathers. She moves with a silent grace, her lithe frame suggesting both agility and endurance. Her skin is lightly tanned from years spent under the sun, and a faint scar runs along her left cheekbone, a memento from a close encounter with a monstrous beast.",
      "personality": "Stoic and disciplined, with a strong sense of responsibility. ",
      "background": "",
      "motivation": "",
      "behavior": "",
      "healthPercent": 100,
      "equipment": [
        {
          "name": "Whisperwood Longbow",
          "description": "A finely crafted longbow made from ancient Whisperwood, known for its incredible range and accuracy."
        },
        {
          "name": "Quiver of Swift Arrows",
          "description": "A quiver containing 20 meticulously fletched arrows, some tipped with special broadheads for hunting, others with enchanted tips for magical threats."
        },
        {
          "name": "Forest-Green Leather Armor",
          "description": "Lightweight, supple leather armor dyed forest-green, providing protection without hindering movement, and excellent camouflage."
        },
        {
          "name": "Elven Hunting Knife",
          "description": "A sharp, balanced knife used for skinning, carving, and close-quarters defense."
        },
        {
          "name": "Cloak of the Wilds",
          "description": "A hooded cloak woven with natural fibers, providing warmth and blending seamlessly with forest environments."
        }
      ],
      "skills": [
        "Archery (Expert)",
        "Stealth",
        "Survival",
        "Perception",
        "Tracking",
        "Nature Lore",
        "Acrobatics"
      ],
      "specialAbilities": [
        "Fey Ancestry (Advantage on saves vs. charm, cannot be put to sleep by magic)",
        "Trance (Does not require sleep, meditates for 4 hours)",
        "Forest Camouflage (Can attempt to hide even when only lightly obscured by natural phenomena)"
      ],
      "status": "",
      "type": "npc",
      "attributes": {
        "strength": 10,
        "dexterity": 18,
        "constitution": 14,
        "intelligence": 12,
        "wisdom": 16,
        "charisma": 10
      },
      "id": "npcs-1749243735467",
      "image": "images/settings/realm-of-myr/covert-cargo/npcs/66faef7d-7d77-4aac-bdec-83850e136f5f.png?t=1749243814586"
    },
    "npcs-1749243869357": {
      "name": "Elven Fighter",
      "archetype": "Fighter",
      "race": "Elf",
      "gender": "Male",
      "appearance": "Tall and lean with sharp, angular features and piercing emerald green eyes. He carries himself with a quiet confidence and a warrior's posture.",
      "personality": "",
      "background": "",
      "motivation": "",
      "behavior": "Reserved and watchful, Faelar rarely speaks unless necessary. He observes situations carefully before acting, preferring decisive, efficient movements.",
      "healthPercent": 100,
      "equipment": [
        {
          "name": "Elven Longsword",
          "description": "A finely crafted blade with a leaf-shaped guard, sharp and perfectly balanced."
        },
        {
          "name": "Reinforced Leather Armor",
          "description": "Light yet durable armor, allowing for swift movement while offering decent protection."
        },
        {
          "name": "Wooden Shield",
          "description": "A sturdy, round shield adorned with a faded elven symbol."
        },
        {
          "name": "Quiver of Arrows",
          "description": "Contains 20 standard arrows, though he primarily uses his sword."
        },
        {
          "name": "Healing Potion",
          "description": "A small vial containing a shimmering red liquid, capable of mending minor wounds."
        }
      ],
      "skills": [
        "Swordsmanship",
        "Tactics",
        "Survival",
        "Perception",
        "Stealth",
        "Archery"
      ],
      "status": "",
      "type": "npc",
      "attributes": {
        "strength": 16,
        "dexterity": 14,
        "constitution": 15,
        "intelligence": 12,
        "wisdom": 13,
        "charisma": 10
      },
      "id": "npcs-1749243869357",
      "image": "images/settings/realm-of-myr/covert-cargo/npcs/ce082298-d090-47b2-a3b9-5af7c851dec7.png?t=1749243962919"
    }
  },
  "premadePlayerCharacters": [
    {
      "name": "Lyra Silvanus",
      "archetype": "Arcanist",
      "race": "Asterian",
      "gender": "Female",
      "appearance": "Lyra has  intelligent eyes framed by spectacles perched on her nose. She has neat, dark hair, tied back to keep it out of the way while she studies. Her posture reflects her scholarly nature, and she often carries a slightly worn satchel filled with books and scrolls.",
      "personality": "Curious, studious, and deeply analytical, Lyra possesses a quiet determination. She is often lost in thought, pondering ancient mysteries, but is also genuinely kind and empathetic. While she can be a bit socially awkward at times, her passion for knowledge makes her an engaging conversationalist on her chosen subjects. She values truth and understanding above all else.",
      "background": "Lyra has insatiable curiosity, and is especially drawn to enigmatic Valkaran lore and elven culture. Despite her bookish nature, Lyra left behind the safety of Asterian academia to venture to the March of Davos, the wild lands of old Valkara and the elves of the forest.\n\nHer long hours researching drew the attention of an agent of the Blackthorn family who presented her with an opportunity for a clandestine meeting with an elf from the reclusive Faelendar settlement to verify the magical properties of an old Valkaran relic. Her curiousity piqued, she had to say yes!",
      "motivation": "Lyra is driven by a profound desire to uncover the lost secrets of Valkaran civilization and to fully understand the nuances of elven culture. She believes that by bridging the knowledge gap between these ancient peoples and her own Asterian heritage, she can unlock new forms of magic and prevent past mistakes from being repeated. Her ultimate goal is to contribute significantly to the collective knowledge of the world.",
      "behavior": "Lyra is generally quiet and observant, preferring to listen and absorb information rather than dominate conversations. When a topic of interest arises, especially concerning lore or magic, she becomes animated and eager to share her knowledge or ask probing questions. She is meticulous in her work and values accuracy above all else.",
      "healthPercent": 100,
      "equipment": [
        {
          "name": "Scholar's Robes",
          "description": "Comfortable, dark blue robes suitable for study and travel."
        },
        {
          "name": "Enchanted Quill",
          "description": "A quill that never runs out of ink and subtly glows when near ancient magic."
        },
        {
          "name": "Leather-bound Spellbook",
          "description": "A personal spellbook filled with Lyra's learned spells and research notes."
        },
        {
          "name": "Satchel of Rare Texts",
          "description": "Contains a few rare, fragile books on Valkaran history and elven linguistics."
        },
        {
          "name": "Simple Wooden Staff",
          "description": "A sturdy staff, unadorned but reliable for focus and defense."
        }
      ],
      "skills": [
        "Arcana",
        "History",
        "Investigation",
        "Linguistics",
        "Culture (Elven)",
        "Calligraphy"
      ],
      "status": "",
      "type": "pc",
      "attributes": {
        "strength": 8,
        "dexterity": 10,
        "constitution": 10,
        "intelligence": 16,
        "wisdom": 14,
        "charisma": 12
      },
      "id": "1749159962941",
      "image": "images/settings/realm-of-myr/covert-cargo/pcs/dc23c6a6-6247-4384-bccc-2eeed66a7b0c.png?t=1749161969365",
      "spells": [
        {
          "name": "Detect Magic",
          "description": "Reveals the presence and general nature of magical auras within range",
          "isUsed": false
        },
        {
          "name": "Mage Hand",
          "description": "Creates a spectral, floating hand that can manipulate an object from a distance.",
          "isUsed": false
        },
        {
          "name": "Light",
          "description": "Causes an object to shed bright light, illuminating the surrounding area.",
          "isUsed": false
        },
        {
          "name": "Ray of Frost",
          "description": "Hurls a beam of frigid cold at a creature, dealing damage and reducing its speed.",
          "isUsed": false
        },
        {
          "name": "Identify",
          "description": "Determines the specific magical properties of an item.",
          "isUsed": false
        },
        {
          "name": "Comprehend Languages",
          "description": "Allows you to understand the literal meaning of any spoken language you hear.",
          "isUsed": false
        },
        {
          "name": "Fog Cloud",
          "description": "Creates a dense sphere of fog, heavily obscuring the area and providing cover.",
          "isUsed": false
        },
        {
          "name": "Charm Person",
          "description": "Magically charms a humanoid, causing them to regard you as a friendly acquaintance.",
          "isUsed": false
        }
      ]
    },
    {
      "name": "Poppen Quickfoot",
      "archetype": "Rogue",
      "race": "Halfling",
      "gender": "Male",
      "appearance": "Standing just over three feet tall, Poppen is a bundle of restless energy. His curly chestnut hair is kept cropped close to avoid snags. He wears a patchwork waistcoat festooned with hidden pockets. His bright hazel eyes dart constantly, and his pale leather boots are scuffed from midnight footwork.",
      "personality": "Gregarious, ever‐curious, and smooth‐tongued. Poppen lives for gossip almost as much as profit. He’d rather talk his way out of a fight—or better yet, never get into one at all. He is endlessly curious, flitting from docksider to courtier in search of the next tantalizing rumor.",
      "background": "Originally from Willowdale, the tranquil halfling homeland bordering the March of Davos. Life in the Dell was too idyllic and slow-paced for Poppen’s adventurous spirit so he set out on a journey to seek his fortune elsewhere.\n\nPoppen made his way to Kordavos to make a name for himself.  He has just learned of a secret dock not far from the city for smuggling operations, and has been spying on it for several days hoping to find his first big score. ",
      "motivation": "Driven by an insatiable love for objects of great value, not just for their worth, but for the stories and prestige they carry. He aspires to become a prominent purloiner and fence to indulge this fascination while simultaneously using his social skills to mingle with interesting people, and get rich while doing it.",
      "behavior": "Poppen moves with quick, careful steps and speaks with a disarming grin, always alert for an unguarded glance or dropped word. He prefers to avoid violence by sleight of hand or a well-placed bribe, but his steel nerve means he’ll risk a bold break-in for the right payoff.",
      "healthPercent": 100,
      "equipment": [
        {
          "name": "Leather Armor"
        },
        {
          "name": "Two Daggers"
        },
        {
          "name": "Shortbow"
        },
        {
          "name": "Quiver with 20 Arrows"
        },
        {
          "name": "Thieves' Tools"
        },
        {
          "name": "Waistcoast with hidden pockets"
        },
        {
          "name": "Belt Pouch"
        },
        {
          "name": "15 Gold Pieces"
        }
      ],
      "skills": [
        "Acrobatics",
        "Deception",
        "Perception",
        "Sleight of Hand",
        "Stealth"
      ],
      "spells": [],
      "specialAbilities": [
        "Halfling Nimbleness: Can move through the space of any creature that is of a size larger than him.",
        "Lucky: When he rolls a 1 on an attack roll, ability check, or saving throw, he can reroll the die and must use the new roll.",
        "Brave: Has advantage on saving throws against being frightened.",
        "Sneak Attack: Deals extra damage when he has advantage on an attack roll or when an enemy is within 5 feet of an ally who isn't incapacitated.",
        "Cunning Action: Can take a bonus action on each of his turns in combat to take the Dash, Disengage, or Hide action."
      ],
      "status": "",
      "type": "pc",
      "attributes": {
        "strength": 10,
        "dexterity": 16,
        "constitution": 14,
        "intelligence": 12,
        "wisdom": 10,
        "charisma": 14
      },
      "id": "1749307435667",
      "image": "images/settings/realm-of-myr/covert-cargo/pcs/b44179ad-0e8e-4d1e-8b17-8c436dbeb15a.png?t=1749311061893"
    }
  ]
}

/*
  File: data/realm-of-myr.json
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/data/realm-of-myr.json
  Directory: data
*/

--- File: data/realm-of-myr.json ---

{
  "name": "Realm of Myr",
  "description": "The setting of Myr is a rich and diverse fantasy world filled with vibrant cultures, ancient civilizations, and varied landscapes, from lush forests and towering mountains to vast deserts and mysterious seas.\n\nThe world is home to humans, elves, dwarves, halflings, orcs, and more, each with their own unique societies and histories. Nations within the main continent in Myr range from wilds and townscapes of the March of Davos, to the powerful and expansionist Asterian Empire, and on to the mysterious elven realms of Evervale and the hardy dwarven kingdoms of Hammerdeep. Myr’s history is marked by the rise and fall of great empires, legendary heroes, and the influence of powerful Immortals who guide and manipulate the mortal world.",
  "genre": "Fantasy",
  "image": "images/d20/1724187594398-fantasy_rpg_setting_landscape._golden_hour._medieva_8df6369a-8279-4459-8b74-21980d9801f6.png",
  "technology": "In Myr, technology remains largely medieval, with societies relying on traditional tools, weapons, and craftsmanship, while magic often serves as a substitute for advanced machinery and innovation. On rare occasions, certain regions and cultures may experiment with blending arcane and mechanical elements",
  "magic": "Magic in Myr is an integral force, woven into the fabric of the world and accessible through intense study, innate talent, or divine favor. Arcane magic involves the manipulation of magical energies through spells and rituals, while divine magic is granted by Immortals to clerics and paladins. Magic permeates daily life in many regions, with enchanted items, teleportation, and protective wards being common among the learned, though true mastery is rare and often concentrated in the hands of powerful individuals or ancient orders. Myr also features mysterious ancient magical sites and artifacts of great power, some of which predate even the most ancient civilizations, making magic both a source of awe and danger.",
  "locations": [
    {
      "name": "March of Davos",
      "description": "The March of Davos, a wild and rugged frontier nestled in the southern regions of the continent of Thylún in the realm of Myr. This setting blends high adventure with political intrigue and ancient mystery. Davos is a land rich with ancient ruins and forgotten magic, caught between the ancient traditions of its native Valkaran population and the recent allegiance to the Asterian Empire. \n\nThe recently instated Margrave Aeron Davos rules with autonomy, but the threat of conflict with surrounding regions, both internal and external, keeps tensions high. Adventurers find themselves drawn to this land of opportunity, where fame, fortune, and hidden knowledge await those brave enough to seek them.",
      "image": "images/d20/1724278021314-fantasy_rpg_setting_landscape._detailed_illustratio_8cd6206d-f488-4d12-87e7-9e2822b67ff7.png",
      "history": "In ancient times, when the forests of Valkara stretched vast and unbroken, the city of Verodyn was founded by the first Valkaran clans. This city soon blossomed into a thriving center of culture and power, its influence reaching far beyond the borders of the fertile land. Under the rule of wise and noble kings, the Valkaran Kingdom flourished, its cities adorned with grand temples and its warriors feared across the realm. The people lived in harmony with the land, guided by their deep respect for the spirits of nature and the wisdom of their ancestors.\n\nAs the centuries passed, far to the east, the Asterian Empire rose to prominence. This powerful empire expanded swiftly, its armies and ships dominating vast territories. Yet, despite the might of Asteris, the Valkaran lands remained independent, their dense forests and mountain strongholds protecting them from invasion. However, the Valkaran people soon found themselves beset by internal strife and raiders from the northern wilds. Their once-great kingdom began to fracture, and the proud city of Verodyn became a shadow of its former glory.\n\nIt was during this time of turmoil that Margrave Aeron Davos, a noble of the Asterian Empire, traded his ancestral lands for control over the Valkaran territories. He established the March of Davos, bringing with him Asterian nobility who settled in the region. The Asterian settlers often displaced the native Valkarans, leading to growing tensions between the two peoples. The March of Davos became a land of both opportunity and conflict, its forests and mountains hiding ancient secrets that called to adventurers from across Myr.\n\nAs the years passed, these tensions reached a boiling point. Uprisings broke out, with the Valkarans seeking to reclaim their ancestral lands from the Asterian invaders. To bridge the cultural divide between the Valkarans and the Asterians, the Sunfire Order was founded. This religious order sought to unite the two peoples under a shared faith, blending the ancient Valkaran reverence for nature with the structured beliefs of the Asterian Empire. Though peace was eventually restored, it was fragile, and the land remained divided in spirit.\n\nIn the present day, the March of Davos is a land of uneasy peace. Adventurers from all corners of Myr flock to the region, drawn by the lure of the wildlands and the promise of fortune hidden within the ruins of forgotten civilizations. The Margrave rules with a firm hand, striving to maintain order and loyalty to the Asterian Empire, even as old wounds between the Valkarans and Asterians continue to fester beneath the surface.",
      "inhabitants": "",
      "organizations": []
    },
    {
      "name": "Kordavos",
      "description": "Kordavos, the capital of the March of Davos, stands as a shining beacon of civilization on the edge of the wild and untamed lands of Valkara. Nestled on the coast of the Jade Sea, it is a bustling port city where cultures, goods, and ideas from across Myr converge. The city’s location makes it a critical hub for trade between the Asterian Empire and the frontier territories, and as such, it is a place of wealth and opportunity, but also of stark contrasts and underlying tensions.\n\nKordavos is a city of contrasts—where wealth and poverty, power and weakness, civilization and wilderness all collide. It stands as a gateway to the untamed lands of Valkara, a place where the ambitions of the Asterian Empire meet the stubborn independence of the Valkaran people. For those who live there, Kordavos offers both opportunity and danger, and for those passing through, it is a city where fortunes can be made or lost in the blink of an eye.",
      "image": "images/d20/1724280044861-Bustling_medieval_city_street_at_midnight._In_the_s_264e9e90-7e9a-4aba-b164-b02e72738087.png",
      "history": "",
      "inhabitants": "",
      "organizations": [
        {
          "name": "The Church of Valkara",
          "description": "The Church of Valkara stands as a pillar of tradition and spiritual guidance for the Valkaran people, intertwining their ancient heritage with the worship of their revered Immortals. Deeply rooted in the cultural fabric of Valkara, the Church promotes values of strength, wisdom, and connection to nature, all while preserving the history of the Valkaran people. At the heart of the faith are the three Immortals—Thalor, the mighty Warrior King, Thyra, the Wayfinder of the wilds, and Dmitriev, the Guardian of the Dead—each embodying the core ideals that Valkarans hold dear.\n\nThalor the Warrior King represents the strength, courage, and leadership of the Valkaran people. Once a legendary ruler who defended his land against invaders, Thalor ascended to Immortality through his heroic deeds, and his followers seek his guidance in times of conflict. He is honored by warriors, leaders, and anyone who fights to protect the people and traditions of Valkara. His shrines are adorned with symbols of battle and bravery, and offerings to him are made before any major conflict or journey. Thalor’s legacy endures as both a protector and unifier of the Valkaran way of life.\n\nThyra the Wayfinder, the druidic mistress of the natural world, is revered for her deep connection to the land and her wisdom in guiding people through both physical and spiritual paths. She embodies the untamed spirit of Valkara’s wild places, with her followers—rangers, druids, and wanderers—dedicating their lives to protecting the balance between nature and civilization. \n\nDmitriev, the solemn Guardian of the Dead, watches over the souls of the departed, ensuring they safely pass into the afterlife. His temples serve as places of mourning and reflection, and his priests tend to the graves of the ancestors, making sure they are honored in accordance with ancient rites. Together, these three Immortals guide Valkarans through life, death, and all the trials in between.",
          "image": "images/d20/1727303487203"
        }
      ]
    },
    {
      "name": "The Valkarr Forest",
      "description": "The Valkarr Forest is a vast, ancient woodland that stretches across the eastern borders of the March of Davos, shrouding the land in deep shadows and mystery. The trees here are tall and gnarled, their thick canopies blotting out much of the sunlight even at midday. Moss-covered trunks and twisted roots snake through the undergrowth, creating a labyrinthine maze where only the most skilled woodsmen dare to venture. \n\nDeep within the Valkarr, forgotten ruins of the old Valkaran kingdom lie hidden, their crumbling stones overgrown with ivy and their secrets guarded by the ancient spirits of the woods.\n\nThe Valkarr is a place of both beauty and danger, where the line between the natural and the supernatural is thin. It is home to many creatures, both mundane and magical—elusive elves who move silently through the trees, cunning goblins who make their lairs in the dark recesses of the forest, and wild beasts that prowl the shadows, ever watchful for unwary travelers. \n\nThe forest is also said to be touched by ancient magic, with certain groves and clearings rumored to be places of power where the veil between worlds is thin. Many who enter the Valkarr seek its secrets, but not all return, for the forest is as unforgiving as it is enchanting, and those who do not respect its ancient ways may find themselves lost forever in its depths.",
      "image": "images/d20/1725315286351",
      "history": "The Valkarr Forest is a remnant of an ancient era when the Valkaran kingdom stretched across much of the land. Once, this forest was a sacred place, revered by the Valkarans as the heart of their spiritual and cultural life. The druids of old tended to its groves, and the great kings of Valkara held their most important rituals beneath its towering oaks. As the Valkaran kingdom waned, the forest became a refuge for those who resisted the encroaching forces of the Asterian Empire. \n\nOver the centuries, the Valkarr grew wild and untamed, its sacred sites abandoned and forgotten by all but the most devoted. Today, the Valkarr is a place of deep mystery and untold danger, where the echoes of its storied past still linger in the shadows, shaping the forest into the enigmatic and foreboding wilderness it is known as today.",
      "inhabitants": "The Valkarr Forest is sparsely populated, with only a few scattered settlements daring to exist within its shadowed depths. The inhabitants are a mix of druids, rangers and Valkaran descendants who have remained true to the old ways, living in small, hidden villages.\n\nVarious humanoid tribes make their homes in the deeper, more dangerous parts of the forest, where they are rumored to guard ancient treasures and perform twisted rituals.\n\nThe forest is also home to a reclusive and enigmatic elven clan known as the Lindrathil. Dwelling deep within the heart of the forest, the Lindrathil have lived in harmony with the ancient woods for countless generations, their lives intertwined with the natural magic that permeates the land. \n\nThey are guardians of the Valkarr, fiercely protective of its secrets and its ancient groves. The Lindrathil rarely interact with outsiders, preferring to remain hidden, but those who manage to gain their trust speak of a people deeply connected to the spirit of the forest, practicing ancient rituals and magic that have been passed down through the ages. Their culture is one of reverence for the land, and they view themselves as the last line of defense against the encroachment of civilization and the dark forces that threaten the Valkarr.",
      "organizations": []
    },
    {
      "name": "Hammerdeep",
      "description": "Hammerdeep is a formidable dwarven kingdom nestled deep within the Ironclad Mountains, known for its extraordinary craftsmanship and the indomitable spirit of its people. The kingdom’s heart is the Great Forge, where master smiths create legendary weapons and intricate works of art from rare metals and precious gems. The city’s architecture is a marvel of dwarven engineering, with vast halls and tunnels illuminated by glowing crystal formations that light the subterranean realm.\n\nThe culture of Hammerdeep is centered on resilience, tradition, and craftsmanship. Dwarves here take great pride in their work, with every citizen contributing to the kingdom’s prosperity through skilled labor and dedication to their clan. Though they are wary of outsiders, the dwarves of Hammerdeep honor alliances with those who prove their worth, maintaining their stronghold as a beacon of strength and endurance in the heart of the mountains.",
      "image": "images/d20/1725324581077",
      "history": "Hammerdeep was founded by the first dwarven clans under the leadership of King Durgrim Hammerdeep, who sought refuge in the Ironclad Mountains during a time of great strife. Carved from the mountain's stone, Hammerdeep grew into a formidable kingdom renowned for its masterful craftsmanship and unassailable defenses. The Great Forge, the heart of the kingdom, fueled its prosperity, making Hammerdeep the finest source of weapons and metalwork in Myr. Despite countless threats, the dwarves have remained steadfast, fiercely protecting their ancestral home and its hidden treasures.",
      "inhabitants": "",
      "organizations": []
    },
    {
  "name": "Willowdale",
    "description": "The Willowdale Dell is a serene and idyllic place of gentle rolling hills, verdant meadows, and meandering streams. It is the ancestral home of the Smallfolk, a jovial and peace-loving people known for their love of good food, hearty ale, and simple pleasures. Their homes, often called 'burrows' or 'holts,' are built directly into the soft earth of the hillsides, with round, brightly painted doors and cozy, labyrinthine interiors. The Dell is primarily agricultural, with small farms and orchards dotting the landscape, and the air is often filled with the scent of fresh-baked bread and pipeweed. While generally peaceful and isolationist, the Smallfolk of Willowdale Dell possess a quiet strength and a fierce loyalty to their way of life, especially when threatened by outsiders. They are known for their hospitality, though they prefer to keep to themselves, valuing community and tradition above all else.",
    "image": "images/settings/realm-of-myr/images/willowdale.png",
    "history": "For centuries, the Smallfolk have lived in Willowdale Dell, a legacy stretching back to when their ancestors first carved homes into the soft hills. Originally a collection of independent family 'holts,' the various clans eventually united under the informal guidance of the Council of Elders, forming a loose confederation that valued self-sufficiency and communal support. Their history is largely one of peaceful cultivation, marked by bountiful harvests and joyous festivals. They have weathered minor skirmishes with forest creatures and occasional, curious outsiders, but their remote location and unassuming nature have largely protected them from major conflicts. While the March of Davos has expanded and empires have risen and fallen across Myr, the Smallfolk of Willowdale Dell have steadfastly maintained their quiet traditions, preferring to live simply and harmoniously with the land.",
    "inhabitants": "The primary inhabitants of Willowdale Dell are the Smallfolk, a small, hearty, and good-natured people. They are known for their curly hair, often bare feet, and a profound appreciation for life's simple comforts. Most Smallfolk are farmers, brewers, or artisans, with a strong emphasis on self-sufficiency and communal sharing. They tend to be wary of 'Bigfolk' (taller races) and their complex ways, preferring the company of their own kind. Beyond the Smallfolk, the Dell is home to various docile wildlife and the occasional reclusive individual of another race who has managed to gain their trust, often by demonstrating a similar love for peace and quiet. Small, family-owned inns and taverns serve as social hubs, where stories are shared, and local news is passed around over a pint of the finest 'Root Brew'.",
    "organizations": []
    }
  ],
  "isPublic": true
}

/*
  File: data/the-march-of-davos-plan.json
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/data/the-march-of-davos-plan.json
  Directory: data
*/

--- File: data/the-march-of-davos-plan.json ---

{
  "sections": [
    {
      "title": "Arrival At Kordavos",
      "plot": "The adventurers arrive at the grand gates of Kordavos during the lively Valkaran Harvest Festival. Tension erupts between rival Valkaran clans. The new arrivals are drawn in to a heated confrontation between members of the Valtor and Blackthorn Clans. The dispute escalates rapidly, threatening to spill into a full-blown brawl and the adventurers have the opportunity to intervene.\n\nTheir actions draw the attention of various locals, each with their own agendas and desires. At the Dragonbone Inn, two representatives of the Blackthorn Clan and are presented with the opportunity to investigate a missing shipment at the docks, hinting at lucrative opportunities and favor with influential figures. \n\nThe next morning, as dawn paints the sky with hues of gold and rose, they encounter Elara, a young woman with weary eyes and an air of desperation. She pleads for their help in finding her missing brother, who vanished under mysterious circumstances while pursuing secrets that could alter the fate of Kordavos. ",
      "scenes": [
        {
          "title": "Arrival at Kordavos",
          "description": "The adventurers arrive at the grand gates of Kordavos during the lively Valkaran Harvest Festival. The atmosphere is festive, with stalls offering exotic goods, street performers entertaining the crowds, and the tantalizing aroma of local delicacies wafting through the air.",
          "encounters": [
            {
              "name": "The Gates of Kordavos",
              "narrative": "As the adventurers approach the grand gates of Kordavos, they are greeted by the sight of towering stone archways adorned with vibrant Asterian and Valkaran banners fluttering in the breeze. The sound of laughter, music, and lively chatter fills the air, signaling the ongoing festivities of the Harvest Festival just beyond the gates. \n\nHowever, before they can join the revelry, they find themselves in a long line of travelers, merchants, and villagers all waiting to be inspected by the city guard. A few guards move among the crowd, occasionally pulling aside individuals for further questioning.\n\n\"Next!\" shouts a burly Asterian guard with a stern face but kind eyes. Stepping forward, he inspects each person meticulously. \"State your business in Kordavos,\" he demands from each group. \"There is a fee of three marks for entrance.\"",
              "notes": "This is an opportunity for each player to introduce their character to the story.",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1725044729016",
              "npcs": [
                {
                  "name": "Garlan Ironfist",
                  "race": "Human",
                  "gender": "Male",
                  "characterClass": "Fighter",
                  "level": "3",
                  "appearance": "A burly man with a stern face, kind eyes, and a well-groomed beard. He wears the polished armor of the Kordavos city guard, with a blue-and-gold tabard showcasing the city's crest.",
                  "personality": "Diligent and fair, Garlan takes his duty seriously but can show kindness to those who need it.",
                  "abilities": "",
                  "characterId": "garlan-ironfist",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1725143818361"
                }
              ]
            },
            {
              "name": "The Harvest Festival",
              "narrative": "Beyond the gates, are the sights, sounds, and smells of the annual Valkaran Harvest Festival. Stalls line the streets, showcasing crafts and goods from all over Thylún. Street performers are everywhere—jugglers, acrobats, and fire-eaters—each competing for the attention of the bustling crowds. The aroma of roasted meats, sweet pastries, and spiced wines is almost intoxicating, drawing people to the food stalls.\n\n\"Come, try your luck!\" a vendor shouts, gesturing to a game of chance where players can win small trinkets and toys. Another stall features a fortune teller, Madam Zephyra, who peers into a crystal ball, her face partially concealed by a veil. \"I see great things in your future,\" she whispers to a customer with a mysterious smile.\n\nIn the center of the square, a stage has been erected where musicians play lively Valkaran tunes, and dancers invite onlookers to join in the merriment. Children dart through the crowd, laughing and playing games. The atmosphere is infectious, making it hard for anyone to resist getting caught up in the celebration.",
              "notes": "- This is an opportunity for the characters to potentially take notice of one another.\n- The adventurers can interact with various NPCs such as vendors, performers, and townsfolk, each offering unique opportunities or challenges.\n- Karim the Jewel Merchant is a well-to-do merchant who has fallen into favor with the wealthy Blackthorn family.\n- Madam Zephyra can provide cryptic hints or prophecies that may pertain to future events in the adventure.\n- Llora is a proud Valkaran. She will complain about the festival’s traditions being lost since the Asterians have come to power.\n- Merrick is related the son of Eamon, and is estranged from him, seeking to pursue artistic pursuits rather than power.",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1725044853455",
              "npcs": [
                {
                  "name": "Karim the Jewel Merchant",
                  "race": "Human",
                  "gender": "Male",
                  "characterClass": "Trader",
                  "level": "1",
                  "appearance": "A middle-aged man with a neatly trimmed beard, wearing an embroidered tunic adorned with various gemstones.",
                  "personality": "Charismatic, shrewd, always looking for the next big deal.",
                  "abilities": "Expert in Jewels",
                  "characterId": "karim-the-jewel-merchant",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1725141974945",
                  "specialAbilities": [
                    {
                      "name": "",
                      "description": ""
                    }
                  ]
                },
                {
                  "name": "Madam Zephyra",
                  "race": "Elf",
                  "gender": "Female",
                  "characterClass": "Fortune Teller",
                  "level": "1",
                  "appearance": "Tall and slender, with piercing green eyes that seem to see through one's soul, dressed in flowing, colorful robes with mystical symbols.",
                  "personality": "Mysterious, wise, speaks in riddles.",
                  "abilities": "Divination",
                  "characterId": "madam-zephyra",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1725142158675"
                },
                {
                  "name": "Finnian the Fire-Eater",
                  "race": "Halfling",
                  "gender": "Male",
                  "characterClass": "Performer",
                  "level": 2,
                  "appearance": "A small, nimble figure with a mischievous grin, wearing a leather vest and a bandana to keep his hair back.",
                  "personality": "Energetic, daring, loves to entertain and show off his skills.",
                  "abilities": "Fire-eating, acrobatics, juggling.",
                  "characterId": "finnian-the-fire-eater",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1725142650394"
                },
                {
                  "name": "Liora the Spice Merchant",
                  "race": "Human",
                  "gender": "Female",
                  "characterClass": "Trader",
                  "level": 4,
                  "appearance": "Short and stout with a braided beard and hair, dressed in earthy tones with a belt full of small, exotic spice jars.",
                  "personality": "Warm, knowledgeable, always ready to share a story or a cooking tip.",
                  "abilities": "Expertise in rare spices and herbs, skilled storyteller.",
                  "characterId": "liora-the-spice-merchant",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1725142385947"
                },
                {
                  "name": "Merrick the Musician",
                  "race": "Half-Elf",
                  "gender": "Male",
                  "characterClass": "Bard",
                  "level": "1",
                  "appearance": "Lithe and graceful, with pointed ears and long, flowing hair, carrying a lute and wearing colorful, patchwork clothing.",
                  "personality": "Charming, soulful, enjoys bringing joy to others through music.",
                  "abilities": "Playing musical instruments, singing, enchanting performances.",
                  "characterId": "merrick-the-musician",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1725142728914"
                }
              ]
            },
            {
              "name": "Clan Conflict",
              "narrative": "The festival is in full swing with music and dance. Most everyone is enjoying themselves, with the exception of two groups of people staring each other down on the outskirts of the celebration area. The atmosphere becomes tense as the crowd begins to sense the hostility, with murmurs spreading through the festival-goers.\n\n\"Your people have dishonored us for the last time!\" one leader shouts, his hand reaching for the hilt of his sword. The other leader, a tall woman with a scar across her cheek, snarls in response, \"And we won't tolerate your insults any longer!\"\n\nThe first leader, a burly man with a red-dyed beard, steps forward, his followers, all rough-looking men and women wearing mismatched armor, echoing his movements. \"We've been patient, but your arrogance knows no bounds, Larya,\" he growls, his eyes locked onto the scarred woman.\n\nLarya's group, consisting of more finely dressed individuals, some even wearing intricate jewelry, hold their ground. \"It's you and your thugs who bring chaos wherever you go, Barok,\" she retorts, her voice steady but filled with venom.\n\nThe air grows thick with tension as the onlookers inch away, creating an unintentional circle around the feuding parties. Street vendors glance around nervously while parents keep their children close, sensing the potential for violence. ",
              "notes": "The Valtor Clan, led by Larya, views the Blackthorn Clan member Barok and his followers as disrespectful intruders threatening their traditional way of life. They are offended at the presence of Asterian symbols and parade participants during the traditional Valkaran even.\n\nMeanwhile, Barok and his group, who have embraced the Asterian way of life, aligning themselves with the Blackthorn clan, see the Valtor clan as archaic and obstructive. They have been accumulating power and wealth since the Asterians’ arrival and plan to continue to do so.\n\nUnless the players intervene, the situation will escalate into a full blown fight requiring the city guard to intervene.\n\nDepending on the actions of the adventurers, they may gain or lose favor with either or both factions, impacting future events in Kordavos.",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1725127001688",
              "npcs": [
                {
                  "name": "Barok Redbeard",
                  "race": "Human",
                  "gender": "Male",
                  "characterClass": "Warrior",
                  "level": "3",
                  "appearance": "A burly man with a red-dyed beard, wearing mismatched armor that has seen many battles.",
                  "personality": "Hot-headed and prideful, with a strong sense of loyalty to his people.",
                  "abilities": "Sword fighting, intimidation, leadership",
                  "characterId": "barok-redbeard",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1725127621254"
                },
                {
                  "name": "Larya Halloway",
                  "race": "Human",
                  "gender": "Female",
                  "characterClass": "Rogue",
                  "level": "4",
                  "appearance": "A tall woman with a scar across her cheek, dressed in finely tailored clothes with hints of intricate jewelry.",
                  "personality": "Sharp-tongued and cunning, with a deep-seated need for respect and order.",
                  "abilities": "Stealth, diplomacy, dagger fighting",
                  "characterId": "larya-halloway",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1725127643282"
                }
              ]
            }
          ]
        },
        {
          "title": "Evening Falls",
          "description": "Suddenly, tension erupts between rival Valkaran clans that escalates into a brawl that turns the streets into chaos. The adventurers are forced to intervene, showcasing their combat prowess and rescuing innocent bystanders caught in the fray.",
          "encounters": [
            {
              "name": "The Dragonbone Inn",
              "narrative": "As the sun settles beyond the horizon, painting the sky in vivid hues of orange and purple, it becomes apparent that the time is approaching for securing lodging for the night. The closest tavern is The Dragonbone Inn, renowned for its eclectic mix of patrons and storied history. It promises a much-needed respite from the road.\n\nThe interior is warm and inviting, with the smell of roasting meat and the sound of a lively bard playing a jaunty tune on his lute. The tavern is filled with a diverse crowd—merchants, travelers, and a few suspicious-looking individuals huddled in dark corners. A large fireplace dominates one wall, its flickering flames casting dancing shadows across the room.\n\nThe innkeeper, a burly man named Bram, greets the adventurers with a hearty welcome and ushers them to a corner table where they can discuss their plans in relative privacy. As he sets down a tray of drinks, Bram remarks, \"Ah, the road can be a harsh mistress, can't she? You lot look like you've seen some excitement. This corner will give you a bit of peace to mull things over.\"",
              "notes": "The players can secure lodging for the night and take this opportunity to discuss the aftermath of what happened at the festival. Encourage them to gather at the tavern. (see the next encounter)",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1725037898828",
              "npcs": [
                {
                  "name": "Bram",
                  "race": "Human",
                  "gender": "Male",
                  "characterClass": "Innkeeper",
                  "level": "1",
                  "appearance": "A burly man with a thick beard and jovial eyes, wearing a simple yet sturdy apron.",
                  "personality": "Hearty and welcoming, with a knack for making everyone feel at home.",
                  "abilities": "",
                  "characterId": "bram",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726055418469"
                }
              ],
              "stages": [
                {
                  "name": "New Companions",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726102302383",
                  "narrative": "The flickering light of the fireplace dances across the new companions sip their drinks. From various corners of the room, curious eyes glance their way—some merely passing, others lingering a little too long. There is a sense that, in a place like this, secrets and opportunities walk hand in hand, waiting for those bold enough to reach out and grasp them. ",
                  "notes": "The adventurers can interact with other patrons, picking up rumors and potentially learning more about the three family clans of Kordavos. Or they can just continue their conversation until the next set of encounters at the inn.",
                  "npcs": [],
                  "stages": []
                }
              ]
            },
            {
              "name": "An Unsolicited Opportunity",
              "narrative": "As late evening falls upon the Dragonbone Inn, a popular tavern in the heart of Kordavos, the air thickens with the scent of roasted meats and the sound of mugs clinking. The Valkaran Harvest Festival's exuberance still whispers through the rafters, and the atmosphere is filled with stories and laughter. Amidst the revelry, several locals eye the adventurers with curious intent.\n\nAmong them is Beric, a burly dockworker with a scar across his face, and Eamon, a scholarly type with an aura of intelligence. Beric speaks first, his voice gruff but respectful, \"Ye seem like quite an assorted lot. We could use some folks of varied talents like you lot.\"\n\nEamon, adjusting his spectacles, adds, \"Indeed, we have matters that require the expertise of seasoned adventurers. Intricacies that only your kind might handle.\"",
              "notes": "\"It's best we discuss this privately,\" Eamon replies, his eyes darting towards the crowded room. \"Too many ears here.\"\n\nIf the adventurers agrees to a more secluded conversation, understanding the need for discretion. Beric and Eamon lead them to a quiet backroom at the rear of the inn, ready to hear their proposal.",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726093207477",
              "npcs": [
                {
                  "name": "Beric Sonacus",
                  "race": "Human",
                  "gender": "Male",
                  "characterClass": "Fighter",
                  "level": "3",
                  "appearance": "A burly man with broad shoulders, a rugged complexion, and a deep scar running diagonally across his face. His clothes are simple but sturdy, fitting for a dockworker.",
                  "personality": "Gruff but respectful, with a no-nonsense attitude. Loyal to his town and friends.",
                  "abilities": "",
                  "characterId": "beric",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726093177133"
                },
                {
                  "name": "Eamon Drakovan",
                  "race": "Half-Elf",
                  "gender": "Male",
                  "characterClass": "Wizard",
                  "level": "4",
                  "appearance": "A slender and slightly frail looking elf with sharp facial features. His spectacles give him a scholarly look..",
                  "personality": "Intelligent and curious, with a calm demeanor. Often lost in thought or poring over ancient texts.",
                  "abilities": "Arcane knowledge, spellcasting, and a deep understanding of historical and magical lore.",
                  "characterId": "eamon",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726093191207"
                }
              ],
              "stages": [
                {
                  "name": "Backroom Dealings",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726098986831",
                  "narrative": "The backroom of the Dragonbone Inn was dimly lit, the flickering glow of a single candle casting long shadows across the rough wooden walls. The smell of roasted meat and spilled ale from the tavern beyond barely reached this quiet corner. A sturdy table occupied the center of the room, with mismatched chairs pulled haphazardly around it. \n\nBeric, a broad-shouldered dockworker with a scar running down his cheek, leaned against the table with his arms crossed, his expression as hardened as the calluses on his hands. Eamon, a thin, bespectacled half-elf in fine but travel-worn robes, sat next to him.\n\n\"We've got a bit of a situation,\" Beric began getting right to the point, his voice low but gruff, like the rumble of distant thunder. \"A shipment went missin' from the docks. Valuable cargo, meant for a noble up in the Asterian quarter. Never made it to where it was supposed to. Let's just say the people I work for ain't too pleased.\" He glanced at Eamon, who cleared his throat and leaned forward, his eyes narrowing as he spoke.\n\n\"The shipment is of great importance,\" Eamon added, his voice smooth and measured. \"It's more than just goods. Among the cargo were certain... artifacts. Items that could cause quite a stir if they fall into the wrong hands. We believe a group of smugglers operating out of the lower district may be responsible. However, our hands are tied—discretion is paramount, and we need individuals with your unique talents to recover it. Quietly.\" He pushed his glasses up the bridge of his nose, his gaze steady. \"There’s coin in it for you, of course.\"",
                  "notes": "The backroom of the Dragonbone Inn is a secluded area, dimly lit and isolated from the noise of the main tavern. Keep the atmosphere tense but not hostile. Beric and Eamon are wary but genuinely need help.\n\nThe conversation should feel like a business negotiation. Beric speaks bluntly, while Eamon is more refined and calculating.\n\nBorn and raised on the docks of Kordavos, Beric grew up in the rough-and-tumble world of sailors, traders, and smugglers. A dockworker by trade, he quickly learned that the line between legal business and underhanded dealings was thin. After a brief stint as a mercenary, Beric returned to the docks, using his strength and reputation to secure a steady job moving cargo and keeping order among the workers. He has been recruited by Eamon to serve as his bodyguard.\n\nBorn to an Valkaran mother and a traveling elven ranger of the Valkarr forest, Eamon has always straddled two worlds, an outsider never fully belonging. He has been alive long enough to watch his human family, now rebranded as Blackthorn, align themselves with the Asterians. Drawn to the study of magical relics and arcane lore, Eamon has helped his human family behind-the-scenes in their rise to power and influence.\n\nHe will not reveal his allegiences, preferring to let people to believe what they will.\n\n",
                  "npcs": []
                },
                {
                  "name": "Negotiation",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726101916586",
                  "narrative": "\"Look, I ain't got hard proof, but there's been whispers down at the docks,” stated the grizzled Valkaran dockworker. \"Smugglers, most like. They’re slippery, but they ain’t ghosts. Someone’s movin’ goods that shouldn’t be moved. Could be your kind of work.\"\n\n”Discretion is crucial here,” the elder half-elf explained. “We cannot afford to draw attention, especially not with what’s involved. The fewer questions asked, the better for everyone.”",
                  "notes": "Beric and Eamon are affiliated with the Raskov Clan. Sensing the involvement of other parties, they wish to enlist an outside group who can't be traced back to them to act as agents on their behalf.\n\nBeric: Rough around the edges, but direct. He knows the docks well and has heard rumors about smuggling activity but can't prove anything.\n\nEamon: More cautious and deliberate, he hints that the artifacts in the shipment have dangerous or magical properties but will not elaborate.",
                  "npcs": [],
                  "stages": []
                }
              ]
            }
          ]
        },
        {
          "title": "Plea for Help",
          "description": "After quelling the street brawl, their actions draw the attention of various locals. Among them is Elara, a desperate woman who pleads for their help in finding her missing brother Joran, who disappeared under mysterious circumstances.",
          "encounters": [
            {
              "name": "Morning at the Dragonbone",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726111833875",
              "narrative": "As dawn breaks and pale light filters through the windows of the Dragonbone Inn, the smell of freshly baked bread and brewing coffee fills the air. The innkeeper, Bram, moves about, preparing for the day ahead.\n\nAs the new companions gather for a new day’s beginning, the door creaks open, and in steps a woman. She is visibly distraught, her face pale and tired, and her clothes slightly disheveled as if she hasn’t slept. Her eyes are red-rimmed, and there’s a nervous energy about her as she scans the room.\n\nBram immediately notices her and makes his way over with a look of concern. “Elara,” he says gently, “you’re early today. Everything alright?” His voice carries the warmth of familiarity, and it's clear they know each other well.\n\nElara gives him a faint smile, though it doesn’t reach her eyes. “I’m here to drop off those supply orders for the upper district,” she explains, pulling a small sheaf of parchment from her bag. “I promised I’d help out where I could, but…” Her voice falters, and it’s clear her mind is elsewhere.\n\nBram nods, taking the papers but not prying further. He knows the source of her distress. “Sit down for a bit, lass,” he says kindly, gesturing toward a table near the adventurers. “You’ve been running yourself ragged.”\n\nReluctantly, Elara sinks into the chair, letting out a sigh. “I’ve been trying to keep up with work… it helps keep my mind off Joran. But no matter where I go, there’s no sign of him.” Her voice trembles, and she rubs her forehead, clearly exhausted.\n\nBram exchanges a glance with the interesting group of new arrivals at his inn, before turning back to Elara. “You know, these folks here,” he says, nodding toward the group, “they seem like the kind who could handle a bit of trouble. Maybe they could help you.”\n\nElara looks up, unsure. “I don’t know… I don’t want to burden anyone,” she says softly, though her desperation is palpable.\n\nBram puts a reassuring hand on her shoulder. “It’s no burden, Elara. Joran’s been missing too long, and you know I’ve always looked after the both of you, ever since your father’s troubles. These folks might be able to help where others have failed. I’d trust them with this.”\n\nElara hesitates, then nods. “If you think they can help, Bram... I don’t know where else to turn.”\n\nBram offers her a comforting smile. “If anyone can, it’s them.”",
              "notes": "Elara works part-time handling supply logistics for several businesses in the city, including local traders and inns, helping organize shipments and deliveries. She is caretaker for her mother, who has taken ill after the mysterious passing of her father.\n\nBram has known her for a long time and wants to get her the help she needs. He will be fairly insistent they aid her.\n\n“Listen,” he says, his voice taking on a more serious tone. “You’re not the usual crowd—seems to me you’ve got more in you than just passing through.”\n\nIf pressed, will even offer to let them stay for free if they as long as they help her.\n\n“Help Elara, and you can stay here at the Dragonbone, free of charge, for as long as it takes to find her brother.”",
              "npcs": [
                {
                  "name": "Elara Antonov",
                  "race": "Human",
                  "gender": "Female",
                  "characterClass": "Commoner",
                  "level": "1",
                  "appearance": "Young woman with pale skin, tired eyes that are red-rimmed, disheveled clothes, and an overall appearance of exhaustion.",
                  "personality": "Distraught, determined, and responsible. Has a deep sense of duty to her community and the people she cares about.",
                  "abilities": "Swift, knowledgeable about the town and surrounding areas, proficient in delivering messages and completing errands.",
                  "characterId": "elara",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726111995012"
                }
              ],
              "stages": [
                {
                  "name": "The Missing Brother",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726113544828",
                  "narrative": "Elara shifts uncomfortably in her seat. After a long pause, she exhales slowly, as if summoning the strength to explain.\n\n“My brother, Joran,” she begins, her voice barely above a whisper, “he’s always been one to chase after dangerous truths. After… after our father’s death, he became obsessed with uncovering why. He believed there was something more.” \n\nShe clasps her hands together, her knuckles white from the tension. “A few weeks ago, he came to me with... strange news. He’d uncovered information about an artifact. He said it could change everything for our people. But I didn’t understand. He wouldn’t tell me everything. He just said he was close to finding it.”\n\nElara’s voice catches, and she swallows hard before continuing. “Then, one night, he vanished. No note, no explanation. He just disappeared. I’ve searched everywhere, asked anyone who might have seen him, but no one knows where he’s gone.”\n\nShe looks down at the table, her voice filled with guilt. “The last time I spoke to him, I told him to stop chasing these dangerous ideas. That he was risking too much. Now I don’t even know if he’s alive.”",
                  "notes": "If the party agrees to help, Elara’s eyes fill with a glimmer of hope. “Thank you,” she whispers. “I don’t know how I can repay you, but… thank you.”\n\nBram nods approvingly, his voice soft but firm. “You’re doing the right thing, Elara. And you’re in good hands now.”\n\nElara offers a faint, grateful smile, though the worry in her eyes remains. “I just hope it’s not too late.”",
                  "npcs": [],
                  "stages": []
                },
                {
                  "name": "Clues",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726176619441",
                  "narrative": "“The last place Joran mentioned going was the Silver Serpent, down by the docks,” she begins, her eyes darting between the adventurers. “It’s not the kind of place I’d ever want to go, but Joran... apparently he had dealings there of some kind.”\n\nShe hesitates, then sighs. “I tried going there myself, just after Joran vanished. But... the moment I stepped inside, they took one look at me and escorted me out. No one would talk to me, not a word. They know something. I could see it in their eyes.”\n\nHer hands move to a small leather scrollcase at her side. She grips it tightly for a moment, as if gathering the courage to continue. “There’s one more thing,” she adds, her voice dropping to a whisper. Slowly, she places the case on the table in front of the adventurers.\n\n“This belonged to Joran,” she says softly. “He spent a lot of time in the library, searching for answers about our father, Milos, and his research. These are his sketches and notes that he left behind. They’re written in some sort of code.”\n\nWith delicate fingers, Elara opens the case and carefully pulls out several sheets of parchment. The pages are filled with intricate sketches of symbols, maps, and notes in meticulous coded handwriting. \n\n“I haven’t been able to figure out what any of this means,” she admits, spreading the pages across the table.",
                  "notes": "If the characters roll successfully, they can determine that many of the symbols are ancient Valkaran runes, while others appear to be arcane in nature. If a magic user has a successful roll, they can infer that the symbology is related to spells of transmutaion and abjuration. Initially, they may be able to detect repeated references to a “key” that is apparently an old Valkaran relic of some importance. If the characters are especially perceptive or have elves amongst them, they can detect that some of the symbology is Elvish in origin.\n\nJoran and Elara’s father Milos was well-respected in Valkaran society, known for his scholarly contributions to preserving Valkaran culture. His work became dangerous when he uncovered information about ancient artifacts tied to Valkaran history. His studies drew the attention of powerful forces within the March of Davos which led to his life being abruptly ended under mysterious circumstances. The tragedy left their mother grief-stricken, and she fell seriously ill, now requiring constant care from Elara when she isn't busy trying to earn enough money to afford rent.\n\nJoran Antonov, a historian and political activist himself, had devoted his life to understanding and preserving Valkaran history. After his father’s untimely death, Joran was obsessed uncovering the truth. He learned that his father had discovered the whereabouts of a powerful ancient artifact from the long gone glory days of old Valkara.",
                  "npcs": [],
                  "stages": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "The Investigation",
      "plot": "As we begin part two, the party should have several avenues of investigation to pursue.\n\nJoran’s drawings and notes provided by his sister Elara reveal more about the ancient Valkaran secrets he and his father Milos had uncovered. When the adventurers visit the Grand Library of Kordavos connected to the Church of Valkara, their research reveals the younger and elder Antonovs were both after an artifact, some sort of key. \n\nOf course, the adventurers are all being watched by the three powerful clans. At an opportune time, the Covenant of the Cowl ambushes the characters in an attempt to steal Joran’s papers. The adventurers now have another mystery—who are the Covenant of the Cowl and what are they after?\n\nInvestigating the Silver Serpent Tavern will lead to finding out more about Joran’s contacts and the mysterious meeting he had before disappearing. The Silver Serpent is a dingy, shadowy establishment nestled among the dock warehouses. Sailors, smugglers, and other shady figures make up the clientele. When the adventurers inquire about Joran or the shipment, they are met with cold stares or subtle attempts to avoid the topic.\n\nIf the adventurers press further, either by offering coin, leveraging intimidation, or impressing a local patron, they’ll hear that Joran was seen meeting with a smuggler known as Silverhand in the lower district. He operates in an area known only as the Black Market.\n\nThe missing shipment is connected to smuggling operations in the Lower District and the docks. Dockworkers, wary of outsiders, are reluctant to talk. An old dockhand named Finn might eventually share that the shipment in question was being closely watched by figures linked to the Blackthorn Clan.\n\nThey can discover that the origin of the shipment was from Lindrathil, the main elven settlement nestled deep within the Valkarr forest. It was a highly unusual origin point for a shipment, but surprisingly there have been a number of shipments from there recently, all to be received by the Blackthorn family. In fact, there is quite a large shipment that just arrived today.\n\nWhen the adventurers go to inspect this shipment, they will find that it held a wild Forest Drake captured by the elves of the Valkarr. Suddenly, it escapes its cage and attacks the dockworkers. It was being delivered to be a special surprise at the Blackthorn’s upcoming Masquerade Ball.\n\nLady Astrid Blackthorn, a ranger and skilled beastmaster, emerges from the boat to attempt to help quell the beast. The Forest Drake was to be a centerpiece for the upcoming Blackthorn Masquerade Ball. She personally oversaw the care of the Drake during the journey, ensuring it was treated humanely.\n\nAfter the beast is dealt with, it will be discovered that someone had sabotaged the ship to orchestrate the Drake's escape and steal valuable elven goods from the shipment. Astrid assumes it is the work of the Raskov clan, with Silverhand being the prime suspect. In actuality though, the sabotage and theft have been orchestrated by the Covenant. \n\nIf asked about the missing shipment, Astrid will be evasive and not mention the Key of Ilmarin. The Blackthorn family is using their resources to track down the thieves. \n\nAs a reward for helping, Astrid will invite the party to the Masquerade Ball.",
      "scenes": [
        {
          "title": "The Library",
          "description": "The adventurers visit the Grand Library of Kordavos, a majestic structure connected to the Church of Valkara. They sift through ancient tomes and scrolls, uncovering the significance of the artifact known as the Key of Ilmarin. The library is filled with the scent of old books, and the air is tinged with an aura of mysticism. As they delve deeper, they feel eyes upon them, shadowy figures keeping tabs on their every move.",
          "encounters": [
            {
              "name": "The Old Grand Library",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726275316858",
              "narrative": "The Old Grand Library stands as a beacon of knowledge in the rugged frontier of the March of Davos. Connected to the nearby Church of Valkara, the library is an ancient building characterized by its grand structure: arched ceilings, intricate stained-glass windows depicting the deeds of Valkaran saints, and ivy-lined stone walls. \n\nInside, towering bookshelves filled with rare and mystical texts stretch up toward the lofty ceiling, while secluded reading alcoves offer quiet sanctuaries for study. Cobblestone floors echo with the footsteps of countless seekers of knowledge over the centuries, and a faint scent of old parchment and burning candles fills the air. \n\nA robed woman steps gracefully from the shadows of a nearby alcove, her presence calm yet commanding. Her long, dark hair is braided intricately, and the soft glow of candlelight reflects off the silver pendant she wears—a delicate symbol of a tree intertwined with the moon, marking her as a follower of Thyra. She approaches the adventurers with a serene smile, her eyes warm with understanding.\n\n\"Welcome to the Grand Library,\" she says softly, her voice carrying a soothing authority. \"I am Sister Danica, a cleric of Thyra, the Wayfinder. You appear as travelers in search of something beyond the ordinary. If there is knowledge you seek, I would be honored to assist you on your path.\"\n\nShe gestures toward a nearby table, inviting them to speak further. \"The library holds many secrets—some ancient, some untamed. Let us explore the answers together.\"",
              "notes": "Sister Danica will assist the characters in their research but she is also watching them. She will be reporting their actions to her superiors.\n\nIf the party reveals the purpose of their investigation, Sister Danica will recommend they look in the private archives. Only one person is allowed at a time.\n\nIf asked about Joran, she will respond, “Joran Antonov? I have heard his name whispered among scholars and seekers alike. He was a passionate soul, always in search of the truth, especially about his father’s work. It is unfortunate he has gone missing. The library holds no recent records of him, but I do hope you find him safe.”",
              "npcs": [
                {
                  "name": "Sister Danica",
                  "race": "Human",
                  "gender": "Female",
                  "characterClass": "Cleric",
                  "level": "2",
                  "appearance": "A robed woman with long, dark hair braided intricately. Wears a silver pendant with a symbol of a tree intertwined with the moon, marking her as a follower of Thyra.",
                  "personality": "Calm, serene, commanding, understanding.",
                  "abilities": "Healing spells, knowledge of ancient texts, spiritual guidance, light manipulation.",
                  "characterId": "sister-danica",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726275370282"
                }
              ],
              "stages": [
                {
                  "name": "The Private Archives",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726280666856",
                  "narrative": "In the quiet corridors of the Grand Library, Sister Danica leads the adventurers down a winding staircase, away from the main hall and toward a smaller, hidden chamber. The air grows cooler and more still as they descend, the flickering torchlight casting elongated shadows on the stone walls. Finally, they reach a thick wooden door adorned with intricate carvings of leaves and stars—the symbol of Thyra woven into its design.\n\n\"This,\" Danica says, her voice dropping to a whisper, \"is the private archives. Only one individual may access this room at a time, a tradition maintained to safeguard the knowledge within. What you seek may be found here, but be prepared—the scrolls and tomes inside are not for the faint-hearted. They contain truths that can change the course of history.\"\n\nShe steps back, her hand resting on the iron handle. \"Who among you will enter? Choose carefully, for what you find here could shift the balance of power in ways unforeseen.\" The quiet hum of enchantments lingers in the air, a faint reminder that this room holds more than just ancient texts—it guards forgotten secrets that only the brave dare uncover.",
                  "notes": "",
                  "npcs": [],
                  "stages": []
                },
                {
                  "name": "The Archivist",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726281576383",
                  "narrative": "The air inside within the private archive is cool and still, thick with the scent of parchment and leather-bound tomes that have endured for centuries. Dim light filters through narrow stained-glass windows, casting colored patterns onto the floor made of worn stone. Towering bookshelves line the walls, filled with scrolls, manuscripts, and relics of the past.\n\nIn the center of the room stands an ancient reading table, where a few scattered documents lay, seemingly awaiting inspection. Along one side, a locked glass cabinet holds rare texts and artifacts, some gleaming faintly in the half-light.\n\nFrom the shadows emerges an elderly man, the Archivist, his pale face framed by thin gray hair. He wears simple robes adorned with the symbol of Valkara, and a pair of spectacles hangs loosely around his neck. His keen eyes scan the adventurer, assessing their presence, before a small smile curls at his lips.\n\n\"Ah, welcome,\" he says, his voice low and steady, though there's an air of caution behind his tone. \"You must be one of those seeking the lost knowledge of Valkara.\" He steps closer, his hands clasped behind his back as he gestures to the shelves around them. \"There is much here that can enlighten, but some truths… well, some truths carry danger.\"\n\nHe leans in slightly, lowering his voice. \"Word has it you’re asking questions. Dangerous questions about the recent troubles in Kordavos.\" His eyes flicker knowingly. \"Be careful where you tread.\"\n\nThe archivist moves to the far corner, retrieving a set of scrolls and carefully placing them on the table. \"These records… well, they aren’t easy to come by. They speak of dealings of old—agreements made in secret.\" He pauses, casting a glance toward the locked cabinet. \"It would be wise to tread cautiously, friend. Many have vanished for much less.\"\n\nHe steps back, giving the adventurer a moment to absorb his words, leaving behind an aura of mystery and suspicion. \"Should you need guidance, I am here. But remember—some knowledge is best left undisturbed.\"",
                  "notes": "The archived documents provided are historical records of a Drakovan family that operated as a prominent noble house holding significant influence over local trade and military affairs, often using alliances and shrewd diplomacy to expand their power. The records suggest a history of betrayals and manipulation, where the Drakovans undermined rival Valkaran houses to grow their influence at all cost.\n\nThe last of the records reveal that the Drakovan family rebranded itself as the House Blackthorn just in advance of Asterian involvement in the region.\n\nIf asked about Joran, the archivist will be evasive. “Joran… yes, he was here. His research into the old Valkaran ways brought him too close to things better left buried. His obsession with his father’s work led him down a dangerous path. If I may offer some advice, tread carefully if you wish to follow where he has gone.”",
                  "npcs": [
                    {
                      "name": "Eldrin Varokich",
                      "race": "Human",
                      "gender": "Male",
                      "characterClass": "Archivist",
                      "level": "8",
                      "appearance": "An elderly man with a pale face, thin gray hair, and simple robes adorned with the symbol of Valkara. Spectacles hang loosely around his neck.",
                      "personality": "Cautious, wise, and enigmatic. He speaks with a low and steady voice, often hinting at secrets and dangers.",
                      "abilities": "Expert knowledge in ancient texts, secret lore, and dangerous truths.",
                      "characterId": "eldrin-varith",
                      "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726285595566"
                    }
                  ],
                  "stages": []
                }
              ]
            }
          ]
        },
        {
          "title": "The Silver Serpent Tavern",
          "description": "The adventurers make their way to the Silver Serpent Tavern, a dimly lit, grimy establishment frequented by sailors, smugglers, and other shady figures. The atmosphere is tense, filled with the smell of salty air and unwashed bodies. They approach the grizzled bartender, Harron, seeking information about Joran. Initially met with cold stares and resistance, they must leverage their skills to extract valuable information about Joran’s last known contacts.",
          "encounters": [
            {
              "name": "The Silver Serpent Tavern",
              "narrative": "The adventurers step into the dimly lit Silver Serpent Tavern, the air thick with the smell of salty seawater and unwashed bodies. The floor is sticky underfoot and the murmur of hushed conversations is occasionally punctuated by drunken laughter or the clinking of glasses. The tavern is filled with sailors, smugglers and other assorted nefarious individuals. A large map of the sea is carved into one wall, and an impressive collection of nautical memorabilia lines the shelves behind the bar.",
              "notes": "Regardless of who the adventurers talk to, everyone in the establishment will be reluctant to talk",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726289298448",
              "npcs": [],
              "stages": [
                {
                  "name": "The Bartender",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726291468584",
                  "narrative": "Behind the bar, a grizzled man with deep-set eyes and a scar running down his cheek methodically wipes down glasses. His gaze is sharp, missing nothing despite his slow, deliberate movements. He looks up as the adventurers approach, his expression unreadable but not unfriendly.\n\n\"What’ll it be?\" he asks, his voice rough like gravel. It’s clear from his demeanor that he’s no stranger to those seeking more than just a drink at the Silver Serpent.",
                  "notes": "The bartender is a grizzled man named Harron, might provide minimal information at first—something vague about how “people who ask too many questions here tend to disappear.” If the adventurers press further, either by offering coin or leveraging intimidation/persuasion, they’ll hear that Joran was seen meeting with a smuggler known as Silverhand in the lower district. He operates in an area known only as the Black Market.\n\n“Now ye best move along. There be eyes and everywhere.,” he warns ominously.\n",
                  "npcs": [],
                  "stages": []
                },
                {
                  "name": "The Dockworkers",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726292403106",
                  "narrative": "The Silver Serpent’s dimly lit common room hums with quiet conversation as a few groups of dockworkers sit hunched over mugs of ale at wooden tables. Their rough, weather-beaten faces and calloused hands speak of hard labor on the docks, and their eyes are sharp, ever watchful of their surroundings. As the adventurers approach, a few heads turn, and the quiet chatter softens to murmurs.\n\nOne of the men, a burly figure with a patchy beard and arms thick with muscle, leans back in his chair and takes a long swig of his drink before locking eyes with the newcomers. He exchanges a glance with his companions, who continue to drink in silence, their expressions guarded.\n\n“What’s your business here, strangers?” he finally asks, his voice gruff and tinged with suspicion. His tone makes it clear that outsiders don’t usually mingle with the regulars here, and any intrusion will need to be handled carefully.",
                  "notes": "If the adventurers press further, either by offering coin or leveraging intimidation/persuasion, they’ll hear about Silverhand, a prominent operator in the lower district, in an area known only as the Black Market.\n\n“If ye have any sense, ye best be moving along now. There be eyes and everywhere.,” he warns ominously.",
                  "npcs": [],
                  "stages": []
                }
              ]
            }
          ]
        },
        {
          "title": "The Docks",
          "description": "The adventurers arrive at the bustling docks, finding it difficult to gain information from the wary dockworkers. Persistence pays off as an old dockhand named Finn reveals that the shipment in question originated from Lindrathil and was being closely observed by figures linked to the Blackthorn Clan. This unexpected lead sends the adventurers further into the web of intrigue involving powerful families and ancient secrets.",
          "encounters": [
            {
              "name": "Arrival at the Docks",
              "narrative": "The sun casts a golden hue over the bustling docks of Kordavos as the adventurers arrive. The air is filled with the tang of saltwater, mingled with the earthy scent of freshly unloaded cargo. Towering ships bob gently in their berths, and from every corner, dockworkers laden with crates and barrels shout directions to one another, their voices lost in the cacophony of seagulls and the crashing of waves against the piers.\n\nAhead, a group of dockworkers pause their work, their sweat-streaked faces turning toward the adventurers with curiosity. One man, a grizzled veteran of the docks with a sun-worn face, sets down a crate and wipes his brow, eyeing the newcomers cautiously. ",
              "notes": "Dockworkers, wary of outsiders, are reluctant to talk. An old dockhand named Finn might eventually share that the shipment in question was being closely watched by figures linked to the Blackthorn Clan.\n\nThey can discover that the origin of the shipment was Lindrathil, the main elven settlement nestled deep within the Valkarr forest. It was a highly unusual origin point for a shipment, but surprisingly there have been a number of shipments from there recently, all to be received by the Blackthorn family. In fact, there is quite a large shipment that just arrived today.",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726345480155",
              "npcs": [
                {
                  "name": "Finn Radonik",
                  "race": "Human",
                  "gender": "Male",
                  "characterClass": "Fighter",
                  "level": "1",
                  "appearance": "Old and weathered dockhand",
                  "personality": "Gruff but fair. He’s a hard worker and expects the same from others. Deeply loyal to his friends.",
                  "abilities": "",
                  "characterId": "loric-windrider",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726344098147"
                },
                {
                  "name": "Tor Marros",
                  "characterId": "",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726344982001",
                  "race": "Human",
                  "characterClass": "Fighter",
                  "gender": "Male",
                  "appearance": "A towering figure in his early forties, Tor is bald and heavily muscled, standing well over six feet tall. His arms are covered in crude tattoos of animals and mythical creatures, and he wears a sleeveless tunic to show them off. His thick neck and powerful build give him the nickname \"The Bull.\" He has a deep, gravelly voice that rumbles when he speaks.",
                  "level": "2",
                  "abilities": "Very strong",
                  "class": "Despite his intimidating appearance, Tor is calm and methodical in his work. He’s known for settling disputes at the docks with his sheer presence, preferring to use his strength only when absolutely necessary."
                },
                {
                  "name": "Petra Velan",
                  "characterId": "",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726344936638",
                  "appearance": "A woman in her mid-forties with short, steel-gray hair tied back in a ponytail. Petra walks with a noticeable limp, the result of a ship’s accident years ago, and wears a metal brace on her right leg. She dresses practically in heavy work boots, a leather apron, and a patched shirt, often seen puffing on a pipe. Her tanned skin and muscular build speak to years of hard work.",
                  "race": "Human",
                  "characterClass": "Commoner",
                  "gender": "Female",
                  "level": "1",
                  "class": "Tough but fair, Petra is respected as a leader among the dockworkers. She’s efficient and direct, with little patience for nonsense, and is known for her quick decisions and no-nonsense attitude."
                }
              ]
            },
            {
              "name": "Mystery Cargo",
              "narrative": "Following Finn’s revelations, the adventurers decide to investigate the area where the shipment was last seen. The docks are a labyrinth of warehouses, narrow alleyways, and hidden corners. As they make their way to an inconspicuous storage shed tucked away behind larger warehouses, they notice furtive movements in the shadows.\n\nA group of suspicious figures lurks near the entrance, attempting to blend in with the workers but clearly out of place. One of them, a tall figure with a scarred face, spots the adventurers and signals to his companions. Realizing they’ve been made, the adventurers prepare for a confrontation.\n\n\"Who’re you lot?\" the scarred figure demands, stepping forward, hand resting on the hilt of a knife. \"Ain’t nothing here for the likes of you. Best be on your way.\"",
              "notes": "The scarred figure is a minion of the Blackthorn Clan and sent to oversee the shipment, unaware of the adventurer's involvement until now. The map is crucial for directing the next steps in the investigation. DMs should use the warehouse skirmish to emphasize the immediate physical danger while the map revelation steers the plot toward uncovering the Blackthorns’ operations.",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726351294262",
              "npcs": [
                {
                  "name": "Alaric Fleyven",
                  "race": "Human",
                  "gender": "Male",
                  "characterClass": "Rogue",
                  "level": "2",
                  "appearance": "Tall and lean with a deeply scarred face, jet-black hair tied back in a ponytail, and piercing blue eyes.",
                  "personality": "Cautious and untrusting, fiercely protective of his crew and territory, has a sharp tongue and quick wit.",
                  "abilities": "Expert in stealth, pickpocketing, and knife fighting.",
                  "characterId": "scarface-alaric",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726346336662"
                }
              ]
            },
            {
              "name": "The Beast Escapes",
              "narrative": "A sudden, loud crash echoes from a nearby ship docked in the harbor. The ship rocks violently, and startled cries fill the air as dockworkers scramble to secure the ship’s lines. A deep, guttural roar reverberates from the cargo hold, followed by the creaking of wood under pressure.\n\nThe thick wooden doors of the hold explode outward, splintering as a massive creature emerges—a Forest Drake. Its scales shimmer in shades of green and brown, blending with the earthy tones of the ship’s hold. Its glowing yellow eyes dart wildly, wings stretching wide as it lets out a deafening roar. Panic sweeps the docks as workers scatter, some diving for cover while others shout warnings to those unaware of the danger.\n\nAt the edge of the gangplank, a woman stands with fierce determination. She’s tall, clad in rugged leather armor, her sharp features framed by windblown hair streaked with the earthy tones of the wild. A bow is slung across her back, and her hand rests on the hilt of a curved blade at her side. Her piercing gaze sweeps the chaos before her as she rushes forward, commanding the crew with authority. “Keep it contained! Don’t let it reach the harbor!” she shouts, her voice sharp and clear amidst the rising panic.",
              "notes": "Finn’s additional information provides critical context for the next phase of the investigation. The Key of Ilmarin is a pivotal reveal, escalating the urgency and stakes of the quest. DMs should highlight Finn’s cautious yet helpful nature, ensuring he becomes a trusted contact while underscoring the omnipresent threat of Blackthorn surveillance.",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726354341751",
              "npcs": [
                {
                  "name": "Astrid Blackthorn",
                  "characterId": "",
                  "image": "/images/app/avatar/npc.png?v=1",
                  "race": "Human",
                  "characterClass": "Ranger",
                  "gender": "Female",
                  "level": "6",
                  "appearance": "Tall, clad in rugged leather armor, sharp features, wild windblown black hair. Intense eyes."
                }
              ]
            },
            {
              "name": "The Aftermath",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726360716968",
              "narrative": "As the dust settles and the echoes of the battle fade, the docks are left in disarray. Crates and barrels lay shattered across the ground, and a few torn sails flap lazily in the breeze. The scent of saltwater and crushed wood mingles in the air. Dockworkers slowly emerge from their hiding spots, cautiously surveying the damage.\n\nOne of the dockworkers approaches, his face pale and shaken. \"Never seen anything like it,\" he mutters, his voice trembling. \"Could’ve been a lot worse if it weren't for you lot.\"\n\nHer posture now regained with poise and confidence, the impressive woman ranger approaches the adventurers. Her forest-green eyes flicker with a mixture of gratitude and calculation. She wipes the grime from her face, tucking a loose strand of hair behind her ear.\n\n“Indeed,” she says echoing the dockworker, “I am Lady Astrid Blackthorn and it seems I am in your debt. Well met.”\n\nBefore anything else can can be said, a tall, broad-shouldered woman with short-cropped hair and a face hardened by years at sea whistles from the ship, standing next to the shattered cage that had once held the Forest Drake.\n\n“Sabotage!” she calls out, kneeling down to inspect the remnants of the cage. She motions for Astrid and the adventurers to join her. \n\n“Look here,” she says, pointing to the mangled steel bars. “These hinges weren’t forced from the inside—someone tampered with them. The lock mechanism’s been melted. Someone used acid, enough to eat through the steel, but slow enough not to raise suspicion until it was too late.”\n\nShe stands, brushing her hands off on her armor, her expression grim. “They knew exactly what they were doing. Whoever it was, they waited for the perfect moment—right when we docked—to unleash the drake. It wasn’t an accident.”\n\nAstrid’s eyes narrow, her lips pressed into a tight line. The implications hang heavy in the air, and it’s clear that this was no simple mistake.\n",
              "notes": "If the players have not already received the clue to look into Silverhand at the Black Market, they should get it now.",
              "npcs": []
            },
            {
              "name": "An Invitation",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726361535587",
              "narrative": "Astrid’s forest-green eyes flicker with a mixture of gratitude and calculation. She wipes the grime from her face, tucking a loose strand of hair behind her ear. \n\n\"You’ve done us a great service today,\" she says, her voice steady but carrying the weight of sincerity. \"Few could have handled a Forest Drake on the loose with such skill.\" She looks over the adventurers with clear respect in her gaze. \"You’ve proven yourselves more capable than most.\"\n\nShe pauses, glancing toward the scattered dockworkers, then back to the adventurers. \"The Blackthorn family doesn’t forget those who help us.\" She reaches into her belt pouch and pulls out a small, intricately designed invitation sealed with black wax bearing the Blackthorn crest. \n\n\"I’d like to extend a formal invitation to our Masquerade Ball. It’s an event for the elite of Kordavos, but after what you’ve done, it’s only right you be among us. The ball is this very week, held at our family estate. You’ll have a chance to meet important people—ones who can make a difference.\"\n\nAstrid hands the invitation to the nearest adventurer, her tone shifting slightly, more serious now. \"Come as our honored guests, but also know this: I may need people like you again. And those who stand with the Blackthorns often find themselves in powerful positions.\" She gives a nod of respect before stepping back, her eyes lingering on the adventurers for a moment longer before she turns to oversee the aftermath.",
              "notes": "",
              "npcs": []
            }
          ]
        }
      ]
    },
    {
      "title": "The Black Market",
      "scenes": [
        {
          "title": "The Lower Districts",
          "description": "The adventurers step into the Lower District's tangled streets, noting the sharp contrast from the orderly North End. Cramped alleyways and dimly lit paths create an air of suspense as they navigate through the labyrinthine environment. Every corner and hidden nook seem to whisper stories of long-forgotten secrets and illicit dealings. The air is thick with the scent of spices and an undercurrent of danger.",
          "encounters": [
            {
              "name": "Welcome to the Lower Districts",
              "narrative": "The streets of Kordavos shift dramatically in the transition from the bustling energy of the docks into the shadowy, labyrinthine alleys of the Lower District. The atmosphere grows heavier, the air tinged with a faint staleness as if the sun rarely finds its way between the narrow, leaning buildings. The sounds of laughter and commerce that filled the upper city fade, replaced by the occasional clatter of distant footsteps, the low hum of whispered conversations, and the creak of doors that are quickly closed as passersby hurry through the dim-lit streets.\n\nThe Lower District is a different world—where the wealthy rarely tread and where secrets are traded like coin. Dilapidated tenements loom on either side, their windows dark and lifeless, while crooked alleyways twist in every direction like a maze designed to disorient even the most seasoned traveler. The streets are uneven, slick with refuse, and the occasional flicker of torchlight from distant corners does little to pierce the gloom.",
              "notes": "",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726428910497",
              "npcs": []
            },
            {
              "name": "Beset by Street Urchins",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726439333709",
              "narrative": "The winding streets of the Lower District are teeming with life, a chaotic mix of hurried vendors, wandering townsfolk, and shady figures lurking in the shadows. The air is thick with the scent of smoke from nearby chimneys, and the distant clatter of market stalls blends with the constant hum of conversation. \n\nPeople jostle past one another, their faces hidden beneath hoods or wide-brimmed hats, their steps quick as they navigate the crowded, narrow alleys. Children dart between adults, chasing each other or carrying small parcels, while street performers play haunting melodies on worn instruments.\n\nIn the midst of it all, a group of halfling urchins moves unnoticed, weaving through the crowd with practiced ease. A small, wide-eyed halfling with messy brown hair rushes through, laughing mischievously as he slips between legs. A red-haired halfling with dirt-smudged cheeks skips and bounces as she bumps into people along the narrow street. More halflings trail behind, exchanging jokes and giggling, blending seamlessly into the bustling flow of the district.",
              "notes": "If the characters pass a perception test, they can discern that the halflings are up to something. \n\nRoll for success for the red-headed halfling to pickpocket the scroll case from whoever is carrying it. If they don't have the scroll case with them, then they will target a different valuable item or whoever appears the most wealthy in the group.\n\nIf chased, the halflings will dash into a narrow alley, their laughter echoing off the walls. Crates and barrels are knocked over in their wake as they try to slow down their pursuers. The halflings split up, vanishing into different side streets.\n\nIf they are successful in getting away with the scroll case, it will find its way to Silverhand who will use it as a bargaining chip with the Covenant.",
              "npcs": [
                {
                  "name": "Finn Swiftfoot",
                  "race": "Halfling",
                  "gender": "Male",
                  "characterClass": "Rogue",
                  "level": 2,
                  "appearance": "Small, wide-eyed, with messy brown hair and a mischievous grin",
                  "personality": "Cheerful and cunning, always looking for a quick escape or opportunity",
                  "abilities": "Expert in pickpocketing, stealth, and evasion",
                  "characterId": "finn-swiftfoot",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726439716482"
                },
                {
                  "name": "Mara Redleaf",
                  "race": "Halfling",
                  "gender": "Female",
                  "characterClass": "Bard",
                  "level": 2,
                  "appearance": "Red-haired with dirt-smudged cheeks and a constant skip in her step",
                  "personality": "Playful and charismatic, known for her infectious laughter and musical talent",
                  "abilities": "Skilled in playing instruments, performing, and charming individuals with her songs",
                  "characterId": "mara-redleaf",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726439437517"
                }
              ]
            },
            {
              "name": "Finding the Black Market",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726450092972",
              "narrative": "Deeper into the Lower District, the streets seem to tighten and close in even tighter. The rickety buildings seem to lean overhead, casting long shadows in the fading light. The smell of damp stone and stagnant water fills the air. The sounds of the bustling city fade away, replaced by hushed conversations, the shuffle of cloaks, and the occasional glance from shadowy figures.",
              "notes": "Roll for perception, one of the adventurers might notice something unusual—small, subtle symbols carved into the stone walls and wooden beams. A snake intertwined with a crescent moon. A crooked dagger etched faintly above a doorway. These are no mere graffiti; they are markers, covert signs left to guide those who know where to look. The catch? These symbols change daily, keeping the Black Market hidden from unwanted eyes.\n\nAlternatively, they may decide to approach one of the locals—a suspicious merchant or a lurking bystander—hoping to glean information. With a well-placed word or a bit of coin, they could persuade or charm someone into revealing the day’s clues. But the people here are wary, and only those who know how to play the game of the Lower District will get what they seek.",
              "npcs": []
            }
          ]
        },
        {
          "title": "The Black Market",
          "description": "Realizing that gaining access to the Black Market requires more than just finding it, the adventurers must employ their wit and resourcefulness to secure an invitation. This might involve persuading a local informant, bartering with a shady character, or even staging a risky infiltration. The stakes are high as they edge closer to the heart of the Lower District's underworld.",
          "encounters": [
            {
              "name": "The Entrance to the Black Market",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726436939251",
              "narrative": "Nestled between two crumbling buildings, is a makeshift entrance hastily constructed from old wooden boards. The entrance itself is nondescript—just a few planks nailed together with no visible markings. But to those who know what to look for, it’s unmistakable: this is the hidden doorway to the Black Market. A heavy cloth curtain hangs over the entrance, swaying gently in the faint breeze, concealing what lies beyond.\n\nStanding guard is a burly figure dressed in a tattered cloak, his face mostly hidden beneath a hood. His arms are crossed, and a long dagger is tucked visibly into his belt. As the adventurers approach, the guard eyes them with suspicion, his gaze sharp beneath the shadow of his hood.\n\n\"Looking for something?\" he grunts, his voice low and gravelly, stepping forward to block the entrance with his broad frame, waiting to see if the adventurers are worthy of entry.",
              "notes": "\"No one gets in without the passphrase.\" \n\nThe adventurers have several strategies at their disposal to gain access to the Black Market. They might rely on diplomacy or charm, using Charisma-based skills like Persuasion or Deception to sweet-talk or bluff their way past the guard. If they've overheard or gathered the passphrase through investigation or by asking the right people, they could simply recall it and gain entry. Alternatively, bribery is a practical option, with a well-timed offer of gold convincing the guard to look the other way. If the group prefers more aggressive tactics, they could use intimidation or threats to force the guard to let them through, showing their combat prowess or making veiled threats.\n\nFor a stealthier approach, they could attempt to sneak past using Dexterity (Stealth) or employ magic like Invisibility to bypass the guard unnoticed. If they find themselves without the necessary information, they might return to the streets to gather intelligence from the locals, using persuasion or intimidation to learn the passphrase or gain insights into how to bypass the guard. Magic spells like Charm Person, Suggestion, or even Disguise Self can also help manipulate the situation, giving the adventurers a creative edge in gaining access to the Black Market.\n\nIf they simply attack, the guard will call for reinforcements, a group of six henchmen. If any of the characters are downed, they will awake to find themselves in a cell, captured and to be interrogated by Silverhand himself.",
              "npcs": [
                {
                  "name": "Garrick",
                  "race": "Half-Orc",
                  "gender": "Male",
                  "characterClass": "Fighter",
                  "level": 4,
                  "appearance": "Burly figure dressed in a tattered cloak, face mostly hidden beneath a hood. Long dagger tucked into his belt.",
                  "personality": "Suspicious and intimidating, but loyal to those he deems worthy.",
                  "abilities": "Expert in hand-to-hand combat, intimidation, and dagger usage.",
                  "characterId": "garrick",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726436888924"
                }
              ]
            },
            {
              "name": "Labyrinthine Stalls",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726435567019",
              "narrative": "The narrow, makeshift entrance opens into the strange, shadowy world of the Black Market, a labyrinthine maze of stalls and tents. Vendors whisper from behind their counters, their goods ranging from the mundane to the forbidden: rare potions, stolen artifacts, strange magical trinkets, and enchanted weapons. Strange characters lurk in the shadows, their faces hidden by cloaks and masks, conducting quiet deals or watching intently as the adventurers move through the market. The sounds of hushed bartering, the occasional sharp laugh, and the constant shuffle of feet fill the air. \n\nFrom the first stall, a scarred and grizzled vendor with a wild look in his eyes and a crooked smile leans forward. \"Looking for something special, are we? I've got charms to ward off death... for the right price.\"\n\nNearby, a dwarven vendor in a tattered cloak boasts as she holds forth an intricately carved dagger. \"You won’t find craftsmanship like this above ground, love.\"\n\nA young woman with a scar across her chin, chuckles quietly as she walks past. \"New faces,\" she remarks with a smirk. \"Fresh meat.\"\n\nFrom deeper within the maze of stalls, a cackling laugh echoes out. \"Step right up, step right up! Rarities from the far reaches of Myr! Trinkets to tempt fate, and scrolls that speak of forgotten powers!\" A small hunched figure waves a bony hand toward the adventurers, beckoning them closer. \"Come closer, strangers... I’ve got exactly what you need.\"",
              "notes": "If the adventurers succeed on a perception check, their keen eyes catch sight of a stall tucked away in a shadowy corner, its vendor sitting casually behind a cluttered table. Among the trinkets and oddities, something familiar stands out: finely crafted elven goods, unmistakable in their delicate design and intricate craftsmanship. \n\nSilver goblets engraved with ancient elven runes, ornate wooden carvings from the Valkarr forest, and shimmering silks that glow faintly with an ethereal light are haphazardly displayed. These are the very items described in the missing shipment. The vendor, an oily man with beady eyes, watches passersby carefully, his fingers twitching nervously as he notices the adventurers’ interest.\n\n\"Ah, you've got a good eye,\" he croons, his voice slick with feigned charm. \"These pieces? Rare as they come. Found their way to me from... let’s just say, exclusive sources.\" He grins, but there’s something sinister behind the smile, and the adventurers now know they’re closer to unraveling the mystery of the stolen shipment.\n\nIf the characters are successful in pressing for more information, he will boast that the goods came to him by way of the infamous Silverhand himself.\n\nAs the adventurers mingle through the maze of stalls, it becomes clear that one topic dominates the hushed conversations around them: the upcoming auction. Whether they question the vendor selling the stolen elven goods or strike up a casual conversation with another merchant, the response is the same—the big auction is starting soon, where rare and powerful items will be up for bid.\n\nA grizzled merchant dealing in enchanted trinkets leans in close when they ask about it. \"You're not from around here, are you?\" he says with a knowing smirk. \"Big auction's coming soon. Finest goods, magical relics, maybe even some things no one should have their hands on. If you’ve got the coin, it's the place to be.\"",
              "npcs": [
                {
                  "name": "Grendar",
                  "race": "Human",
                  "gender": "Male",
                  "characterClass": "Merchant",
                  "level": "1",
                  "appearance": "A scarred and grizzled vendor with a wild look in his eyes and a crooked smile",
                  "personality": "Cunning, opportunistic, and always looking for a profitable exchange.",
                  "abilities": "Expert in appraisal and haggling, skilled in setting up traps and detecting lies.",
                  "characterId": "grendel-one-eye",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726436104061"
                },
                {
                  "name": "Rae the Scarred",
                  "race": "Human",
                  "gender": "Female",
                  "characterClass": "Fighter",
                  "level": "1",
                  "appearance": "A young woman with a distinct scar across her chin. She has short, messy hair and wears rugged adventurer's gear.",
                  "personality": "Confident, bold, and slightly taunting.",
                  "abilities": "",
                  "characterId": "rae-the-scarred",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726439232056"
                },
                {
                  "name": "Mizrith the Cackler",
                  "race": "Gnome",
                  "gender": "Male",
                  "characterClass": "Sorcerer",
                  "level": "2",
                  "appearance": "A hunched figure with a bony hand, bushy eyebrows, and an oddly large grin. His garb is a mix of colorful rags.",
                  "personality": "Eccentric, mischievous, and always eager to display his peculiar wares.",
                  "abilities": "Specialized in illusion and enchantment magic, adept at creating magical trinkets and rare scrolls.",
                  "characterId": "mizrith-the-cackler",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726438466481"
                },
                {
                  "name": "Vera Azimov",
                  "characterId": "",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726438484598",
                  "race": "Dwarf",
                  "characterClass": "Weapon Dealer",
                  "gender": "Female",
                  "appearance": "Wears a tattered cloak",
                  "class": "Loud and boastful",
                  "level": "1"
                }
              ]
            }
          ]
        },
        {
          "title": "The Auction",
          "description": "A rare artifact, believed to be connected to Valkaran heritage, is up for auction. The adventurers initially suspect it to be the key they seek. However, it turns out to be an old map, its significance shrouded in mystery. As they ponder the implications, they notice Silverhand, a prominent figure in the city’s smuggling operations, is also keenly interested in the item.",
          "encounters": [
            {
              "name": "The Auction Begins",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726455716232",
              "narrative": "The party is ushered into a shadowy, candlelit chamber deeper within the Black Market. The room is a stark contrast to the bustling stalls outside—quiet, dark, and secretive. Rows of velvet-covered seats are arranged before a small raised platform where the items will soon be displayed. The audience consists of a mix of shady figures, wealthy nobles, and collectors, their faces hidden behind intricately designed masks.\n\nA tall, slim figure draped in a black robe and black leather mask strides onto the platform. His voice, smooth and commanding, fills the room. \"Ladies and gentlemen, esteemed guests, welcome to tonight’s exclusive event. We have gathered some of the finest and most coveted items in the realm. May you bid wisely… and generously.\"\n\nAs the auctioneer gestures to an assistant, the first item is unveiled—a jeweled dagger, glinting ominously under the dim light. The crowd shifts with excitement as the bidding begins.",
              "notes": "If the characters look for Silverhand, they can find him on a successful perception check.\n\nSeated near the back, yet still commanding an undeniable presence, he exudes an air of cold calculation. His tall, slender frame is cloaked in a dark, richly embroidered coat. His left hand, encased in an intricate gauntlet of polished silver, rests on the arm of his chair. Beneath his hood, only the lower half of his face is visible, showing a thin-lipped smirk that hints at both intelligence and ruthlessness. Though his face remains shadowed, everyone in the room knows who he is: the man who controls the flow of illicit goods and information in Kordavos.",
              "npcs": []
            },
            {
              "name": "A Relic of Old Valkara",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726455771790",
              "narrative": "The crowd hushes as the auctioneer takes the stage once more, his eyes gleaming with anticipation. \"What I have next,\" he begins, his voice dripping with mystery, \"is truly one of a kind. Recovered from the depths of the Valkarr Forest—a relic of Old Valkara.\"\n\nThere’s a subtle shift in the room as interest piques, heads turning toward the stage.\n\nWith a dramatic sweep, he unveils an ancient map. The parchment, weathered by time, bears faint, intricate markings. \"This map,\" he continues, \"leads to an item of unknown origin—lost, forgotten, and waiting to be found. A mystery hidden in the wilds for centuries.\"\n\nBefore anyone can get too good a look at the route, the auctioneer dutifully returns the map to its protective case, obscuring the details from prying eyes. The auctioneer smiles slyly, sensing the growing anticipation. \"Now, let’s see who dares to take the first bid.\"",
              "notes": "The characters may have expected this to be the Key, but it is instead a different relic. The Key is already in the possession of the Covenant of the Cowl.",
              "npcs": [],
              "stages": [
                {
                  "name": "The First Bid",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726463464761",
                  "narrative": "As the auctioneer's voice rings out, starting the bidding for the map, a tense silence falls over the room. Eyes dart nervously, and hands hesitate, knowing well the reputation of those who covet such rare treasures. \n\nFrom the back of the crowd, a figure steps forward—Silverhand’s representative, a tall man dressed in a sharp black coat. He raises a gloved hand calmly. “Ten thousand gold,” he states with an air of finality.\n\nSeated behind him sits an undeniable presence exuding an air of cold calculation. His tall, slender frame is cloaked in a dark, richly embroidered coat. His left hand, encased in an intricate gauntlet of polished silver, rests on the arm of his chair. Beneath his hood, only the lower half of his face is visible, showing a thin-lipped smirk that hints at both intelligence and ruthlessness. Though his face remains shadowed, everyone in the room knows who he is: the man who controls the flow of illicit goods and information in Kordavos.\n\nA murmur ripples through the crowd, but no one dares to speak. The weight of the bid—and more importantly, the man making it—casts a heavy shadow over the room. All know that to challenge Silverhand, even through his emissary, could mean far more than losing gold. The auctioneer pauses, scanning the room, but no one else dares lift their voice in opposition.\n\n\"Do I hear another bid?\" the auctioneer asks tentatively, his voice cracking slightly in the tense atmosphere. Silence. \"Ten thousand going once… going twice…\"",
                  "notes": "",
                  "npcs": [],
                  "stages": []
                }
              ]
            },
            {
              "name": "The Winning Bid",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726458036467",
              "narrative": "The gavel falls with a sharp crack. \"Sold—to the gentleman in black!\" the auctioneer proclaims, though his enthusiasm falters as the tension in the room thickens.\n\nWithout a word, Silverhand’s representative turns on his heel, slipping into the shadows with an air of purpose. A pair of silent guards fall in behind him, and together, they make their way toward the exit.",
              "notes": "",
              "npcs": [
                {
                  "name": "Silverhand Representative",
                  "characterId": "",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726458565684"
                }
              ]
            }
          ]
        },
        {
          "title": "Silverhand",
          "description": "Choosing to follow Silverhand after the auction could reveal deeper layers of the plot. He leads them through the winding streets to a hidden den beneath an abandoned warehouse by the docks. Here, amidst the remnants of his smuggling operations, Kazimir Raskov—notorious as Silverhand—deliberates his next move.",
          "encounters": [
            {
              "name": "Shadowing Silverhand",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726462025424",
              "narrative": "Late evening falls over Kordavos. The city’s streets are bathed in a dim, silvery glow from the moon hanging low in the sky. Silverhand strides purposefully away from the auction house, his cloak rippling in the faint breeze. The distant hum of the city’s nightlife fades as he and his two silent guards move through the winding alleys, the flickering street lanterns barely illuminating their cautious steps. \n\nThe air is thick with tension as they navigate the darkened streets, the threat of being spotted ever-present. Silverhand’s movements are deliberate, and the path he takes seems to lead deeper into the city’s forgotten corners, far from the watchful eyes of law and order.",
              "notes": "Silverhand’s people are seasoned professionals, and following them undetected will require a group stealth or deception check. If they fail, the group is quickly noticed, and two of Silverhand’s guards subtly block their path in a narrow alley. The guards won’t initiate combat right away, but will issue a stern warning to \"mind their own business\" and leave. If the party presses, they can try persuasion or intimidation to continue the pursuit, but pushing too hard risks provoking a fight.\n\nIf they just attack, other Silverhand bodyguards will appear quickly to defend him. If any of the characters fall due to attacking him, they will wake up in a cell to be interrogated by Silverhand himself.",
              "npcs": [
                {
                  "name": "Silverhand",
                  "race": "",
                  "gender": "",
                  "characterClass": "",
                  "level": "",
                  "appearance": "",
                  "personality": "Cunning, enigmatic, and stealthy. Silverhand is always two steps ahead, calculating his movements precisely to avoid detection.",
                  "abilities": "",
                  "characterId": "silverhand",
                  "class": ""
                },
                {
                  "name": "Varchk",
                  "race": "Half-Orc",
                  "gender": "Male",
                  "characterClass": "Fighter",
                  "level": "4",
                  "appearance": "Muscular build with greenish skin, a prominent tusk jutting out from his lower jaw, and a scar that runs from his forehead to his cheek.",
                  "personality": "Loyal, stoic, and unwavering. Aldith is fiercely protective of Silverhand and follows orders without question.",
                  "abilities": "",
                  "characterId": "aldith",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726459305887"
                },
                {
                  "name": "Kaeleth",
                  "race": "Human",
                  "gender": "Female",
                  "characterClass": "Mage",
                  "level": "5",
                  "appearance": "",
                  "personality": "Calm, observant, and sharp-witted. Kaelen’s keen senses and agility make her an excellent scout.",
                  "abilities": "",
                  "characterId": "kaelen",
                  "class": "",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726461750367"
                }
              ]
            },
            {
              "name": "The Hideout",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726461696892",
              "narrative": "The trail leads back to the docks, where the evening mist rolls in from the sea, shrouding the ships and warehouses in a thick veil of fog. The once-bustling port has grown eerily quiet, save for the distant creak of ropes and the occasional splash of waves against the pier. At the edge of the docks, they spot their destination—an abandoned warehouse, its weathered wooden walls barely visible in the dim light of a flickering lantern hung outside.\n\nThe building seems forgotten by time, with boarded-up windows and a rusted metal door hanging loosely on its hinges. Silverhand slips through the mist toward this inconspicuous hideout, his silver gauntlet catching the light briefly before he vanishes into the shadows. ",
              "notes": "The adventurers have several options for getting inside Silverhand’s hideout, depending on their approach. Stealthy players might observe the building from the shadows, waiting for one of Silverhand’s guards to exit or for a moment when the door is left slightly ajar. A successful perception or investigation check could reveal a loose window on the upper floor or a back entrance hidden by crates and debris. If they possess spells such as invisibility or disguise, magic could allow them to slip past unnoticed or even pose as one of Silverhand’s own men.\n\nAlternatively, a more direct approach could involve bluffing their way inside. The adventurers might try to convince the guards they have business with Silverhand, requiring a high persuasion or deception check, especially if they claim involvement in the Black Market auction. Bribery could also work if they offer gold or a valuable item in exchange for entry. \n\nIf all else fails, combat is an option, though they would not likely succeed, and instead wind up as captives, subject to interrogation from Silverhand himself.\n\nOr another option is to assume Silverhand is aware he was followed and wants to meet this crew of adventurers to find out more about them, with his bodyguards not far away.",
              "npcs": []
            },
            {
              "name": "Face-to-Face with Silverhand",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726464286132",
              "narrative": "Inside the dimly lit hideout, the scent of damp wood and smoke fills the air. The interior is stark, with low ceilings and walls lined with crates and sacks—no doubt filled with illicit goods. A faint flickering of candlelight from the far side of the room casts long shadows across the floor, making the cramped space feel even more confined. \n\nAt the far end of a long, weathered table, Silverhand sits, shrouded in the dim light of flickering lanterns. His presence dominates the room, his infamous silver gauntlet resting on the tabletop, the metal gleaming menacingly in the low light. His bald head shines faintly, but it’s his piercing eyes—cold, calculating, and dangerous—that capture attention. His dark, finely cut clothes hint at wealth, but the tension in his posture and the predatory stillness he exudes tell a story of violence and control. In front of him, a rare bottle of Hammerdeep whiskey sits uncorked, its deep amber liquid untouched, as though mocking any who might dare to indulge.\n\nWithout standing, Silverhand's gaze locks onto the adventurers as they step into the room. His voice cuts through the silence like a blade. \"You’re late.\" There’s no invitation in his tone, only cold accusation. He leans forward slightly, his silver-clad fingers tapping the table with a metallic clink that echoes ominously. \"I don’t like being followed. I like being interrupted even less.\"\n\nHe gestures lazily toward the empty chairs, though the gesture feels more like a command. \"Sit. You’ve gone through a lot of trouble to find me, but let’s be clear,\" his voice drops to a growl, his silver gauntlet flexing with unsettling precision, \"this is my domain. You are here because I have allowed it, and you leave when I decide.\" He takes a long, deliberate pause, eyes narrowing. \"Now, tell me why I shouldn’t have you thrown into the harbor, or worse.\"",
              "notes": "This encounter could play itself out in a variety of ways.\n\nSilverhand is an alias used by Kazimir Raskov, the head of the Raskov Clan’s smuggling operations. He was in fact behind the operation to steal the Blackthorn shipment at the docks. However, he was double crossed by one of his men who was secretly a member of an organization known as the Covenant of the Cowl. \n\nKazimir wishes to avoid any direct confrontation with the Covenant. His instincts tell him that it is too dangerous. They seem to know everything, with spies operating everywhere. In fact, he is considering leaving the city to expand their operations elsewhere.",
              "npcs": [
                {
                  "name": "Silverhand",
                  "characterId": "",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726464320001",
                  "race": "Human",
                  "characterClass": "Rogue",
                  "gender": "Male",
                  "level": "8"
                }
              ]
            }
          ]
        },
        {
          "title": "Ambush",
          "description": "On their return to the Dragonbone Inn, the adventurers are attacked by agents of the Covenant of the Cowl. Determined to eliminate those who get too close to the truth, the attackers fight ferociously. Capturing an agent could provide valuable information, but they are prepared to die to protect their secrets, creating a perilous encounter for the party.",
          "encounters": [
            {
              "name": "The Ambush",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726580775048",
              "narrative": "As the adventurers make their way back to the Dragonbone Inn, the streets of Kordavos are eerily quiet, bathed in the cold, pale light of a waning moon. The lanterns that line the narrow roads flicker weakly, casting long, twisted shadows across the cobblestones. The chill of the late evening air bites at their skin, and a heavy stillness hangs in the air.\n\nSuddenly, the sharp *thunk* of an arrow breaks the silence, embedding itself into the wooden door of a nearby shop, just inches from one of the adventurers. From above, a soft rustle catches their attention. The rooftops, dark and shrouded in shadow, hold the vague forms of hooded figures. Silent watchers, barely visible, but present.\n\nThen, without warning, a low rumbling voice, amplified and unnatural, reverberates through the narrow streets. \"*You tread where you are not welcome,*\" the voice booms, unnatural and echoing as if spoken from all directions at once. The air itself seems to tremble. The ground beneath their feet shudders slightly, cracks form in the nearby stone, and the faint scent of sulfur fills the air. From the rooftops, more arrows are nocked, but none are loosed.\n\n\"Cease your meddling,\" the voice continues, filled with cold authority. \"Turn your attention away from what is not yours to uncover, or the consequences will be far worse than arrows in the night.\" Another arrow whistles through the air, embedding itself in the wall just ahead of the adventurers, a clear warning.\n\nThe figures on the rooftops remain motionless, but their presence is overwhelming. The voice speaks once more: \"We are watching. We know every step you take. Keep searching, and you will find only ruin.\"",
              "notes": "This encounter serves as a powerful psychological tactic by the Covenant of the Cowl to intimidate the adventurers rather than physically harm them. The use of magic, particularly Thaumaturgy, and the dramatic timing of the arrows are meant to create an atmosphere of unease and fear, reminding the party that they are constantly being watched. The adventurers should feel the weight of the Covenant’s influence and the very real threat that comes from crossing such a secretive and powerful organization. However, the absence of a direct attack gives the players the opportunity to choose their next steps without forcing combat, allowing them to consider the gravity of their investigation.",
              "npcs": [
                {
                  "name": "Cowled Rogue",
                  "race": "Human",
                  "gender": "Male",
                  "characterClass": "Rogue",
                  "level": "5",
                  "appearance": "A lithe, shadowy figure with a hooded cloak that hides his features, except for his sharp, glinting eyes.",
                  "personality": "Cold, calculating, and merciless.",
                  "abilities": "Expert marksman with a crossbow, skilled in stealth and agility.",
                  "characterId": "silas"
                },
                {
                  "name": "Cowled Assassin",
                  "race": "Half-Elf",
                  "gender": "Female",
                  "characterClass": "Assassin",
                  "level": 5,
                  "appearance": "Slender and graceful, her narrow eyes gleam with a dangerous light beneath her deep hood.",
                  "personality": "Stoic, deadly, and fiercely loyal to The Cowl.",
                  "abilities": "Master of poisons and silent kills, exceptionally quick and agile.",
                  "characterId": "liora"
                }
              ]
            }
          ]
        }
      ],
      "plot": "As the party enters the Lower Districts, they find its labyrinthine streets and alleyways quite different from the North End.\n\nThey will need to use their skills to attempt to locate the mysterious Black Market. As they wander the twists and turns of the cramped streets, it isn’t long before they experience an encounter with a group of halfling street urchins who attempt to pickpocket them and take the scroll case.\n\nThe black market is invitation-only. The adventurers must find a way to secure invitations or somehow gain access. The market itself is a maze of stalls selling illegal goods. It's bustling with nefarious individuals.\n\nOne of the stalls has Elven goods for sale that match the description of the items stolen from the ship. If pressed successfully for information, the merchant will reveal that he purchased the goods \n\nThey learn that a rare artifact connected to the Valkaran heritage is up for auction. They will think it may be the key, but it is actually an old map of some sort. Silverhand is there and will be bidding on the item.\n\nThe adventurers can choose to engage with Silverhand at their discretion. If they follow him, he will return to a hidden den beneath an abandoned warehouse by the docks.\n\nSilverhand is an alias used by Kazimir Raskov, the head of the Raskov Clan’s smuggling operations. He was in fact behind the operation to steal the Blackthorn shipment at the docks. However, he was double crossed by one of his men who was secretly a member of an organization known as the Covenant of the Cowl. \n\nKazimir wishes to avoid any direct confrontation with the Covenant. His instincts tell him that it is too dangerous. They seem to know everything, with spies operating everywhere. In fact, he is considering leaving the city to expand their operations elsewhere.\n\nOn their way back to the Dragonbone Inn, they are ambushed by agents of the Covenant of the Cowl. The leaders of the Covenant have decided that the adventurers are getting too close to the truth and must be eliminated. None of the attackers will allow themselves to be captured. \n\nIf they must flee, they will retreat to their secret underground tunnels, disappearing behind a door that gets magically sealed behind them. If captured, they will reveal nothing and attempt to ingest a cyanide pill. If somehow the adventurers are able to use a charm person or other means, it is possible they could get one of the attackers to reveal the existence of the Covenant’s secret underground network. They will not reveal the connection of the Cowl to the Valtor clan as they do not have knowledge of it."
    },
    {
      "title": "The Masquerade Ball",
      "plot": "The masquerade ball is a dazzling affair, held in the opulent halls of the Blackthorn mansion. The architecture blends Valkaran artistry with Asterian sophistication, featuring soaring ceilings, marble columns, and intricate carvings depicting legendary tales. \n\nThe adventurers don elaborate costumes and masks, ready to blend in with the elite of Kordavos. As they enter, the stark contrast between the lavishness of the mansion and the modest living conditions they've observed elsewhere in Kordavos is quite apparent. Whispers among some guests hint at disapproval of such extravagance, especially during times when many Valkarans struggle.\n\nLady Astrid will graciously greet the party and introduce them to her brother Thaddeus, the Patriarch of the Blackthorn Clan. He thanks them for their actions at the docks, and suggests an alliance. He needs strong people to help him mold the future of Davos in close alignment with the Margrave, Aeron Davos. \n\nIn reality, the Blackthorns seek to gain more power, glory and wealth for themselves, with little regard or even at the expense of other Valkarans. Astrid is using her knowledge of the forest and beast mastery to engage with the elves to discover hidden wealth and powerful artifacts of the lost glory days of Valkara for the Blackthorns, and those that have chosen to align with them. Her brother is a political force, with ambitions to become a key ally to the Margrave of Davos and the Asterians.\n\nFor all those who choose to align themselves with the Blackthorns there is opportunity for wealth and power. Thaddeus is proud and dismissive of the opposition as crude thieves and weak minded fools who cling to the past.\n\nLater when the characters are on their own, Seraphina Valtor will introduce herself along with her personal guest and spiritual advisor, Bishop Nikolai Petrov. After comparing the extravagance of the ball and mansion to the living conditions of ordinary Valkarans, they talk about how they were once a proud and mighty people. Now, regretfully, they seem to be losing their heritage.\n\nSeraphina Valtor is in actuality the leader of the Covenant of the Cowl. She is aware that the adventurers are snooping around and will subtly probe to find out if the characters know about the key, its location or how close they are to finding it. The bishop covertly leads a faction of the church that is secretly connected to the Valtor Clan and allied with the Covenant.\n\nIf the characters snoop around the mansion, they may be able to find various clues, such as shipping manifests, correspondence with the Valkarr elves and potentially even financial records that document fraudulent transactions benefiting a ‘Drakovan’ family. If they are especially bold, they can even find an old tome hidden in Astrid’s quarters, written by Milos Antonov with all of his notes on the Key of Ilmarin. The tome was in fact stolen when Joran’s father was poisoned by Astrid herself.\n\nAs the intrigue of the evening builds, Thaddeus takes the stage to proclaim a new era of prosperity for those who align with the Blackthorns and the Asterians. \"We stand on the brink of greatness. Those who cling to outdated traditions will be left behind.\"\n\nIf the forest drake has not been killed, he will proudly reveal it as an additional example of new opportunities from forging a relationship with the elves. If the forest drake is not available, Eamon the half-elf they had met at the Dragonbone Inn will instead conjure an impressive illusion.\n\nAt this moment, a covert assassin, donned in the garb of the Covenant, will take advantage of the distraction and stab Thaddeus with a poison dagger. “Death to the murderer of Milos Antonov!” The killer will then immediately attempt to escape out the balcony behind him, descending down a rope, into a secret tunnel in the basement. At the end of the tunnel is a door, which will be sealed shut behind him and locked with a magic seal. ",
      "scenes": [
        {
          "title": "The Blackthorn Mansion",
          "encounters": [
            {
              "name": "Entry to the Ball",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726597339022",
              "narrative": "The Blackthorn Mansion looms ahead, its towering spires silhouetted against the darkening sky. Flickering torchlight illuminates the imposing stone walls, casting long, shifting shadows that dance across the mansion’s façade. Wrought iron gates, adorned with intricate Valkaran and Asterian symbols, stand open, welcoming the evening’s elite. Servants in finely tailored uniforms guide carriages through the cobblestone courtyard, while guests draped in lavish costumes and ornate masks make their way up the grand staircase leading to the entrance.\n\nAt the foot of the grand staircase, two imposing guards, clad in polished black armor adorned with the Blackthorn family crest, stand vigilant. Their hands rest casually on the hilts of their sheathed swords, but their watchful eyes dart over each guest with practiced precision.\n\nOne of the guards steps forward, a burly man with a red beard and imposing frame that seems familiar. \n\nNow, though, Barok looks far more composed, with his unruly beard neatly trimmed and his posture straighter, as if the formal attire demands a certain level of dignity. His eyes narrow in recognition as the adventurers approach, but he says nothing of their prior encounter. Instead, he steps forward, raising a gloved hand.\n\n\"Invitation,\" he grunts, his voice as gruff as they remember, though more restrained in this refined setting. His eyes scan each of them, lingering a moment longer than necessary, a hint of recognition on his face.",
              "notes": "This guard is the same man they encountered during the Harvest Festival brawl—Barok, the rough-edged leader who had been quick to escalate tensions between rival Valkaran clans. \n\nIf the adventurers previously sided with Barok, he’ll be more accommodating and might allow them in with minimal scrutiny. If they opposed him, Barok will be unfriendly, scrutinizing their invitations and potentially causing a delay unless persuaded or intimidated. In a neutral scenario, Barok remains professional, checking their invites efficiently but becoming confrontational if disrespected.",
              "npcs": [
                {
                  "name": "Barok Redbeard",
                  "race": "Human",
                  "gender": "Male",
                  "characterClass": "Fighter",
                  "level": "3",
                  "appearance": "Burly frame with a neatly trimmed red beard, wearing polished black armor adorned with the Blackthorn family crest.",
                  "personality": "Gruff but dignified, vigilant, holds grudges from past encounters.",
                  "abilities": "Proficient in hand-to-hand combat and swordsmanship, keen observational skills.",
                  "characterId": "barok-ironfist",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726597353909"
                },
                {
                  "name": "Door Guard",
                  "characterId": "",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726597363187",
                  "race": "Human",
                  "characterClass": "Fighter",
                  "gender": "Male",
                  "level": "2"
                }
              ]
            },
            {
              "name": "Inside the Ball",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726605687900",
              "narrative": "As the adventurers step through the grand entrance of the Blackthorn Mansion, they are immediately enveloped by the opulence of the Masquerade Ball. The soaring ceilings stretch high above, supported by elegant marble columns adorned with gold filigree. Along the walls, intricate carvings tell the stories of Valkaran legends, their craftsmanship blending seamlessly with the sleek, Asterian-style architecture that dominates the room. Crystal chandeliers cast a warm glow over the scene, refracting light onto the polished stone floors and the vibrant tapestries that hang from every wall.\n\nThe ballroom itself is a dazzling display of wealth and power, where nobles, merchants, and influential figures from across Kordavos gather in elaborate costumes and masks. Tables laden with exotic delicacies, goblets of rare wines, and displays of gemstones glimmer under the soft light. The air hums with laughter, music, and whispered conversations, creating a stark contrast to the modest and often struggling lives the adventurers have witnessed in the city outside.\n\nAs they take in the splendor of the room, the disparity between this lavish celebration and the hardships endured by the common Valkarans becomes painfully clear. Here, in the heart of the Blackthorn’s domain, wealth flows freely, and the concerns of the outside world seem distant, almost forgotten. The adventurers can sense that beneath the glittering surface, deeper currents of intrigue and ambition swirl among the guests.",
              "notes": "If the characters listen or pass a perception check, they can hear whispers among some guests hint at disapproval of such extravagance, especially during times when many Valkarans struggle. Others admire the Blackthorn’s forward thinking.\n\nFrom behind elaborate masks, a few guests murmur in hushed tones, expressing quiet disapproval of the Blackthorns’ extravagance. \"All this, while many in the city can barely afford bread,\" one voice whispers, her tone sharp with judgment. Another adds, \"They’ve forgotten their roots... forsaking the people for Asterian opulence.\"\n\nYet, not all share this sentiment. Other guests admire the Blackthorns' ambition and speak of their \"forward-thinking\" ways. \"They know how to seize opportunity,\" says a man in a richly embroidered cloak. \"In times like these, it’s visionaries like him who will secure the future of Kordavos.\"",
              "npcs": []
            },
            {
              "name": "The Blackthorns",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726591063592",
              "narrative": "A striking woman walks toward the new arrivals, her elaborate gown shimmering under the soft glow of chandeliers. She moves with effortless grace, her face obscured by a golden mask adorned with intricate details. \n\n\"Welcome to our humble gathering,\" she says, her voice smooth but commanding, her eyes scanning the party with a keen interest. \"I’m so delighted that you have come.\" \n\nShe pauses, letting the tension hang for just a second longer before her hand reaches up to remove the mask. With a graceful flourish, the mask falls away, revealing the familiar face of Lady Astrid Blackthorn. Surrounded by luxury and opulence, she is almost unrecognizable from the rugged ranger they fought alongside in the chaos of the docks. Now, in her elaborate attire, she exudes an air of nobility and control.\n\n“I must admit, you’ve piqued my interest since our little encounter at the docks. Not many handle themselves so well in such chaotic circumstances.”\n\nShe glances around the room, the faintest hint of pride in her gaze. “But tonight... tonight is a different kind of challenge. You’ll want to meet my brother, Thaddeus. He has a keen eye for talent and understands the value of... skilled allies.” Astrid offers a knowing smile. “He’s a man of vision, and if you’re the type who seeks to rise above the fray, I think you’ll find him quite compelling. Shall we?”",
              "notes": "As the conversation progresses, Astrid will suggest introducing them to her brother, Thaddeus Blackthorn, who holds more political sway and could offer them valuable connections. She will make it clear that the Blackthorn family rewards those who prove to be valuable allies, planting seeds of intrigue about what future opportunities may await them.\n\n\"You’ll want to meet my brother, Thaddeus. He has a keen eye for talent and understands the value of... skilled allies.” Astrid offers a knowing smile. “He’s a man of vision, and if you’re the type who seeks to rise above the fray, I think you’ll find him quite compelling. Shall we?”",
              "npcs": [
                {
                  "name": "Astrid Blackthorn",
                  "characterId": "",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726590994792",
                  "race": "Human",
                  "characterClass": "Ranger",
                  "gender": "Female",
                  "level": "6"
                }
              ],
              "stages": [
                {
                  "name": "Meeting Thaddeus",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726605568064",
                  "narrative": "A tall and broad-shouldered noble stands prominently in the mansion’s grand rotunda, his dark hair slicked back to reveal a sharp, angular face that exudes confidence and control. His piercing blue eyes seem to take in every detail, his lips curling into a smile that never quite reaches them, hinting at the calculated nature beneath his polished exterior. tall amidst a group of finely dressed nobles. His attire is immaculate, adorned with symbols of both Valkaran heritage and Asterian influence, blending the old world and the new. \n\n“Ah, so these are the capable individuals my sister has spoken of,” Thaddeus begins, his voice smooth and measured. He extends a hand in greeting, though his eyes betray the fact that he is already assessing them. “I must say your arrival in Kordavos have not gone unnoticed.”\n\nHe gestures for them to step closer, away from the crowd. “The March of Davos is at a turning point. The old ways, while noble in their time, can only hold us back. The Margrave sees the future, and so do I. Those with the foresight to align themselves with progress—well, they stand to benefit greatly. Wealth, influence, power... it’s all there for those who aren’t afraid to reach for it.” \n\nHis tone shifts slightly, growing colder as he speaks of the opposition. “Of course, there are always those who resist change. Crude, small-minded fools clinging to traditions long past their prime. But their time is ending.”\n\nThaddeus pauses, offering a sly smile. “Consider this an invitation. Align yourselves with the Blackthorns, and there’s no telling how far we might go together. But choose your path carefully. Not everyone in this city is fit to be part of what’s to come.”",
                  "notes": "After exchanging a few more pleasantries and gauging the adventurers' reactions, Thaddeus offers a final, cordial smile. \"Consider my offer, but don’t delay too long. Opportunities such as these have a way of slipping through one’s fingers,\" he says smoothly. With a nod to his sister, he adds, \"Astrid, we have other guests to attend to.\"\n\nAstrid gives the adventurers a lingering glance before turning to follow her brother. \"Enjoy the evening, friends. I’m sure we’ll speak again soon,\" she says, her voice warm but hinting at an underlying calculation. Together, the Blackthorn siblings slip into the crowd, leaving the adventurers free to enjoy the opulent surroundings of the masquerade ball.\n\nThaddeus carries on his person a key to his desk and the basement vault—a small yet intricately designed object, reflecting the wealth and attention to detail that defines the Blackthorn patriarch. Forged from polished black iron, the key’s shaft is engraved with delicate filigree patterns that resemble twisting vines, perhaps a nod to the Valkaran heritage the Blackthorns claim to preserve.\n\nThe head of the key is set with a dark, glimmering onyx stone, subtly enchanted to enhance its durability and prevent it from breaking or bending under pressure. This stone also serves as a focus for the desk’s arcane security, interacting with the lock’s magical components to ensure only Thaddeus—or someone with his key—can open it safely. At the base of the key, where it attaches to a finely braided leather cord, a tiny emblem of the Blackthorn family crest is etched, a small reminder of the power and influence behind it.",
                  "npcs": [
                    {
                      "name": "Thaddeus Blackthorn",
                      "characterId": "",
                      "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726605980934",
                      "race": "Human"
                    }
                  ],
                  "stages": []
                }
              ]
            },
            {
              "name": "The Lady and The Bishop",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726609502768",
              "narrative": "As the adventurers mingle among the masked guests of the ball, they are approached by a pair of figures moving with purpose through the crowd. One is an elegantly dressed woman, her poise regal, her movements deliberate and graceful. Beside her walks a tall man in ornate clerical robes, his presence calm yet commanding. Both wear ornate masks, but as they come to stand before the adventurers, the woman reaches up and removes hers with a respectful nod, revealing striking features and piercing eyes. The bishop follows suit, lowering his mask to reveal a stern yet composed face.\n\n\"Good evening,\" the woman begins, her voice smooth and deliberate. \"I am Seraphina Valtor, and this is Bishop Nikolai Petrov.\" She offers a respectful nod, while the bishop inclines his head in silent greeting. \"It seems you are not the typical guests here,\" Seraphina adds, her eyes sweeping over the adventurers, assessing them. She gestures subtly to the grand surroundings, her gaze settling on the opulence of the ballroom. \"Such grandeur on display, while so many of our people suffer... It’s an unfortunate contrast, don’t you think?\"\n\nBishop Nikolai speaks, his voice measured. \"We were once a proud and mighty people, deeply connected to our heritage. Now it seems some have forgotten what made us strong.\" His tone carries a hint of regret, but also resolve. \"There are those who still believe in preserving what truly matters.\"\n\nSeraphina’s eyes meet each of the adventurers', her expression intent. \"The Blackthorns have ambitions, of course. But not everyone shares their vision for our future. I wonder if people such as yourselves might be interested in... a different way forward.\" She pauses, lowering her voice. \"One that respects where we came from and what we stand to lose.\"",
              "notes": "Seraphina Valtor is in actuality the leader of the Covenant of the Cowl. She is aware that the adventurers are snooping around and will subtly probe to find out if the characters know about the key, its location or how close they are to finding it. The bishop covertly leads a faction of the church that is secretly connected to the Valtor Clan and allied with the Covenant.",
              "npcs": [
                {
                  "name": "Seraphina Valtor",
                  "characterId": "",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726609419379",
                  "race": "Human",
                  "gender": "Female"
                },
                {
                  "name": "Bishop Nicolai",
                  "characterId": "",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726609448307",
                  "race": "Human",
                  "characterClass": "Priest",
                  "gender": "Male",
                  "level": "5"
                }
              ],
              "stages": [
                {
                  "name": "A Conversation with Seraphina",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726609667621",
                  "narrative": "As Seraphina Valtor continues the conversation with the adventurers, her questions take on a more subtle yet probing nature. Her tone remains pleasant, but there’s a discernible shift, as if she’s testing the waters for hidden truths. \n\n\"You know,\" she begins, glancing around at the extravagant ball, \"Kordavos has always been a place where power and history intersect. It’s curious, really, how much of our heritage has been lost or, perhaps… *misplaced.*\" Her eyes linger on the adventurers, gauging their reactions. \"There have been whispers—rumors, really—that certain families in Kordavos are not content with their wealth and standing. They’re seeking to acquire more. And not just in gold or influence, but in things that truly belong to the Valkaran people.\"\n\nShe lowers her mask, as does the bishop, her expression calm but sharp. \"It’s said that the Blackthorn family has been collecting relics—items of great historical and cultural significance. Some believe they’re doing so to curry further favor with the Asterians, perhaps even to strengthen their grip on the city. These items… they should be safeguarded by those who truly understand their value, don’t you think?\"\n\nBishop Nikolai, standing quietly beside her, fingers his silver chain with the symbol of Thyra, his eyes narrowing slightly. Seraphina leans in, her voice soft but pointed. \"Have you come across anything like that in your recent travels? Something that might help preserve our people’s true legacy?\" ",
                  "notes": "Her words, while delicate, are unmistakably fishing for any knowledge the adventurers might hold regarding the Key of Ilmarin. All the while, the bishop watches, ready to interject if needed, casting the adventurers in a web of intrigue where power, heritage, and ancient secrets intertwine.",
                  "npcs": [],
                  "stages": []
                }
              ]
            }
          ]
        },
        {
          "title": "Exploring the Mansion",
          "encounters": [
            {
              "name": "A Distraction",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726622649291",
              "narrative": "The ballroom's murmur of conversation quiets, Lady Astrid Blackthorn steps forward, her voice smooth and commanding as she addresses the crowd. Her lips curl into a proud smile, and her eyes scan the room, lingering on the adventurers for a moment before she continues.\n\n\"Ladies and gentlemen, honored guests, tonight we celebrate not just our prosperity but our alliance with the ancient people of the Valkarr Forest. In keeping with this celebration, I am pleased to introduce a very special guest, an emissary from our elven allies. Please welcome Aelindor, master bard of Lindrathil, who will honor us with the Song of the Eldertree.\"\n\nThe grand doors of the ballroom swing open, and all eyes turn as a tall, ethereal elf strides into the room. His silver hair shimmers under the chandelier light, and his long, flowing robes of green and silver seem to blend with the very air around him. Across his back, he carries an ornately carved lyre made from the heartwood of an ancient tree, its strings glinting like threads of moonlight.\n\nAelindor steps gracefully to the center of the ballroom, offering a respectful nod to Astrid before he faces the gathered crowd. His voice is as smooth as flowing water. \"It is an honor to stand before you. Tonight, I share a song from my people—the Song of the Eldertree. It speaks of the forest’s eternal wisdom and the bond between our people and this land.\"\n\nHe begins to strum the lyre, and an ethereal melody fills the air, soft and haunting, as if the very forest itself is whispering through the strings. The music weaves through the crowd, drawing them in, and for a moment, it feels as though the ballroom has been transported to the heart of the ancient woods. \n\nIt also could serve as the perfect distraction should someone in the crowd of attendees wish to slip away.",
              "notes": "",
              "npcs": []
            },
            {
              "name": "Through the Halls",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726623933022",
              "narrative": "A dimly lit hallway stretches out, the flicker of a distant candle casting long shadows on the stone walls. Pressing forward, the sound of the party grows faint, replaced by the soft creak of wood underfoot and the low murmur of their own movements.\n\nThe hall ends with a staircase rising on the left, spiraling upwards to the higher levels of the mansion, its bannisters polished and ornate, hinting at more luxurious chambers above. On the right, a narrow set of steps descends into the bowels of the mansion, where the air grows cooler, and the faint scent of aged wine or damp stone lingers.",
              "notes": "",
              "npcs": []
            },
            {
              "name": "The Ranger’s Quarters",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726624593921",
              "narrative": "On the upper floors, the sounds of the masquerade ball below become distant echoes, leaving only the subtle creak of wood and the occasional gust of wind rattling the ornate windows.\n\nAt the end of a long corridor adorned with portraits of the Blackthorn family, is a heavy door carved with intricate designs of twisted branches and forest creatures—symbolic of the Blackthorn clan’s connection to the Valkarr Forest. ",
              "notes": "The door is locked.",
              "npcs": [],
              "stages": [
                {
                  "name": "Inside Astrid’s Quarters",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726624812656",
                  "narrative": "Inside, the room exudes a rustic elegance, a blend of Blackthorn wealth and her deep connection to the wilderness. Animal pelts line the floor, while the walls are decorated with mounted hunting trophies and maps of the Valkarr Forest. A large wooden desk stands near the window, scattered with papers, maps, and various trinkets—a reflection of Astrid’s meticulous planning and her ties to the Valkaran wilderness.\n\nA smaller door in the back leads to a private study, where the faint scent of old leather and ink lingers in the air. On the desk, a few open books rest alongside a locked chest. A hunting bow is propped against the wall, and on the shelves, there are tomes and scrolls detailing elven lore and forest creatures.",
                  "notes": "With the right dice rolls, they can discover a hidden compartment.",
                  "npcs": [],
                  "stages": []
                },
                {
                  "name": "The Hidden Compartment",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726624846273",
                  "narrative": "As the adventurers explore Astrid’s private study, they notice a faint draft coming from one of the bookcases, as if air is slipping through the cracks. Upon closer inspection, they find a small mechanism hidden within the intricate carvings along the side of the shelf. With a click, the bookshelf swings open, revealing a narrow compartment behind it.\n\nInside the hidden compartment is a worn, leather-bound journal. Its edges are frayed, and the pages are filled with the meticulous handwriting of a scholar. The cover bears the initials \"M.A.\" \n\nThe pages reveal sketches, historical notes, and cryptic clues tied to forgotten relics. It's now clear that Astrid had stolen this journal after orchestrating Milos's death, concealing it to keep its valuable knowledge for her own purposes.",
                  "notes": "This is the very journal that Joran had been desperately searching for, believed lost when his father was murdered. The journal contains Milos Antonov’s research on ancient Valkaran artifacts, most notably his detailed investigation into the Key of Ilmarin and its significance to Valkaran history.\n\nThis journal represents both the culmination of Milos’s life’s work and the key to unraveling the truth behind his death—a truth the adventurers now hold in their hands.",
                  "npcs": [],
                  "stages": []
                }
              ]
            },
            {
              "name": "The Lavish Corridor",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726672244509",
              "narrative": "Through the winding hallways of the mansion is a section of the estate clearly reserved for the highest-ranking member of the Blackthorn family. The lavish decor gradually becomes even more ornate—walls adorned with rich tapestries, priceless paintings depicting scenes of conquest and glory, and opulent candelabras casting a warm golden glow along the corridors.\n\nTwo guards stand blocking the way. Behind them is a large, intricately carved door. Both guards, clad in dark leather reinforced with iron plating, wear the unmistakable crest of the Blackthorn family—a black tree twisted into a circle—stitched into their tabards. \n\nThough they wear the family crest and carry longswords, their postures are relaxed, and their conversation seems far more focused on the lavish spread at the Masquerade than any potential threats. The hallway is otherwise silent, the muffled sounds of the Masquerade Ball barely audible from this far into the mansion\n\nOne of the guards, a stocky man with graying hair, leans against the wall, absently fiddling with the straps of his armor. His companion, a younger guard with a scruffy beard, lets out a soft chuckle as he mutters something under his breath about the wine and roasted game downstairs. Neither seems particularly interested in the goings-on beyond the door they’re meant to protect, though they still cast occasional glances down the hall.",
              "notes": "Unlike the highly alert soldiers in the main hall, these guards appear more complacent, their attention divided between their conversation and the events below. While they aren't entirely inattentive, they seem far more approachable and easier to influence.\n\nFriendly Conversation: A well-timed conversation or compliment about the Masquerade could distract them further, offering the party a chance to slip by unnoticed.\n\nSmall Bribe: These guards don’t seem too proud to accept a little \"encouragement.\" A few gold coins or a rare drink from the ball might make them more inclined to turn a blind eye.\n\nConvincing Story: Given their relaxed demeanor, the adventurers could easily convince them that Thaddeus had summoned them for an urgent discussion or delivery.\n\nMagical Assistance: Given how at ease they are, even a simple illusion or Charm Person spell could sway them with little resistance.",
              "npcs": [],
              "stages": [
                {
                  "name": "Thaddeus’s Door",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726755558247",
                  "narrative": "At the end of the hall, is the grandest, most intricately carved door in the mansion. The wood is dark and polished, with the crest of the Blackthorn family—an ominous black tree twisted in a circle—emblazoned on its center.",
                  "notes": "The door is locked of course.",
                  "npcs": [],
                  "stages": []
                }
              ]
            },
            {
              "name": "Thaddeus Blackthorn’s Private Chambers",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726695978966",
              "narrative": "Beyond the door to Thaddeus Blackthorn’s private chambers is a stark contrast to the opulence of the rest of the mansion. The room is grand, but there’s a certain coldness to it—no lavish decorations or personal touches, just polished dark wood and expensive furnishings, all meticulously arranged.\n\nThe centerpiece of the room is an imposing mahogany desk, its surface covered in organized stacks of papers, ledgers, and maps. Behind the desk, a large window offers a sweeping view of the moonlit city of Kordavos, though thick velvet curtains are half-drawn, as if to limit just how much can be seen. \n\nAlong the walls are rows of shelves, but instead of books, they hold scrolls and sealed letters, many marked with the insignias of various prominent families, including the Blackthorn and Asterian crests. A glass cabinet in one corner houses rare and valuable trinkets—gems, ornate daggers, and a few peculiar objects that seem out of place, including a small carved wooden idol of Valkaran origin.\n\nTo the side, an ornate sword hangs mounted on the wall, its scabbard adorned with intricate Valkaran symbols. The hilt gleams in the firelight, drawing the eye as if it holds significance beyond mere decoration. A second door, almost hidden behind a heavy tapestry, leads to what seems to be a smaller, more private study.\n\nThis is clearly a place where business is done—deals struck, secrets kept, and plans formed. The atmosphere is thick with ambition and power, and it’s easy to imagine Thaddeus sitting behind the desk, orchestrating his plans to rise further in Kordavos’s political landscape.",
              "notes": "The ornate long sword is lightly enchanted to slightly increase accuracy and damage. ",
              "npcs": [],
              "stages": [
                {
                  "name": "The Desk",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726777118249",
                  "narrative": "The imposing desk in the center of the room is immaculately organized, with a few unremarkable ledgers and papers neatly arranged. However, a small but intricate lock built into one of the desk drawers hints at something more valuable hidden within.\n\nUpon closer inspection, it’s clear that the lock has been custom-designed, crafted by a master locksmith—perhaps even with arcane assistance. The keyhole is lined with faint engravings, barely visible to the untrained eye, and small runes subtly glow when tampered with. This mechanism is a blend of mechanical precision and magical security.",
                  "notes": "The lock on Thaddeus's desk is no ordinary mechanism. If the trap is triggered have the players roll a dexterity check:\n\nWithout warning, an arc of blue lightning crackles and surges from the metal components, leaping out toward anyone standing near. The room is briefly illuminated by an arcane electrical discharge, casting long, jagged shadows on the walls.\n\nIf they take the full damage, it is possible they could be rendered unconscious and wake up in a cell in a secret Blackthorn dungeon.\n\nIf they manage to bypass the lock and trap, either through skilled hands or magic, the drawer slides open to reveal a single, finely bound ledger. The ledger’s cover is made of black leather, and inside, the entries are written in neat, flowing script, detailing secretive transactions between the Blackthorn family and the elves of the Valkarr Forest.\n\nThe records are precise, listing dates, shipments, and the exchange of valuable artifacts—ancient relics from Old Valkara, including weapons, trinkets, and objects of mysterious power. \n\nAmong the listed items, one particular entry stands out: \"The Key of Ilmarin, acquired through negotiation, to be delivered in secret.\" ",
                  "npcs": [],
                  "stages": []
                }
              ]
            },
            {
              "name": "The Wine Cellar",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726777134645",
              "narrative": "Descending the stone staircase, the air grows cooler, carrying with it the faint scent of damp earth and aged wood. The faint hum of the masquerade ball above slowly fades away, replaced by the distant echoes of dripping water and the creak of wooden barrels settling in the darkness below. The staircase is narrow and spirals down into the depths of the Blackthorn mansion, the flickering light of their torches casting long, distorted shadows on the walls.\n\nAt the bottom, they find themselves in a dimly lit corridor that leads to the wine cellar. Rows of old oak barrels are stacked high, alongside shelves lined with bottles of the finest vintages, some covered in dust, their labels faded with age. ",
              "notes": "Allow the characters to plot out their action, then roll a perception check to see if they hear footsteps from the stairway.",
              "npcs": [],
              "stages": [
                {
                  "name": "The Sommelier",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726777163635",
                  "narrative": "The soft patter of footsteps echoes down the stone staircase, accompanied by muted voices. Emerging from the shadows of the upper mansion, the sommelier steps into view—a tall, wiry man with graying hair slicked back neatly, his sharp nose tilted upward as he descends. He wears the crisp, formal attire of the Blackthorn staff, a silver brooch gleaming on his lapel. His thin lips are pursed in mild irritation.\n\nBehind him, a younger servant, shorter but stockier, hurries down the stairs carrying a small notepad and a faint sheen of sweat on her brow. Her round face is flushed from the heat of the ballroom above, and she looks far less composed than the sommelier.\n\n\"I told you, we need the 407 Dronis red for the toast,\" the sommelier snaps impatiently, his tone leaving little room for error. \"It must be perfect.\" He scans the shelves as he enters, eyes narrowing.\n\n",
                  "notes": "There is limited time to make a decision: remain hidden among the barrels, attempt a distraction, or perhaps even bluff their way through the encounter by pretending to be servants or patrons inspecting the cellar.\n\nIf the players manage to have time to properly search the cellar, they may roll to check if they can discover the Hidden Alcove.",
                  "npcs": [
                    {
                      "name": "Clive Stonebrook",
                      "race": "Human",
                      "gender": "Male",
                      "characterClass": "Sommelier",
                      "level": "3",
                      "appearance": "Tall, wiry man with graying hair slicked back neatly. Wears crisp, formal attire of the Blackthorn staff with a silver brooch on his lapel. Has a sharp nose and thin lips, often pursed in mild irritation.",
                      "personality": "Impatient, meticulous, and holds high standards when it comes to his duties. Rarely smiles and expects perfection from those around him.",
                      "abilities": "Knowledge of wines",
                      "characterId": "clive-stonebrook",
                      "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726777234195"
                    },
                    {
                      "name": "Mira Hearthstone",
                      "race": "Human",
                      "gender": "Female",
                      "characterClass": "Servant",
                      "level": 1,
                      "appearance": "Shorter but stockier young woman with a round, flushed face and a faint sheen of sweat on her brow. Wears simple but neat servant attire and carries a small notepad.",
                      "personality": "Nervous, eager to please, and slightly clumsy but hardworking. Looks up to her superiors and is determined to do a good job despite her occasional mistakes.",
                      "abilities": "Diligence, basic knowledge of household tasks, quick learner.",
                      "characterId": "mira-hearthstone",
                      "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726777443914"
                    }
                  ],
                  "stages": []
                },
                {
                  "name": "The Hidden Alcove",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726777363275",
                  "narrative": "Row upon row of bottles line the dimly lit corners of the wine cellar, some covered in a fine layer of dust. Something about the ornate wooden wine rack set against the furthest stone wall feels off. At first glance, it appears like any other rack, holding a variety of expensive and rare vintages. \n\nHowever, upon a closer look, this particular rack seems sturdier, its wooden frame slightly different in color as though newer than the rest. Upon closer examination, they discover that the rack doesn’t sit flush with the stone wall behind it. A faint, almost imperceptible seam runs along the edges, and the dust on the floor reveals subtle scuff marks near its base, as if it had been moved recently.\n\nFurther investigation reveals a hidden latch cleverly disguised as a wine bottle, its label faded and peeling. When the bottle is pulled, there’s a soft click, followed by a low rumbling sound as the entire wine rack shifts slightly. \n\nSlowly, the rack slides away from the wall on hidden tracks, revealing a narrow alcove behind it with a small, but heavily fortified vault door. In the center of the door is a complex lock mechanism of an unusual design—no simple keyhole, but rather an elaborate mechanism with several moving parts that interlock like a puzzle.\n\nIt’s clear that the lock has been custom-designed, crafted by a master locksmith—perhaps even with arcane assistance. The keyhole is lined with faint engravings, barely visible to the untrained eye, and small runes subtly glow when tampered with. This mechanism is a blend of mechanical precision and magical security.",
                  "notes": "If the trap is triggered have the players roll a dexterity check:\n\nWithout warning, an arc of blue lightning crackles and surges from the metal components, leaping out toward anyone standing near. The room is briefly illuminated by an arcane electrical discharge, casting long, jagged shadows on the walls.\n\nIf they take the full damage, it is possible they could be rendered unconscious and wake up in a cell in a secret Blackthorn dungeon.",
                  "npcs": [],
                  "stages": []
                },
                {
                  "name": "Archives of the Drakovan",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726778953924",
                  "narrative": "As the vault door is opened, the air within the small chamber beyond feels cooler, stale as if it hasn’t been disturbed in years. Inside is a meticulously organized archive, the walls lined with shelves containing scrolls, ledgers, and bound volumes, all emblazoned with the sigil of a ‘Drakovan’ family\n\nHere it seems, the secrets of this powerful house lie hidden, with records of ancient dealings, maps of forgotten lands, and documents of alliances that stretch back to a time before the Asterians arrived. The scent of old parchment fills the air, mingling with the faint smell of aged wine, creating an atmosphere thick with forgotten history.",
                  "notes": "The Drakovan archives reveal a darker history of the family, long before they rebranded themselves as the Blackthorn Clan to align with the Asterian settlers. The documents trace their rise to power and wealth through a series of corrupt dealings, shady alliances, and blackmail. The Drakovans were known to form secret pacts with smugglers and bandit groups, leveraging these alliances to undermine their rivals and seize control of key trade routes in the region. They also engaged in illegal land grabs, manipulating local leaders and using forged documents to claim ancestral Valkaran lands. These methods allowed them to amass considerable influence, all while keeping their actions hidden from the public eye.\n\nThe decision to rebrand as the Blackthorn family was a calculated move to cleanse their image and gain favor with the Asterians. However, the archives show that the Drakovans never fully abandoned their ruthless practices. \n\nThese documents would be enough to bring down the entire clan faction should they be brought to the attention of the authorities and the public.",
                  "npcs": [],
                  "stages": []
                }
              ]
            }
          ]
        },
        {
          "title": "Murder in the Mansion",
          "encounters": [
            {
              "name": "The Speech",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726779752897",
              "narrative": "As the adventurers make their way back to the ballroom, the atmosphere has shifted into one of eager anticipation. The lights flicker and dance across the grand hall, casting a warm glow on the elegantly dressed guests. Thaddeus Blackthorn is confidently on the stage, his dark, formal attire gleaming under the chandelier light. His presence commands attention, and the entire room falls silent as he raises his hand, a proud smirk playing across his face.\n\n“Ladies and gentlemen,” Thaddeus begins, his voice booming with the practiced ease of a seasoned leader. “We stand on the brink of greatness. A new era of prosperity awaits those who are bold enough to embrace it. For those who align themselves with the Blackthorns and the Margrave, opportunity and wealth will follow. But,” he pauses for emphasis, his gaze sweeping across the room, “those who cling to outdated traditions will be left behind. The future belongs to those who dare to seize it.”\n\nAs the crowd murmurs in approval, Thaddeus gestures toward the far side of the ballroom. With a flourish, a large curtain is drawn back to reveal the Forest Drake, caged but still impressive in its size and power. The creature's green scales shimmer, its bright eyes surveying the crowd with an intense, predatory focus. \"Behold,\" Thaddeus announces proudly, \"a symbol of the new alliances we've forged with the elves of the Valkarr Forest. Together, we will unlock the ancient secrets of the wilds and bring forth untold riches and power!\"\n\nThe crowd gasps in awe, as the drake towers above, its translucent form shifting and shimmering.",
              "notes": "If the Forest Drake is unavailable, the half-elf Eamon steps forward, his hands weaving intricate patterns in the air. A moment later, an illusion of the Forest Drake takes form—so realistic it almost seems to breathe.",
              "npcs": []
            },
            {
              "name": "Death to the Murderer!",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726789587556",
              "narrative": "As the applause for Thaddeus' grand announcement reaches its peak, a figure in the shadows moves with purpose. Clad in the dark, hooded garb of the Covenant of the Cowl, the assassin has been biding his time, waiting for the perfect moment amidst the excitement and spectacle of the Forest Drake's reveal.\n\nWith a sudden, calculated movement, the assassin breaks from the cover of the crowd gathered near Thaddeus. In one swift motion, a blade plunges into Thaddeus’ side, the assassin hissing, “Death to the murderer of Milos Antonov!” Thaddeus gasps, his eyes wide in shock as the poison begins to work its way through his veins.\n\nChaos erupts. Guests scream and scatter as the assassin spins around, heading for the balcony with deadly speed. The figure vaults over the bannister toward the balcony, a rope already prepared for a quick descent into the darkness below.",
              "notes": "The players have a decision to make. They could give chase, or go to Thaddeus. If they go to Thaddeus, it is possible they could obtain his key. Regardless, there is nothing they can do to help him—he will die.",
              "npcs": []
            },
            {
              "name": "The Chase",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726797856154",
              "narrative": "The ballroom explodes into chaos as the assassin rushes out over the balcony. The cool night air rushes against those who they peer over the edge, catching a glimpse of the hooded figure rapidly descending the rope into the darkened garden below. \n\nBeneath the lush greenery and meticulously maintained flower beds, movement can be spotted as the figure disappears through what appears to be an old drainage grate hidden beneath the ivy. The grate, almost indistinguishable from the garden's stone pathways, swings shut with a soft clang, the mechanism hidden beneath the vines.",
              "notes": "If the assassin is somehow prevented from escaping, he will ingest a cyanide capsule. The underground passage will still be discovered as part of the plot.",
              "npcs": [],
              "stages": [
                {
                  "name": "Dead End",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726797804541",
                  "narrative": "At the end of the narrow, winding passage through which the assassin escaped is a crude wooden door, reinforced with iron bands. Despite its worn appearance, it is sealed impossibly tight. The door seems out of place, its rough craftsmanship in stark contrast to the smooth, ancient stone walls of the tunnel. The faint glow of arcane symbols etched into the wood pulses softly, casting eerie shadows on the walls around it. \n\nA faint hum of magical energy lingers in the air h, the seal shimmering with faint runes, preventing anyone from crossing its threshold. ",
                  "notes": "No matter how hard they push, pull, or attempt to force the door, it remains firmly shut, locked by powerful magic. The assassin has fled beyond this barrier, and without the proper means to dispel the seal, the adventurers find themselves temporarily thwarted in their pursuit.\n\nIn the aftermath of the assassination, the once-celebratory atmosphere in the Blackthorn mansion turns to utter panic. Thaddeus Blackthorn lies lifeless, his body crumpled on the ballroom floor, the dark poison having already claimed his life. Guests scream and rush toward the exits, while guards frantically search for the assassin, who has long since disappeared. \n\nIt is possible that in the chaos that the adventurers could have an opportunity to further explore the interior of the mansion as the guards will have their attention elsewhere.",
                  "npcs": [],
                  "stages": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "The Covenant of The Cowl",
      "plot": "In the aftermath of the murder of Thaddeus Blackthorn, the secret underground network of tunnels has finally been revealed. A powerful ward has sealed the only entrance.\n\nIn reality, the Covenant of the Cowl is created and led by the Valtor family and its allies amongst Valkaran traditionalists. Their tunnel system is secured by doors locked via the magic of the Key of Ilmarin, only accessible to those who know the secret unlocking divination.\n\nLady Astrid will be hellbent on finding her brother’s murderers. If the adventurers cannot devise a way to breach the entrance, Eamon, the half-elf mage, uses a knock spell to dispel the ward.  She will enlist the aid of the adventurers to accompany her, Eamon and Beric into the underground, potentially promising a handsome reward in return. \n\nNavigating the maze will prove challenging as they encounter resistance from Covenant loyalists inside, ancient magical guardians, a giant spider nest and even the undead of old Valkara.\n\nFinally, they reach the inner sanctum where they will confront the leaders of the Covenant. To their surprise, Joran Antonov removes his cowl to reveal himself as the Champion of the Covenant. He accuses Astrid Blackthorn of crimes against the Valkaran people and the murder of his father. \n\nIn this climax of the adventure, the party must decide whether to expose the Valtor Clan’s underground operations, bring down the Covenant to prevent further bloodshed, or support their radical agenda to preserve Valkaran traditions and oppose the powerful Blackthorn family. The fate of Kordavos—and the balance of power between the Valkarans and Asterians—rests in the adventurers’ hands.\n",
      "scenes": [
        {
          "title": "Into the Underground",
          "encounters": [
            {
              "name": "The Hunt for the Assassin",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726868134486",
              "narrative": "Lady Astrid, now clad in her ranger gear, steps through the courtyard with renewed purpose, her dark leathers and cloak a stark contrast to the opulence of the Blackthorn mansion. The fury in her eyes remains undimmed, but her attire reflects the shift from a grieving noble to a hardened hunter. The night is cold, and the moonlight casts long shadows as she leads the adventurers along the assassin's escape route.\n\nNear the edge of the estate, where the assassin had vanished, a familiar figure stands by the hidden entrance to the underground tunnels. No longer the well-mannered half-elf scholar they met at the Dragonbone Inn—his robes now carry the weight of a man deeply entrenched in the mystery of Kordavos.\n\nAstrid strides forward, her movements silent and deadly, her eyes never leaving the warded door. \"Eamon,\" she snaps, addressing the half-elf, her voice low but intense. \"The ward. Break it.\" Eamon nods, his hands already moving in intricate gestures, his voice a steady murmur as he begins to unravel the magical seal.\n\nTurning to the adventurers, Astrid's gaze hardens. \"We’ve wasted enough time. This assassin and the Covenant think they can hide behind magic and shadows. But we will find them. We will deliver justice upon them.\" She pauses, her voice dropping to a growl. \"Help me hunt them down. Thaddeus will not die without vengeance.\"",
              "notes": "Astrid is willing to pay a large sum if asked. She will be desperate to find and end this threat to her family.",
              "npcs": [],
              "stages": [
                {
                  "name": "Unsealing the Entrance",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726872020005",
                  "narrative": "Eamon steps forward, his fingers weaving through the air as he mutters an arcane incantation. The sound of his voice echoes faintly off the stone walls as a shimmer of magical energy ripples across the sealed door. A moment later, a sharp, metallic click reverberates through the air, signaling the release of the lock. Behind him, Astrid’s soldiers stand at attention, their hands gripping the hilts of swords and axes, their faces a mixture of resolve and wariness.\n\nThe warded seal, once glowing with an ethereal light, fades, leaving the door unprotected. Eamon glances at Astrid and the adventurers, his expression tense. \"It’s done,\" he says quietly. \"But whatever’s down there, they won’t be expecting us. Let’s use that to our advantage.\" He steps back as Astrid’s men shift in place, readying themselves for what lies ahead.\n\nAstrid wastes no time. With a nod, she pushes open the door, revealing the dark mouth of the tunnel beyond. The air inside is cool and damp, carrying the musty scent of earth and stone. \"Stay alert,\" she warns, her voice a low whisper as she draws her blade. \"We’ve got the numbers, but they’ve got the advantage. They could be lying in wait. We’re in their territory now.\" She motions to her soldiers to follow her in.",
                  "notes": "",
                  "npcs": [],
                  "stages": []
                }
              ]
            },
            {
              "name": "Into the Catacombs",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726873268984",
              "narrative": "The tunnel stretches on in eerie silence ahead, its long, narrow path carved deep beneath the city. The air is cool and damp, with the faint scent of earth and stone lingering in the stillness. For a while, the parties' careful steps echo softly, but nothing disturbs the peace of the passage. \n\nAfter an initial uneventful exploration, the walls begin to widen slightly, the tunnel opening into a broader section. The dim glow of torchlight flickers ahead, barely visible in the distance. As they draw closer, low voices can be heard, carried by the tunnel’s natural acoustics. \n\nRounding a final bend, they come upon a group of hooded figures from the Covenant of the Cowl. The figures move swiftly, carefully positioning large barrels along the walls. One of them kneels to the ground, tending to a long fuse that snakes across the floor, its end glowing with a faint spark. They work in tense silence, unaware of the adventurers’ approach.\n\nA voice ahead mutters, “Hurry. It’s almost ready. Light the fuse. We’ll collapse the tunnel and seal it behind us.”",
              "notes": "In this encounter, the adventurers have to navigate a tunnel set to be collapsed by members of the Covenant. If the party chooses a stealthy approach, they may overhear the Covenant members discussing their plan to detonate the tunnel. This gives them a chance to gain the upper hand and prevent the collapse before it happens. Successful *Stealth* checks will allow the adventurers to surprise their foes, while a failed check alerts the Covenant, who will immediately attempt to light the fuse. A quick, decisive action or disabling spells can stop the fuse before it's fully lit.\n\nIf the adventurers decide to engage the Covenant in open combat, the enemies will prioritize lighting the fuse as they defend themselves. One Covenant member is tasked with igniting the explosives, creating a race against time. The party will have the chance to stop the fuse from being lit or disarm it before the collapse occurs. If the fuse is lit, the adventurers face a ticking clock scenario, requiring them to act fast. Disarming the explosives may require a *Sleight of Hand* or *Arcana* check, or the use of magic such as *Mage Hand* or *Dispel Magic*. Failure in disarming the explosives will lead to a tense moment as the fuse burns toward detonation.\n\nIf the fuse reaches its end, the adventurers will have to choose between attempting a last-ditch effort to disarm it or escaping the tunnel before it collapses. A successful escape will require *Athletics* or *Dexterity* checks as they flee the explosion. Should the adventurers partially mitigate the damage, the tunnel may only collapse in part, allowing them to move forward with difficulty. However, a complete failure means the tunnel collapses entirely behind them, forcing the party deeper into the unknown. The stakes of this encounter are high, and the adventurers will feel the weight of each decision, knowing that failure could result in being trapped underground or losing their lead in the investigation.",
              "npcs": []
            },
            {
              "name": "Through the Labyrinth",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726950403113",
              "narrative": "Past the detonation point, the tunnel branches, then again, and again. Each fork leads to another, one blending into the next, with walls that look eerily similar and no obvious landmarks to guide their way. The air is damp, carrying a faint metallic tang. Some tunnels seem freshly dug, while others seem very old, forgotten by time.\n\n“Too many turns,” Astrid mutters in frustration, her brow furrowed as she looks down each corridor. “It’s designed to lose anyone who isn’t supposed to be down here.” \n\nDetermined, she glances back at her men. “Split up,” she commands. “Take smaller teams and explore each of these tunnels. Report back if you find anything of importance. We’ll cover more ground this way.” Without hesitation, several groups of soldiers break off and head down different passageways, their footsteps quickly fading into the distance.\n\nEamon pauses, running his fingers along faint markings on the walls. “The Covenant wanted to make sure no one found their way without help. But magic leaves traces... and I can still sense that there is a core center of power.” As they move deeper, passing through secret entrances leading to hidden chambers beneath noble estates and prominent guildhouses, it becomes clear that the Covenant uses this network for more than smuggling—it’s a web of surveillance. After a sharp turn, the reduced party comes to a dead end, the shadows pressing in around them.",
              "notes": "Perception or Investigation checks to uncover subtle clues about their surroundings. A successful check will reveal faint magical etchings along the walls, which an Arcana check can confirm are part of a surveillance network. These runes are used by the Covenant to spy on important locations in Kordavos, including the City Council chambers. If the players make the connection, they’ll realize the tunnels are not just for smuggling but are integral to the Covenant’s efforts to monitor key figures in the city.\n\nEamon might mutter, \"These runes aren’t just for decoration… they’re transmitting information. The City Council is being watched.\" If the players investigate further, they’ll realize the tunnels serve not just for smuggling but for spying on powerful figures in Kordavos. Astrid, studying the wall, might add, “Thaddeus never saw this coming… the Covenant has eyes everywhere.”",
              "npcs": []
            },
            {
              "name": "The Sealed Door",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726951147257",
              "narrative": "After what feels like hours of navigating the endless maze of tunnels, the path narrows and ends abruptly at a large, ancient door. Marked with glowing sigils that pulse with arcane power, the door radiates an oppressive, magical force. The air grows colder as they approach, the sigils casting eerie reflections on the stone walls.\n\n“This is it,” Astrid says, her voice steady but grim. “Whatever the Covenant’s been hiding, it’s through that door.”\n\nEamon steps forward, examining the intricate runes etched into the door’s surface. “A powerful seal, just like the last. There is a pattern at work here. I should be able to bypass it like the last, but breaking this will not go unnoticed,” he warns the group.",
              "notes": "",
              "npcs": [],
              "stages": []
            },
            {
              "name": "Big Empty",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726951960914",
              "narrative": "The arcane seal dissolves, and the heavy stone door creaks open with a deep rumble, revealing... nothing. Beyond the threshold is a vast, cavernous chamber, its emptiness an anticlimax after the intricate secrecy that guarded it. The ceiling arches high into the darkness, while the rough-hewn stone walls, worn and weathered, suggest great age. At the far end of the chamber, barely visible in the gloom, a narrow passageway leads deeper into the unknown. No treasure, no immediate enemies—just a desolate, echoing space that seems to mock their efforts.\n\nAstrid steps forward, her brow furrowed. \"All this... for *this*?\" she mutters, her voice tinged with frustration. Eamon moves to her side, carefully studying the walls. \"It doesn’t make sense,\" he says, his voice low and thoughtful. \"The Covenant went through great lengths to hide this place... but why? There’s nothing here.\" His eyes shift toward the far exit. \"Perhaps we haven’t seen everything yet.\"",
              "notes": "The players may feel compelled to explore the chamber, searching for anything that would explain its significance. A careful investigation might reveal faint scuff marks on the floor or slight indentations in the walls, suggesting that something large was once stored here but has since been moved. The echoes of their footsteps reinforce the strange emptiness, a hollow reminder of something ancient, now gone.",
              "npcs": [],
              "stages": [
                {
                  "name": "Ancient Undead",
                  "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726954368228",
                  "narrative": "As footsteps echo in the eerie silence of the cavernous chamber, the ground feels unsettlingly soft. Suddenly, the earth shifts ever so slightly. Without warning, a skeletal hand bursts through the surface, its cold, bony fingers reaching for the living. A low, unnatural groan reverberates through the chamber as another skeletal hand breaks through—then another, and another.\n\nThe air grows thick with the musty scent of decay. These are not ordinary undead; their bones are adorned with remnants of old Valkaran armor, rusted but still recognizable. Each figure bears the markings of an ancient time, their cracked skulls and hollow eyes glowing with a faint, unnatural light. These are the cursed remnants of Old Valkara, rising from the grave.\n\nAstrid’s eyes widen in shock as she draws her blade, its steel gleaming in the dim light. \"We’ve been led into a trap!\" she shouts, her voice cutting through the mounting chaos.  The chamber fills with the sound of cracking bones as the army of ancient undead rises from beneath.",
                  "notes": "These skeletons are not particularly powerful individually, but they keep coming, forcing the party to think strategically about how to deal with them before becoming overwhelmed. They will not leave the chamber.",
                  "npcs": [],
                  "stages": []
                }
              ]
            }
          ]
        },
        {
          "title": "The Inner Sanctum",
          "encounters": [
            {
              "name": "Forgotten Temple",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726955916736",
              "narrative": "Astrid wipes the grime from her blade, her eyes narrowing with determination. \"We’re close. The ancient undead were protecting something important.\"\n\nThe narrow, rough-hewn stone passage begins to widen, its texture and shape gradually changing. The crumbling walls give way to smooth, intricately carved stonework, and the air becomes thick with the musty scent of forgotten history. Faded runes and symbols, barely discernible under centuries of grime, begin to appear, etched into the stonework.\n\nAstrid’s voice breaks the heavy silence. She exhales slowly, her eyes wide with both awe and disbelief. \"A lost temple of old Valkara,\" she murmurs, her voice barely above a whisper, \"underneath the city all this time, just waiting to be discovered.\"\n\nTowering pillars frame an arched doorway, their surfaces etched with intricate runes and faded depictions of Valkaran heroes long forgotten. The massive stone door stands partially ajar, revealing only darkness beyond. The carvings on its surface, once vibrant and telling stories of Valkara’s golden age, are now worn down by centuries of erosion. \n\nThe air here is thick with the weight of forgotten history, and a palpable tension fills the musty underground air. ",
              "notes": "",
              "npcs": []
            },
            {
              "name": "Final Confrontation",
              "image": "https://s3.us-east-1.amazonaws.com/d20-public/images/d20/1726970504298",
              "narrative": "Inside the ancient temple, darkness swallows everything. The air is thick, cold, and utterly still, as if the stone walls themselves are holding their breath. For a moment, there is nothing but the muffled sound of footsteps as the adventurers cautiously step inside, their eyes straining against the oppressive blackness. The sense of foreboding grows with each passing second.\n\nThen, with a sharp flick, a torch is lit. Its flickering flame casts long, dancing shadows against the cold stone walls, revealing the vast interior of the temple. Standing at the center of the grand hall, cloaked in the dim glow of the torch, is a figure draped in dark robes, the unmistakable insignia of the Covenant of the Cowl visible on their chest. Their hood is pulled low, hiding their features, but the voice that greets the adventurers is unnervingly calm, almost welcoming.\n\n\"Welcome,\" the figure says, stepping forward with measured grace. \"I’ve been expecting you. In fact, I’ve been looking forward this for quite some time.\" There’s satisfaction in his voice, as if this moment was all part of a plan unfolding exactly as intended.\n\nAs the figure speaks, more torches ignite around the chamber, one after another. The faint hiss of fire reveals shadowed figures standing at the perimeter, each one cloaked in the same dark robes, their faces obscured but their presence unmistakable. The room, once dark and empty, now pulses with an ominous energy as more members of the Covenant of the Cowl step forward. Silent and foreboding, they watch with cold intensity, their numbers slowly revealed in the flickering torchlight.\n\n\"You see, you’ve walked right into the heart of it. And now, you stand before those who have shaped everything you’ve encountered. There is no escape. The only question now is… what will you do?\"",
              "notes": "",
              "npcs": [],
              "stages": [
                {
                  "name": "Joran Antonov",
                  "image": "",
                  "narrative": "As the flickering torches illuminate the vast temple, the tension in the air becomes almost suffocating. Astrid, her posture rigid and her eyes ablaze with defiance, steps forward. Her men, loyal and ready, gather behind her, their weapons drawn. The Blackthorn soldiers fan out, their armor gleaming in the low light, creating a stark contrast to the shadowy, robed figures of the Covenant of the Cowl.\n\nAstrid’s voice cuts through the tense atmosphere like a blade, sharp and resolute. “You think this ends with some pathetic show of force? You underestimate the strength of the Blackthorn family.” She glares at the hooded figure at the center of the chamber. “We’ve built our power through blood and fire, and we will not be brought down by your cowardice.”\n\nAt that, the cloaked figure at the center steps forward. Slowly, the figure pulls back his hood, revealing his face. There is no mistaking who he is.\n\nHis eyes lock with Astrid’s, cold and filled with a vengeful fire. “Cowardice?” His voice is calm, measured, but laced with contempt. “I’ve had the courage to do what needed to be done. Thaddeus was a parasite, preying on our people, exploiting our history.” He pauses, allowing the weight of his words to hang in the air. Then, with a chilling smile, he adds, “And I know you stole my father’s journal, Astrid. That was my legacy, not yours.”\n\nAstrid’s grip tightens on her sword as she steps forward, her face set in a mask of fury. “Your father was a fool. And you? You’re just a puppet for the Valtors. Do you even realize what you’ve done?” She gestures to the adventurers, a mixture of desperation and fury in her voice. “These people deserve better than your lies and betrayal.”\n\nJoran takes a step closer, his eyes scanning the group of adventurers at Astrid’s side, who were also allied with his sister. \n\n“It’s time to choose. The Blackthorn’s hunger for power will destroy Valkara. Join me, and we can rebuild our people and purge the Asterian interlopers. Or stand with Astrid and be crushed under the weight of their greed.” His gaze shifts back to Astrid, the tension crackling between them like lightning. ",
                  "notes": "The adventurers now stand at a crossroads, watching the scene unfold. Both sides have laid bare their intentions, and the choice before them feels heavier than ever. Astrid, defiant and proud, leads the Blackthorn family with a ruthless determination. Joran, driven by vengeance and the pursuit of his father’s legacy, has revealed the depths of the Covenant’s influence.\n\nWill they stand with the Blackthorns, preserving the fragile alliance with the Asterians and securing their own wealth and power? Or will they side with Joran, embracing the Covenant’s vision of an independent Valkara—at any cost?",
                  "npcs": [],
                  "stages": []
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "summary": "The March of Davos is a land of contrasts and conflicts, where the ancient traditions of the Valkaran people clash with the ambitions of the Asterian Empire. Nestled in the southern regions of Thylún, this rugged frontier is a place of wild beauty and hidden dangers. The capital city, Kordavos, stands as a beacon of civilization on the edge of the untamed lands, a bustling port where cultures and ideas converge. It is a place where adventurers are drawn by the promise of fortune and the allure of secrets waiting to be uncovered at the edge of civilization and wild ancient land.\n\nInside the gates, travelers and locals alike gather at the annual Valkaran Harvest Festival, and tension between rival clan factions erupts, drawing the adventurers into the fray. Afterward, as they settle in at a tavern, their intervention catches the attention of several locals. \n\nThey are approached by a half elf named Eamon and his bodyguard Beric and presented with the opportunity to investigate a missing shipment at the docks. \n\nLater in the morning, they encounter another in need. An acquaintance of the innkeeper, Elara Antonov is a desperate woman who pleads for their help in finding her missing brother, Joran, who was obsessed with finding the truth about their father’s mysterious death.\n\nAs they pursue these quests, navigating the labyrinthine streets and eclectic districts of Kordavos, they draw the attention of three powerful clan families.\n\nThe Valtor Clan, led by the formidable Matriarch Seraphina Valtor, is deeply connected to ancient Valkaran traditions and the Valkaran Church. The family controls vast forests around Kordavos and fiercely defends their ancestral lands. They are often at odds with the Asterian settlers, whom they see as desecrators of the natural world. Their influence in the city extends through green spaces and a network of rangers and druids who safeguard Valkaran interests.\n\nThe Blackthorn Clan, led by Patriarch Thaddeus Blackthorn, has embraced the Asterian way of life and become one of the wealthiest families in Kordavos. Originally known as Drakovan, a traditional Valkaran family name, they rebranded themselves as Blackthorn to align more closely with Asterian customs and gain favor with the Empire’s elite. The family controls key trade routes and merchant fleets, using their wealth and political clout to influence decisions in the city. Their mansion stands as a symbol of opulence and power at the heart of Kordavos.\n\nThe Raskov Clan, known for their opportunism, walks the line between Valkaran traditions and Asterian influence. They are expert manipulators, often playing both sides for personal gain. In the shadows, they operate as smugglers and traders, with deep connections in the city’s underworld and political circles. Initially, suspicion for the missing shipment falls on the Raskov Clan due to their history of shady dealings.\n\nAs the investigation deepens, the adventurers begin to uncover cryptic symbols and mysterious clues pointing to a secretive organization known as the Covenant of the Cowl that seems to have orchestrated the theft, but it’s unclear whom they serve. They operate in the shadows, manipulating events in Kordavos for reasons unknown. Many suspect they are aligned with the Raskov Clan, given its history of working in the underworld.\n\nThrough investigation and a series of dangerous encounters, the adventurers eventually find themselves invited to a masquerade ball hosted by the Blackthorn Clan, where they have a chance to gather intelligence from the city’s elite. During the event, the adventurers must navigate political intrigue, question alliances and probe for more clues.\n\nA shocking murder at the ball leads to the revelation that the Covenant has established an underground network of tunnels for the purposes of operating in secret and conducting espionage throughout the city.\n\nNot merely a rogue faction, the Covenant of the Cowl is secretly the underground wing of the Valtor Clan. Its true purpose is to maintain Valkaran dominance by undermining the Blackthorns’ alignment with the Asterians and any foreign influence in Kordavos. They stole the shipment to gain the upper hand and disrupt the Asterians' control.\n\nElara’s missing brother Joran becomes central to the plot. Once torn between his loyalty to his family’s traditional values and the darker methods of the Covenant, he determined that his father Milos had been murdered by the Blackthorn family in order to rob him of his research into ancient Valkaran lore.\n\nInitially believed to be a victim, he has in fact been indoctrinated and trained as a paladin of the old ways of Valkara and now, holding the Key of Ilmarin, is the operational leader of Covenant operations. It was Joran who organized the operation to betray Kazimir “Silverhand” Raskov and steal the Key of Ilmarin, an artifact that has the power to magically secure or unlock openings of any kind.\n\nIn this climax of the adventure, the party must decide whether to expose the Valtor Clan’s underground operations, bring down the Covenant to prevent further bloodshed, or support their radical agenda to preserve Valkaran traditions and oppose the powerful Blackthorn family. The fate of Kordavos—and the balance of power between the Valkarans and Asterians—rests in the adventurers’ hands.\n"
}

/*
  File: data/the-midnight-summons.json
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/data/the-midnight-summons.json
  Directory: data
*/

--- File: data/the-midnight-summons.json ---

{
  "id": "the-midnight-summons",
  "settingId": "realm-of-myr",
  "title": "The Midnight Summons",
  "author": "D20Adventures",
  "version": "1716220800",
  "teaser": "A mysterious summons from an old druid friend draws a reclusive ranger into the wilds of the Valkarr forest.",
  "overview": "Thalbern, a ranger of the Valkarr woods, is called upon by his old friend, the druid Wollandora, to meet him at the Old Standing Stones at midnight. The balance of the forest could depend on it.",
  "party": [1, 1],
  "image": "images/settings/realm-of-myr/the-midnight-summons/the-midnight-summons.png",
  "sections": [
    {
      "title": "Journey to the Standing Stones",
      "summary": "Thalbern receives an urgent message and ventures to meet the druid Wollandora, facing an unexpected danger along the way.",
      "image": "",
      "scenes": [
        {
          "title": "Path Through The Dark Forest",
          "summary": "Thalbern answers Wollandora's call, navigating the dark forest towards the ancient meeting place.",
          "image": "",
          "encounters": [
            {
              "id": "broken-silence",
              "title": "Broken Silence",
              "intro": "Thalbern, a solitary ranger of the Valkarr woods, has always trusted the silence of the wilds more than the promises of men. Orphaned by border raiders and raised by the elves of the Valkrarr Forest, he has spent years living on the edge of Kordavos, guiding travelers, hunting for his own survival, and keeping his distance from the tangled politics of the city.\n\nYet on this night, a message delivered by a red squirrel bearing the unmistakable script of Wollandora, a trusted elven friend and druid, has drawn him from his hidden home. The note was simple and urgent: Meet me at the Old Standing Stones at midnight. The balance of the forest could depend on it.\n\nNow, as midnight approaches, Thalbern moves quietly through the dense undergrowth, guided by memory and instinct. It is dark with almost no moonlight coming through the forest canopy.\n\nSuddenly, the hush of the night is broken by a sharp crack. Something large has just stepped on a branch somewhere off in the distance.",
              "instructions": "A perception check is appropriate if Thalbern investigates (low difficulty with a plus 3 modifier). If successful, he will determine it is a large creature that is approaching quickly. With a high roll (18+), he will determine it is an Owlbear. If combat ensues and Thalbern is below 25% health, Wollandora will intervene. If Thalbern avoids or defeats the Owlbear, or if Wollandora saves him, he proceeds to the Old Standing Stones.",
              "image": "images/settings/realm-of-myr/the-midnight-summons/broken-silence-2.png",
              "transitions": [
                {
                  "condition": "If Thalbern successfully rolls to hide or evade and can avoid the Owlbear, go to meeting-at-the-stones.",
                  "encounter": "meeting-at-the-stones"
                },
                {
                  "condition": "If Thalbern fails any dice roll (including stealth, perception, or any other check) or does nothing requiring a roll, advance to owlbear-confrontation.",
                  "encounter": "owlbear-confrontation"
                },
                {
                  "condition": "If Thalbern has a healthPercent of less than 50%, go to wollandora-intervention.",
                  "encounter": "wollandora-intervention"
                }
              ]
            },
            {
              "id": "owlbear-confrontation",
              "title": "Owlbear Confrontation",
              "intro": "From the direction of the sound, a little bit of eye shine glints in the shadows of the tree line. A hulking fifteen foot tall monster with the body of a giant bear and the head of an owl. As it crashes out from the undergrowth, it lets out a guttural squawk, clearly agitated and territorial.",
              "instructions": "The Owlbear will attack. If Thalbern attempts an animal handling check (high difficulty) and succeeds, he can move past the Owlbear. If Thalbern wins initiative and attempts to hide, he can move past the Owlbear if he passes a medium difficulty stealth check. If Thalbern's health drops to a critical level, Wollandora appears and drives off the Owlbear, transitioning to 'wollandora-intervention'. If Thalbern defeats the Owlbear, describe his victory and transition to 'meeting-at-the-stones'.",
              "image": "images/settings/realm-of-myr/the-midnight-summons/owlbear-confrontation.png",
              "npc": [
                {
                  "id": "owlbear",
                  "behavior": "Aggressively attacks any perceived threat. Will fight until heavily wounded or driven off.",
                  "initialInitiative": 1
                }
              ],
              "transitions": [
                {
                  "condition": "Thalbern defeats the Owlbear, manages to evade it, successfully uses Animal Handling to pacify and move past it, or successfully rolls any other way to move past it.",
                  "encounter": "meeting-at-the-stones"
                },
                {
                  "condition": "Thalbern is reduced to critical health by the Owlbear.",
                  "encounter": "timely-rescue"
                }
              ]
            },
            {
              "id": "timely-rescue",
              "title": "Timely Rescue",
              "intro": "Just as the Owlbear is about to land a seemingly final blow, a shaft of silvery moonlight pierces the canopy. A calm, authoritative voice calls out, 'That's enough, beast of the wood!' Wollandora steps from the shadows, her staff glowing faintly. With a gesture and a word of power, she unleashes a wave of natural energy that stuns and drives the startled Owlbear back into the depths of the forest.",
              "instructions": "Wollandora quickly checks on Thalbern's condition. She'll offer a brief comment ('You look like you've seen better nights, ranger. Come, the stones are not far, and our business is urgent.'). She then leads him to the Standing Stones.",
              "image": "images/settings/realm-of-myr/the-midnight-summons/timely-rescue.png",
              "npc": [
                {
                  "id": "wollandora",
                  "behavior": "Protective of Thalbern, focused on getting to the meeting."
                }
              ],
              "transitions": [
                {
                  "condition": "Thalbern is able to go to the Standing Stones with Wollandora.",
                  "encounter": "meeting-at-the-stones"
                }
              ]
            },
            {
              "id": "meeting-at-the-stones",
              "title": "Meeting at the Stones",
              "intro": "Thalbern arrives at the ancient Standing Stones. The air is thick with anticipation as the moonlight bathes the clearing in a silvery glow.\n\n\"Thalbern, thank you for coming. The forest is grateful for your swiftness,\" Wollandora intones, her voice echoing softly in the stillness. The wise elf's silver hair glistens in the moonlight, and her eyes are a deep forest green, wise and kind, but currently troubled.",
              "instructions": "Write dialogue for Wollandora as she explains the situation. She should say: \"Thalbern, we have a problem. I received word from a friend from Faelandar, Eldoria, Sylvandor, and Oakhaven. Some Valkaran relics from the elves' vaults have gone missing. Items that should never leave these woods.\" She nods toward the river, where the current glides past the standing stones. \"I saw a river boat, Valkaran-made, heading downstream to Kordavos. You must go to the city and investigate - find these relics before they disappear forever.\" Wollandora should NOT offer any transportation, boats, or assistance beyond information. She only provides the mission details and urges Thalbern to act. If Thalbern asks for further information about the relics, the boat, or Kordavos, this will trigger a transition to 'the-missing-relics' for more details. Once he is ready to accept or decline the overall mission, other transitions apply (e.g., to 'preparing-for-the-city' or 'back-home').",
              "image": "images/settings/realm-of-myr/the-midnight-summons/meeting-at-the-stones.png",
              "skipInitialNpcTurns": true,
              "npc": [
                {
                  "id": "wollandora",
                  "behavior": "Concerned about the missing relics, focused on getting Thalbern to investigate in the city.",
                  "initialInitiative": 1
                }
              ],
              "transitions": [
                {
                  "condition": "If Thalbern accepts or the mission",
                  "encounter": "preparing-for-the-city"
                },
                {
                  "condition": "If Thalbern refuses the mission",
                  "encounter": "back-home"
                },
                {
                  "condition": "If Thalbern asks for more information",
                  "encounter": "the-missing-relics"
                }
              ]
            },
            {
              "id": "the-missing-relics",
              "title": "The Missing Relics",
              "intro": "",
              "instructions": "Wollandora can offer the following info:\n\nAs ancient Valkaran artifacts, deeply connected to the history and spirit of the Valkarr Forest, it is possible they could hold forgotten lore or possess secret untapped powers. The elves have kept them safe for centuries, to maintain the balance of the forest. She can allude to hearing about the rise of powerful figures in the human city who have little respect for the old ways or the forest. Somehow the elves have been drawn into the tangled politics and the relics have been stolen. \n\nWollandora remains focused on getting Thalbern to investigate in the city and **will NOT offer any transportation, boats, or assistance beyond this information**",
              "image": "images/settings/realm-of-myr/the-midnight-summons/meeting-at-the-stones.png",
              "skipInitialNpcTurns": true,
              "npc": [
                {
                  "id": "wollandora",
                  "behavior": "Focused on getting Thalbern to agree to investigate in the city. \"The hour is late and the trail grows cold. Will you take on this task?\"",
                  "initialInitiative": 1
                }
              ],
              "transitions": [
                {
                  "condition": "If Thalbern accepts or the mission",
                  "encounter": "preparing-for-the-city"
                },
                {
                  "condition": "If Thalbern refuses the mission",
                  "encounter": "back-home"
                }
              ]
            },
            {
              "id": "preparing-for-the-city",
              "title": "Preparing for the City",
              "intro": "The following morning, bathed in the soft light of the forest, Thalbern is back at his secluded home. Wollandora's words from the previous night echo in his mind – the stolen relics, the suspicious shipment, the urgent need to investigate in Kordavos.\n\nThe city's tangled ways are far from the quiet paths he knows. Thalbern carefully packs a change of simple, unassuming clothes, ensuring his hunting bow and a quiver of arrows were discreetly bundled, alongside a smaller hand axe and knife. As the sun climbed higher, he left the quiet security of his forest home, turning his steps towards the distant, bustling spires of Kordavos, a place where his survival instincts would be tested in a different kind of wilderness.",
              "instructions": "Thalbern should be fully healed from any wounds or fatigue from the previous night.",
              "image": "images/settings/realm-of-myr/the-midnight-summons/preparing-for-the-city.png",
              "notes": "This encounter serves as a narrative bridge and allows the player to make small, character-flavoring decisions before the next main section of the adventure.",
              "resetHealth": true
            },
            {
              "id": "back-home",
              "title": "Back home",
              "intro": "The following morning, bathed in the soft light of the forest, Thalbern is back at his secluded home. Wollandora's words from the previous night echo in his mind – the stolen relics, the suspicious shipment, the urgent need to investigate in Kordavos.\n\nHe had turned down her request for his help.\n\nHad he made the right choice? He did not enjoy the city, but Wollandora's claims of stolen relics were intriguing. Perhaps a trip to the city would prove tobe worth it.",
              "instructions": "",
              "image": "images/settings/realm-of-myr/the-midnight-summons/back-home.png",
              "notes": "This encounter serves as a narrative bridge and allows the player to make small, character-flavoring decisions before the next main section of the adventure.",
              "resetHealth": true
            }
          ]
        }
      ]
    }
  ],
  "allowCustomPlayerCharacters": false,
  "premadePlayerCharacters": [
    {
      "id": "thalbern",
      "type": "pc",
      "name": "Thalbern",
      "image": "/images/characters/demo-ranger.png",
      "archetype": "Ranger",
      "race": "Human",
      "gender": "Male",
      "appearance": "Lean, weathered, with sharp green eyes and long, tangled brown hair. Wears a cloak of forest hues and carries a longbow.",
      "personality": "Solitary, cautious, loyal to those who earn his trust, and deeply connected to nature.",
      "background": "Orphaned by border raiders, raised by elves in the Valkarr forest. Lives on the edge of Kordavos, guiding travelers and hunting for survival.",
      "motivation": "To protect the forest and its people from outside threats, and to find a place where he truly belongs.",
      "behavior": "Prefers silence and observation, avoids city politics, acts decisively when the wilds are threatened.",
      "healthPercent": 100,
      "equipment": [
        { "name": "Longbow", "description": "A finely crafted elven bow, silent and deadly." },
        { "name": "Quiver", "description": "A quiver filled with arrows." },
        { "name": "Sword", "description": "A practical blade for close encounters." },
        { "name": "Dagger", "description": "A small blade for quick strikes." }
      ],
      "skills": ["Stealth", "Tracking", "Archery", "Survival", "Nature Lore"],
      "attributes": {
        "strength": 13,
        "dexterity": 17,
        "constitution": 13,
        "intelligence": 11,
        "wisdom": 13,
        "charisma": 10
      }
    }
  ],
  "npcs": {
    "wollandora": {
      "id": "wollandora",
      "type": "npc",
      "name": "Wollandora",
      "archetype": "Druid",
      "race": "Elf",
      "gender": "Female",
      "appearance": "A wise elf with silver hair braided with leaves and twigs. Her eyes are a deep forest green, wise and kind, but currently troubled. She carries a staff of gnarled oak.",
      "personality": "Wise, patient, deeply connected to nature, fiercely protective of the forest balance.",
      "background": "An ancient guardian of the Valkarr woods, a friend to Thalbern, and a powerful druid.",
      "motivation": "Recover the stolen relics and restore balance to the forest. Protect the secrets of her people.",
      "behavior": "Generally calm and thoughtful. Will provide information and guidance. Can be firm when necessary.",
      "image": "/images/settings/realm-of-myr/the-midnight-summons/npcs/wollandora.png",
      "healthPercent": 100,
      "attributes": {
        "strength": 10,
        "dexterity": 12,
        "constitution": 12,
        "intelligence": 16,
        "wisdom": 18,
        "charisma": 14
      },
      "status": ""
    },
    "owlbear": {
      "id": "owlbear",
      "type": "npc",
      "name": "Owlbear",
      "archetype": "Monster",
      "race": "Owlbear",
      "appearance": "A hulking monstrosity with the body of a bear and the head of an owl. Thick, matted fur, razor-sharp talons, and a powerful beak. Its eyes glow with a feral intensity.",
      "personality": "Territorial, aggressive, primal.",
      "motivation": "Defend its territory, hunt for food.",
      "behavior": "Attacks perceived threats on sight. Fights with ferocity. Can be driven off by overwhelming force or a display of superior power.",
      "image": "/images/settings/realm-of-myr/the-midnight-summons/npcs/owlbear-portrait.png",
      "healthPercent": 100,
      "attributes": {},
      "status": ""
    }
  }
}

/*
  File: eslint.config.mjs
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/eslint.config.mjs
  Directory: .
*/

--- File: eslint.config.mjs ---

import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
  {
    ignores: [
      ".next/**/*",
      "test-results/**/*",
      "tests-examples/**/*",
      "tests/**/*",
      "coverage/**/*",
      "dist/**/*",
      "build/**/*",
      "**/node_modules/**/*",
      "**/*.min.js",
      "**/*.bundle.js"
    ],
    rules: {
      // Disable noisy rules
      "@typescript-eslint/no-this-alias": "off",
      "react-hooks/exhaustive-deps": "off",
      
      // Enable max-lines rule
      "max-lines": ["error", {
        max: 500,
        skipBlankLines: true,
        skipComments: true
      }]
    }
  }
];

export default eslintConfig;


/*
  File: lib/ai/index.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/ai/index.ts
  Directory: lib/ai
*/

--- File: lib/ai/index.ts ---

"use server"

import { generateObject as baseGenerateObject, streamObject as baseStreamObject, generateText as baseGenerateText } from "ai";
import { geminiModel } from "./llm";
import { auth } from "@clerk/nextjs/server"
import { z } from "zod";
import { decrementUserTokensAction } from "@/app/_actions/tokens";

// Helper function to wait for a specified number of milliseconds
function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Wrapper: uses geminiModel by default, but allows override
export async function generateObject<T extends z.ZodTypeAny>({prompt, schema}: { prompt: string; schema: T; }) {
  let result;
  try {
    const { userId } = await auth()

    if (!userId) {
      throw new Error("User not authenticated");
    }

    result = await baseGenerateObject({
      prompt,
      schema,
      model: geminiModel,
    });

    console.log('generateObject:', result.object);

    if (result.usage && result.usage.totalTokens > 0) {
      console.log('Token Usage (generateObject):', {
        tokensInputOutputRatio: result.usage.promptTokens/result.usage.completionTokens,
        totalTokens: result.usage.totalTokens,
        model: geminiModel.modelId,
      });
      const tokenDecrementResult = await decrementUserTokensAction({
        tokensUsed: result.usage.totalTokens,
        transactionType: "usage_generate_object",
        modelId: geminiModel.modelId,
      });

      if (!tokenDecrementResult.success) {
        console.error("Token decrementation failed for generateObject:", tokenDecrementResult.error, tokenDecrementResult.details);
        let errorMessage = '';
        if (tokenDecrementResult.details instanceof Error) {
          errorMessage = tokenDecrementResult.details.message;
        }
        if (errorMessage.includes("Insufficient tokens")) {
          throw new Error(`Insufficient tokens for generateObject operation. Usage: ${result.usage.totalTokens}.`);
        }
        throw new Error("Failed to update token balance after generateObject operation.");
      }
    }

    return result;
  } catch (error) {
    console.warn('generateObject failed. Error details:', error);
    console.warn('Retrying generateObject in 2 seconds...');
    await sleep(2000);
    
    // Retry once
    try {
      result = await baseGenerateObject({
        prompt,
        schema,
        model: geminiModel,
      });

      console.log('generateObject (retry) raw result:', result);

      if (result.usage && result.usage.totalTokens > 0) {
        console.log('Token Usage (generateObject retry):', {
          tokensInputOutputRatio: result.usage.promptTokens/result.usage.completionTokens,
          totalTokens: result.usage.totalTokens,
          model: geminiModel.modelId
        });
        const tokenDecrementResultRetry = await decrementUserTokensAction({
          tokensUsed: result.usage.totalTokens,
          transactionType: "usage_generate_object",
          modelId: geminiModel.modelId,
        });

        if (!tokenDecrementResultRetry.success) {
          console.error("Token decrementation failed for generateObject (retry):", tokenDecrementResultRetry.error, tokenDecrementResultRetry.details);
          let errorMessage = '';
          if (tokenDecrementResultRetry.details instanceof Error) {
            errorMessage = tokenDecrementResultRetry.details.message;
          }
          if (errorMessage.includes("Insufficient tokens")) {
            throw new Error(`Insufficient tokens for generateObject operation (retry). Usage: ${result.usage.totalTokens}.`);
          }
          throw new Error("Failed to update token balance after generateObject operation (retry).");
        }
      }
      
      return result;
    } catch (retryError) {
      console.error('generateObject retry also failed. Error details:', retryError);
      throw retryError; // Re-throw the error from the retry attempt
    }
  }
}

// Wrapper for streamObject: uses geminiModel by default, but allows override
export async function streamObject<T extends z.ZodTypeAny>({prompt, schema}: { prompt: string; schema: T; }) {

  const { userId } = await auth()

  if (!userId) {
    throw new Error("User not authenticated");
  }

  return baseStreamObject({
    prompt,
    schema,
    model: geminiModel,
  });
}

// Wrapper for generateText: uses geminiModel by default, but allows override
export async function generateText({prompt}: { prompt: string; }) {
  let result;
  try {
    console.log('Entering generateText...');

    const { userId } = await auth()

    if (!userId) {
      throw new Error("User not authenticated");
    }

    result = await baseGenerateText({
      prompt,
      model: geminiModel,
    });

    console.log('generateText result:', result.text);

    if (result.usage && result.usage.totalTokens > 0) {
      console.log('Token Usage (generateText):', {
        tokensInputOutputRatio: result.usage.promptTokens/result.usage.completionTokens,
        totalTokens: result.usage.totalTokens,
        model: geminiModel.modelId
      });
      const tokenDecrementResult = await decrementUserTokensAction({
        tokensUsed: result.usage.totalTokens,
        transactionType: "usage_generate_text",
        modelId: geminiModel.modelId,
      });

      if (!tokenDecrementResult.success) {
        console.error("Token decrementation failed for generateText:", tokenDecrementResult.error, tokenDecrementResult.details);
        let errorMessage = '';
        if (tokenDecrementResult.details instanceof Error) {
          errorMessage = tokenDecrementResult.details.message;
        }
        if (errorMessage.includes("Insufficient tokens")) {
          throw new Error(`Insufficient tokens for generateText operation. Usage: ${result.usage.totalTokens}.`);
        }
        throw new Error("Failed to update token balance after generateText operation.");
      }
    }

    return result;
  } catch (error) {
    console.warn('generateText failed. Error details:', error);
    console.warn('Retrying generateText in 2 seconds...');
    await sleep(2000);
    
    // Retry once
    try {
      result = await baseGenerateText({
        prompt,
        model: geminiModel,
      });

      console.log('generateText (retry) raw result:', result);

      if (result.usage && result.usage.totalTokens > 0) {
        console.log('Token Usage (generateText retry):', {
          tokensInputOutputRatio: result.usage.promptTokens/result.usage.completionTokens,
          totalTokens: result.usage.totalTokens,
          model: geminiModel.modelId
        });
        const tokenDecrementResultRetry = await decrementUserTokensAction({
          tokensUsed: result.usage.totalTokens,
          transactionType: "usage_generate_text",
          modelId: geminiModel.modelId,
        });

        if (!tokenDecrementResultRetry.success) {
          console.error("Token decrementation failed for generateText (retry):", tokenDecrementResultRetry.error, tokenDecrementResultRetry.details);
          let errorMessage = '';
          if (tokenDecrementResultRetry.details instanceof Error) {
            errorMessage = tokenDecrementResultRetry.details.message;
          }
          if (errorMessage.includes("Insufficient tokens")) {
            throw new Error(`Insufficient tokens for generateText operation (retry). Usage: ${result.usage.totalTokens}.`);
          }
          throw new Error("Failed to update token balance after generateText operation (retry).");
        }
      }

      return result;
    } catch (retryError) {
      console.error('generateText retry also failed. Error details:', retryError);
      throw retryError; // Re-throw the error from the retry attempt
    }
  }
}

/*
  File: lib/ai/llm.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/ai/llm.ts
  Directory: lib/ai
*/

--- File: lib/ai/llm.ts ---

import { google } from "@ai-sdk/google";

const geminiModel = google('gemini-2.5-flash-preview-05-20'); //google('gemini-2.0-flash-lite');

export { geminiModel }


/*
  File: lib/auth-utils.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/auth-utils.ts
  Directory: lib
*/

--- File: lib/auth-utils.ts ---

import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";

export function isClerkConfigured(): boolean {
  return Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
}

export function isAdminConfigured(): boolean {
  return Boolean(process.env.ADMIN_USER_IDS);
}

export function isDev(): boolean {
  return process.env.NODE_ENV === "development";
}

/**
 * Checks if a user is an admin
 * @param userId - Optional user ID to check. If not provided, checks the current user.
 * @returns Promise<boolean> - True if the user is an admin, false otherwise
 */
export async function isAdmin(userId?: string): Promise<boolean> {
  try {
    // If userId is not provided, get the current user's ID
    let userIdToCheck = userId;
    
    if (!userIdToCheck) {
      const { userId: currentUserId } = await auth();
      userIdToCheck = currentUserId || undefined;
    }
    
    // If no user is authenticated, they're not an admin
    if (!userIdToCheck) {
      return false;
    }
    
    // Get the list of admin user IDs from environment variables
    const adminUserIds = process.env.ADMIN_USER_IDS?.split(",") || [];
    
    // Check if the user's ID is in the admin list
    return adminUserIds.includes(userIdToCheck);
  } catch (error) {
    console.error("Error checking admin status:", error);
    return false;
  }
}

/**
 * Checks if the provided user ID is an admin
 * @param userId - The user ID to check
 * @returns boolean - True if the user is an admin, false otherwise
 */
export function isUserAdmin(userId: string | null): boolean {
  if (!userId) {
    return false;
  }
  
  // Get the list of admin user IDs from environment variables
  const adminUserIds = process.env.ADMIN_USER_IDS?.split(",") || [];
  
  // Check if the provided user ID is in the admin list
  return adminUserIds.includes(userId);
}

export type AdminCheckResult = {
  isAdmin: boolean
  userId: string | null
  requiresSetup: boolean
}

export type AuthCheckResult = {
  isAuthenticated: boolean
  userId: string | null
}

/**
 * Checks if the user is authenticated
 * @returns The authentication status and user ID
 */
export async function checkAuth(): Promise<AuthCheckResult> {
  // Get the user's ID from Clerk
  const { userId } = await auth()

  return { 
    isAuthenticated: !!userId, 
    userId 
  }
}

/**
 * Checks if the current user is an admin and redirects if not
 * @returns The user ID if the user is an admin
 */
export async function requireAdmin(): Promise<AdminCheckResult> {
  // Get the user's ID from Clerk
  const { userId } = await auth()

  // If not authenticated, redirect to sign-in in production, return status in development
  if (!userId) {
    if (process.env.NODE_ENV === "production") {
      redirect("/sign-in")
    }
    return { isAdmin: false, userId: null, requiresSetup: false }
  }

  // Get the list of admin user IDs
  const adminUserIds = process.env.ADMIN_USER_IDS?.split(",") || []

  // In development, if no admin IDs are configured, return a special status
  if (process.env.NODE_ENV === "development" && (!adminUserIds.length || adminUserIds[0] === "")) {
    return { isAdmin: false, userId, requiresSetup: true }
  }

  // If the user is not an admin, redirect in production, return status in development
  if (!adminUserIds.includes(userId)) {
    if (process.env.NODE_ENV === "production") {
      redirect("/")
    }
    return { isAdmin: false, userId, requiresSetup: false }
  }

  return { isAdmin: true, userId, requiresSetup: false }
} 

/*
  File: lib/aws.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/aws.ts
  Directory: lib
*/

--- File: lib/aws.ts ---

import { S3Client } from "@aws-sdk/client-s3"

// Environment variables
const awsConfig = {
  region: process.env.AWS_REGION,
  accessKeyId: process.env.AWS_KEY,
  secretAccessKey: process.env.AWS_SECRET,
  bucketPublic: process.env.AWS_BUCKET_PUBLIC,
  cloudfrontDomain: process.env.CLOUDFRONT_DOMAIN,
}

export const AWS_BUCKET_PUBLIC = process.env.AWS_BUCKET_PUBLIC

// Log missing variables in development only
if (process.env.NODE_ENV === 'development') {
  const missingVars = Object.entries(awsConfig)
    .filter(([, value]) => !value)
    .map(([key]) => key)

  if (missingVars.length > 0) {
    console.warn('Missing AWS configuration variables:', missingVars)
  }
}

// Function to check if AWS is configured
export function isAwsConfigured(): boolean {
  return Boolean(
    awsConfig.region &&
    awsConfig.accessKeyId &&
    awsConfig.secretAccessKey &&
    awsConfig.bucketPublic
  )
}

// Create an S3 client if configured
export const s3Client = isAwsConfigured()
  ? new S3Client({
      region: awsConfig.region!,
      credentials: {
        accessKeyId: awsConfig.accessKeyId!,
        secretAccessKey: awsConfig.secretAccessKey!,
      },
    })
  : null

// Function to get asset URL
export function getAssetUrl(key: string, withTimestamp = false): string | null {
  if (!isAwsConfigured()) {
    return null
  }

  const timestamp = withTimestamp ? Date.now() : null
  const keyWithTimestamp = timestamp 
    ? (key.includes('?') ? `${key}&t=${timestamp}` : `${key}?t=${timestamp}`)
    : key

  if (awsConfig.cloudfrontDomain) {
    return `${awsConfig.cloudfrontDomain}/${keyWithTimestamp}`
  }

  // Fallback to direct S3 URL
  return `https://${awsConfig.bucketPublic}.s3.${awsConfig.region}.amazonaws.com/${keyWithTimestamp}`
}

// Function to check AWS connection
export async function checkAwsConnection(): Promise<{
  success: boolean
  message: string
  details?: {
    error?: unknown
  }
}> {
  if (!isAwsConfigured()) {
    return {
      success: false,
      message: 'AWS is not configured',
      details: {
        error: 'Missing required environment variables'
      }
    }
  }

  try {
    // Try to make a simple API call to verify connection
    await s3Client!.config.credentials()
    
    return {
      success: true,
      message: 'Successfully connected to AWS'
    }
  } catch (err) {
    console.error('Unexpected error checking AWS connection:', err)
    return {
      success: false,
      message: `Unexpected error: ${err instanceof Error ? err.message : String(err)}`,
      details: { error: err }
    }
  }
} 

/*
  File: lib/clerk.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/clerk.ts
  Directory: lib
*/

--- File: lib/clerk.ts ---

import { createClerkClient } from '@clerk/backend'

if (!process.env.CLERK_SECRET_KEY) {
  throw new Error('CLERK_SECRET_KEY is not defined')
}

export const clerkClient = createClerkClient({ 
  secretKey: process.env.CLERK_SECRET_KEY 
})

// Re-export commonly used types
export type { User } from '@clerk/backend' 

/*
  File: lib/config/navigation.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/config/navigation.ts
  Directory: lib/config
*/

--- File: lib/config/navigation.ts ---

export const navItems = [
  {
    title: "About",
    href: "/about",
  },
  {
    title: "Contact",
    href: "/contact",
  },
] as const

export type NavItem = (typeof navItems)[number] 

/*
  File: lib/config.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/config.ts
  Directory: lib
*/

--- File: lib/config.ts ---

export const IMAGE_HOST = "https://d1dkwd3w4hheqw.cloudfront.net";

export const siteConfig = {
  title: "D20 Adventures",
  description: "A new narrative-driven RPG platform that blends play-by-post gameplay and real-time updates facilitated by an AI Game Master.",
  shortDescription: "A new narrative-driven RPG platform that blends play-by-post gameplay and real-time updates facilitated by an AI Game Master.",
  url: "d20adventures.com",
  shareImage: "https://d20adventures.com/images/screenshot.png",
  x: "",
  github: "",
  logo: "",
  imageHost: IMAGE_HOST,
} as const

export type SiteConfig = {
    title: string
    description: string
    shortDescription: string
    url: string
    shareImage: string
    x: string
    github: string
    logo: string
    imageHost: string
}

/*
  File: lib/context/AdventureContext.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/context/AdventureContext.tsx
  Directory: lib/context
*/

--- File: lib/context/AdventureContext.tsx ---

import React, { createContext, useContext } from "react"
import type { Adventure } from "@/types/adventure"

type AdventureContextType = {
  adventurePlanId: string
  settingId: string
  adventure: Adventure
}

const AdventureContext = createContext<AdventureContextType | undefined>(undefined)

export const AdventureProvider = ({ adventurePlanId, settingId, adventure, children }: { adventurePlanId: string; settingId: string; adventure: Adventure; children: React.ReactNode }) => (
  <AdventureContext.Provider value={{ adventurePlanId, settingId, adventure }}>{children}</AdventureContext.Provider>
)

export function useAdventure() {
  const ctx = useContext(AdventureContext)
  if (!ctx) throw new Error("useAdventure must be used within an AdventureProvider")
  return ctx
}


/*
  File: lib/context/TokenContext.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/context/TokenContext.tsx
  Directory: lib/context
*/

--- File: lib/context/TokenContext.tsx ---

import React, { createContext, useContext, useState, useEffect, useCallback, ReactNode } from "react"
import { useUser } from "@clerk/nextjs"
import { fetchUserTokenBalance } from "@/app/_actions/user-token-actions"

type TokenContextType = {
  tokensRemaining: number | null
  alltimeTokens: number | null
  isLoading: boolean
  error: string | null
  refreshTokens: () => Promise<void>
}

const TokenContext = createContext<TokenContextType | undefined>(undefined)

interface TokenProviderProps {
  children: ReactNode
  pollingInterval?: number // Optional: interval in milliseconds, defaults to 60000
}

export const TokenProvider: React.FC<TokenProviderProps> = ({ children, pollingInterval = 60000 }) => {
  const { isSignedIn, isLoaded } = useUser()
  const [tokensRemaining, setTokensRemaining] = useState<number | null>(null)
  const [alltimeTokens, setAlltimeTokens] = useState<number | null>(null)
  const [isLoading, setIsLoading] = useState<boolean>(true)
  const [error, setError] = useState<string | null>(null)

  const handleFetchTokens = useCallback(async () => {
    // Don't fetch if user is not signed in or Clerk hasn't loaded yet
    if (!isLoaded || !isSignedIn) {
      setTokensRemaining(null)
      setAlltimeTokens(null)
      setIsLoading(false)
      setError(null)
      return
    }

    setIsLoading(true)
    try {
      const result = await fetchUserTokenBalance()

      // Handle authentication error gracefully
      if (result.error === "USER_NOT_AUTHENTICATED") {
        // User is not authenticated on server side, treat as signed out
        setTokensRemaining(null)
        setAlltimeTokens(null)
        setError(null) // Don't show error for auth issues, just clear tokens
        return
      }

      // Handle other errors
      if (result.error) {
        setError(result.error)
        return
      }

      // Success case
      setTokensRemaining(result.tokensRemaining)
      setAlltimeTokens(result.alltimeTokens)
      setError(null)
    } catch (err) {
      // This should rarely happen now since server action returns error objects
      console.error("TokenContext: Unexpected error fetching token balance", err)
      setError(err instanceof Error ? err.message : "An unknown error occurred while fetching token balance.")
    } finally {
      setIsLoading(false)
    }
  }, [isLoaded, isSignedIn])

  useEffect(() => {
    handleFetchTokens() // Initial fetch

    // Only set up polling if user is signed in
    if (isLoaded && isSignedIn) {
      const intervalId = setInterval(() => {
        handleFetchTokens()
      }, pollingInterval)

      return () => clearInterval(intervalId) // Cleanup interval on unmount
    }
  }, [handleFetchTokens, pollingInterval, isLoaded, isSignedIn])

  return <TokenContext.Provider value={{ tokensRemaining, alltimeTokens, isLoading, error, refreshTokens: handleFetchTokens }}>{children}</TokenContext.Provider>
}

export const useTokens = (): TokenContextType => {
  const context = useContext(TokenContext)
  if (context === undefined) {
    throw new Error("useTokens must be used within a TokenProvider")
  }
  return context
}


/*
  File: lib/context/TurnContext.tsx
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/context/TurnContext.tsx
  Directory: lib/context
*/

--- File: lib/context/TurnContext.tsx ---

import React, { createContext, useContext, useEffect, useState, useRef } from "react"
import { useUser } from "@clerk/nextjs"
import type { Turn } from "@/types/adventure" // Adjust as needed
import { mapConvexTurnToTurn } from "@/lib/utils"

type TurnContextType = {
  currentTurn: Turn | null
  disableSSE: boolean
  isConnected: boolean
}

const TurnContext = createContext<TurnContextType | undefined>(undefined)

export const TurnProvider = ({ adventureId, initialTurn, disableSSE = false, children }: { adventureId: string; initialTurn: Turn | null; disableSSE?: boolean; children: React.ReactNode }) => {
  const { isSignedIn, isLoaded } = useUser()
  const [currentTurn, setCurrentTurn] = useState<Turn | null>(initialTurn)
  const [isConnected, setIsConnected] = useState(false)
  const eventSourceRef = useRef<EventSource | null>(null)
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const reconnectAttempts = useRef(0)
  const maxReconnectAttempts = 5

  // Effect to ensure currentTurn reflects initialTurn when SSE is disabled
  useEffect(() => {
    if (disableSSE) {
      // Only update if they are actually different to prevent unnecessary re-renders
      if (currentTurn?.id !== initialTurn?.id || (currentTurn === null && initialTurn !== null) || (currentTurn !== null && initialTurn === null)) {
        console.log(
          "[TurnProvider SyncEffect] SSE is disabled. Syncing currentTurn with initialTurn. initialTurn ID:",
          initialTurn?.id,
          "initialTurn Title:",
          initialTurn?.title,
          "Previous currentTurn ID:",
          currentTurn?.id
        )
        setCurrentTurn(initialTurn)
      }
    }
    // If !disableSSE, currentTurn is managed by its own state + SSE updates.
  }, [initialTurn, disableSSE, currentTurn])

  const createConnection = () => {
    // Don't create connection if user is not authenticated
    if (!isLoaded || !isSignedIn) {
      console.warn("[TurnProvider] Not creating SSE connection: user not authenticated")
      setIsConnected(false)
      return
    }

    if (!adventureId || adventureId === "demo-adventure") {
      console.warn("[TurnProvider] Not creating SSE connection: adventureId is", adventureId)
      return
    }

    if (disableSSE) {
      console.warn("[TurnProvider] SSE disabled for historical turn viewing")
      return
    }

    // Close existing connection if any
    if (eventSourceRef.current) {
      eventSourceRef.current.close()
    }

    const es = new EventSource(`/api/adventure/stream/${adventureId}`)
    eventSourceRef.current = es

    es.onopen = () => {
      setIsConnected(true)
      reconnectAttempts.current = 0 // Reset on successful connection
    }

    es.onmessage = (event) => {
      let rawData = null // Default to null
      if (event.data) {
        // Check if event.data is not null, undefined, empty string, 0, false
        try {
          rawData = JSON.parse(event.data)
        } catch (e) {
          console.error("[TurnProvider SSE OnMessage] JSON.parse error. Data will be treated as null.", "Error:", e, "Raw event.data:", event.data)
          // rawData remains null if parsing fails
        }
      } else {
        // event.data is falsy (null, undefined, empty string, 0, false), so treat rawData as null.
        console.log("[TurnProvider SSE OnMessage] event.data is falsy. Data treated as null. Raw event.data:", event.data)
      }

      // console.log("[TurnProvider SSE OnMessage] Parsed rawData:", rawData)
      const newTurn = mapConvexTurnToTurn(rawData)

      // Only update currentTurn if newTurn is not null.
      // This prevents a null message from SSE from wiping out a valid initialTurn or a previously valid SSE turn.
      if (newTurn !== null) {
        setCurrentTurn(newTurn)
      } else {
        console.log("[TurnProvider SSE OnMessage] SSE resulted in a null turn. currentTurn will NOT be updated to null to preserve existing state. Current currentTurn ID:", currentTurn?.id)
      }
    }

    es.onerror = (err) => {
      console.error("[TurnProvider] SSE error:", JSON.stringify(err, null, 2))
      setIsConnected(false)

      // Only attempt reconnection if we haven't exceeded max attempts and user is still authenticated
      if (reconnectAttempts.current < maxReconnectAttempts && isSignedIn) {
        const backoffDelay = Math.min(1000 * Math.pow(2, reconnectAttempts.current), 30000) // Max 30 seconds
        console.log(`[TurnProvider] Attempting reconnection in ${backoffDelay}ms (attempt ${reconnectAttempts.current + 1}/${maxReconnectAttempts})`)

        reconnectAttempts.current++
        reconnectTimeoutRef.current = setTimeout(() => {
          createConnection()
        }, backoffDelay)
      } else {
        console.error("[TurnProvider] Max reconnection attempts reached or user not authenticated, giving up")
      }
    }
  }

  useEffect(() => {
    createConnection()

    // Handle visibility change to reconnect when tab becomes active
    const handleVisibilityChange = () => {
      if (!document.hidden && isSignedIn && (!eventSourceRef.current || eventSourceRef.current.readyState === EventSource.CLOSED)) {
        // Reset attempts when user returns to tab
        reconnectAttempts.current = 0
        createConnection()
      }
    }

    document.addEventListener("visibilitychange", handleVisibilityChange)

    return () => {
      document.removeEventListener("visibilitychange", handleVisibilityChange)

      if (eventSourceRef.current) {
        eventSourceRef.current.close()
      }

      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current)
      }
    }
  }, [adventureId, disableSSE, isLoaded, isSignedIn, initialTurn]) // Added initialTurn

  return <TurnContext.Provider value={{ currentTurn, disableSSE, isConnected }}>{children}</TurnContext.Provider>
}

export const useTurn = () => {
  const context = useContext(TurnContext)
  if (!context) {
    throw new Error("useTurn must be used within a TurnProvider")
  }
  return context.currentTurn
}

export const useTurnContext = () => {
  const context = useContext(TurnContext)
  if (!context) {
    throw new Error("useTurnContext must be used within a TurnProvider")
  }
  return context
}


/*
  File: lib/convex/client.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/convex/client.ts
  Directory: lib/convex
*/

--- File: lib/convex/client.ts ---

import { ConvexReactClient } from "convex/react";

export const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!); 

/*
  File: lib/convex/server.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/convex/server.ts
  Directory: lib/convex
*/

--- File: lib/convex/server.ts ---

import { ConvexClient } from "convex/browser";
import { api, internal } from "@/convex/_generated/api";

export const convex = new ConvexClient(process.env.CONVEX_URL!);
export { api, internal }; 

/*
  File: lib/email-utils.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/email-utils.ts
  Directory: lib
*/

--- File: lib/email-utils.ts ---

import { createHash } from "crypto"

/**
 * Generates a secure token for email unsubscribe links
 * @param email The email address to generate a token for
 * @returns A secure hash that can be used in unsubscribe links
 */
export function generateUnsubscribeToken(email: string): string {
  if (!process.env.UNSUBSCRIBE_SECRET) {
    throw new Error("UNSUBSCRIBE_SECRET environment variable is not set")
  }

  // Combine email with secret and current year-month
  // This makes the token valid for one month
  const date = new Date()
  const yearMonth = `${date.getUTCFullYear()}-${(date.getUTCMonth() + 1).toString().padStart(2, "0")}`
  const data = `${email}:${yearMonth}:${process.env.UNSUBSCRIBE_SECRET}`

  // Create a SHA-256 hash
  return createHash("sha256").update(data).digest("hex")
}

/**
 * Verifies if an unsubscribe token is valid for a given email
 * @param email The email address to verify
 * @param token The token to verify
 * @returns boolean indicating if the token is valid
 */
export function verifyUnsubscribeToken(email: string, token: string): boolean {
  // Generate a token for the current month and previous month
  // This gives users a grace period when links cross month boundaries
  const currentToken = generateUnsubscribeToken(email)
  
  // Generate token for previous month
  const lastMonth = new Date()
  lastMonth.setUTCMonth(lastMonth.getUTCMonth() - 1)
  const yearMonth = `${lastMonth.getUTCFullYear()}-${(lastMonth.getUTCMonth() + 1).toString().padStart(2, "0")}`
  const lastMonthData = `${email}:${yearMonth}:${process.env.UNSUBSCRIBE_SECRET}`
  const previousToken = createHash("sha256").update(lastMonthData).digest("hex")

  // Check if the token matches either current or previous month
  return token === currentToken || token === previousToken
}

/**
 * Encodes an email address for use in URLs
 * @param email The email address to encode
 * @returns URL-safe base64 encoded email
 */
export function encodeEmail(email: string): string {
  return Buffer.from(email).toString("base64url")
}

/**
 * Decodes an encoded email address from a URL
 * @param encoded The encoded email to decode
 * @returns The original email address
 */
export function decodeEmail(encoded: string): string {
  return Buffer.from(encoded, "base64url").toString("utf-8")
} 

/*
  File: lib/generated/routes.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/generated/routes.ts
  Directory: lib/generated
*/

--- File: lib/generated/routes.ts ---

// This file is auto-generated. DO NOT EDIT IT MANUALLY.
// It is used to generate the validRoutes for tracking user visits.
// To regenerate, run: pnpm generate:routes

export const validRoutes = new Set([
  '/',
  'about',
  'account/*',
  'admin',
  'admin/mailing-list',
  'admin/users',
  'contact',
  'demo/ai',
  'demo/upload',
  'mailing-list',
  'pay',
  'privacy',
  'roadmap',
  'settings/*',
  'terms',
  'unsubscribe'
])


/*
  File: lib/s3-utils.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/s3-utils.ts
  Directory: lib
*/

--- File: lib/s3-utils.ts ---

import { GetObjectCommand,PutObjectCommand, CopyObjectCommand, ListObjectsV2Command } from "@aws-sdk/client-s3"
import { s3Client, isAwsConfigured, getAssetUrl } from "./aws"
import { Readable } from "stream"

/**
 * Upload a file to S3
 * @param file The file to upload
 * @param key The S3 object key (path + filename)
 * @param contentType Optional content type
 * @returns The URL of the uploaded file through CloudFront
 */
export async function uploadFileToS3(
  file: File | Blob,
  key: string,
  contentType?: string
): Promise<string> {
  if (!isAwsConfigured() || !s3Client) {
    throw new Error("AWS S3 is not configured")
  }

  // Convert file to buffer
  const arrayBuffer = await file.arrayBuffer()
  const buffer = Buffer.from(arrayBuffer)

  // Set up the upload parameters
  const params = {
    Bucket: process.env.AWS_BUCKET_PUBLIC,
    Key: key,
    Body: buffer,
    ContentType: contentType || file.type,
    CacheControl: key.includes('hackathon/covers') ? 'no-cache' : "public, max-age=31536000",
  }

  // Upload to S3
  await s3Client.send(new PutObjectCommand(params))
  
  // Get the URL (with timestamp for cache busting)
  const url = getAssetUrl(key, true)
  if (!url) {
    throw new Error("Failed to generate asset URL")
  }
  
  return url
}

export const transferImageToS3 = async (imageUrl: string, key: string): Promise<string> => {
  if (!isAwsConfigured() || !s3Client) {
    throw new Error("AWS S3 is not configured")
  }

  try {
    // Download the image from the URL
    const response = await fetch(imageUrl)
    const arrayBuffer = await response.arrayBuffer()

    // Prepare the parameters for uploading to S3
    const params = {
      Bucket: process.env.AWS_BUCKET_PUBLIC,
      Key: key,
      Body: Buffer.from(arrayBuffer),
      ContentType: response.headers.get("content-type") || "application/octet-stream",
      ContentLength: parseInt(response.headers.get("content-length") || "0", 10),
    }

    // Upload the image to the S3 bucket
    const putCommand = new PutObjectCommand(params)
    
    await s3Client.send(putCommand)

    // Get the URL
    const publicUrl = getAssetUrl(key)
    if (!publicUrl) {
      throw new Error("Failed to generate asset URL")
    }

    return publicUrl
  } catch (error) {
    throw new Error("Error uploading image to S3: " + error)
  }
}

// Helper function to convert a Readable stream to a string
export const streamToString = (stream: Readable): Promise<string> => {
  const chunks: unknown[] = []
  return new Promise((resolve, reject) => {
    stream.on("data", (chunk) => chunks.push(chunk))
    stream.on("end", () => resolve(Buffer.concat(chunks as Buffer[]).toString("utf8")))
    stream.on("error", reject)
  })
}

/**
 * Read a JSON file from S3 (private data bucket)
 * @param key The S3 object key (path + filename)
 * @returns The parsed JSON object
 */
export async function readJsonFromS3(key: string): Promise<unknown> {
  const bucket = process.env.bucketData || process.env.AWS_BUCKET_DATA;
  if (!bucket) {
    throw new Error("AWS_BUCKET_DATA is not set");
  }
  if (!isAwsConfigured() || !s3Client) {
    throw new Error("AWS S3 is not configured");
  }
  try {
    const command = new GetObjectCommand({
      Bucket: bucket,
      Key: key,
    });
    const response = await s3Client.send(command);
    if (!response.Body) {
      throw new Error("No file body returned from S3");
    }
    // Convert stream to string
    const jsonString = await streamToString(response.Body as Readable);
    try {
      // Parse and return JSON
      return JSON.parse(jsonString);
    } catch (parseError) {
      console.error("Failed to parse JSON from S3:", {
        key,
        jsonString,
        parseError,
      });
      throw new Error(`Invalid JSON in S3 object: ${key}`);
    }
  } catch (error) {
    throw new Error(`Error reading JSON from S3: ${error}`);
  }
}

export async function updateJsonOnS3(key: string, data: unknown): Promise<void> {
  const bucket = process.env.bucketData || process.env.AWS_BUCKET_DATA;
  if (!bucket) {
    throw new Error("AWS_BUCKET_DATA is not set");
  }
  if (!isAwsConfigured() || !s3Client) {
    throw new Error("AWS S3 is not configured");
  }
  try {
    const command = new PutObjectCommand({
      Bucket: bucket,
      Key: key,
      Body: JSON.stringify(data, null, 2),
      ContentType: "application/json",
    });
    await s3Client.send(command);
  } catch (error) {
    console.error("Error updating JSON on S3:", { key, error });
    throw new Error(`Error updating JSON on S3: ${error}`);
  }
}

export async function copyS3Object(sourceKey: string, destinationKey: string): Promise<void> {
  const bucket = process.env.bucketData || process.env.AWS_BUCKET_DATA;
  if (!bucket) {
    throw new Error("AWS_BUCKET_DATA is not set");
  }
  if (!isAwsConfigured() || !s3Client) {
    throw new Error("AWS S3 is not configured");
  }

  try {
    const command = new CopyObjectCommand({
      Bucket: bucket,
      CopySource: `${bucket}/${sourceKey}`,
      Key: destinationKey,
    });
    await s3Client.send(command);
    console.log(`Successfully copied ${sourceKey} to ${destinationKey}`);
  } catch (error) {
    console.error("Error copying S3 object:", { sourceKey, destinationKey, error });
    throw new Error(`Error copying S3 object: ${error}`);
  }
}

/**
 * List and read all .json files within a given directory on S3 (private data bucket)
 * @param directoryPrefix The directory prefix (e.g., "adventures/" or "templates/")
 * @param exclude Optional array of filenames to exclude (e.g., ["setting-data.json"])
 * @returns Array of objects with key and parsed JSON data
 */
export async function listAndReadJsonFilesInS3Directory(
  directoryPrefix: string, 
  exclude: string[] = []
): Promise<Array<{ key: string; data: unknown }>> {
  const bucket = process.env.bucketData || process.env.AWS_BUCKET_DATA;
  if (!bucket) {
    throw new Error("AWS_BUCKET_DATA is not set");
  }
  if (!isAwsConfigured() || !s3Client) {
    throw new Error("AWS S3 is not configured");
  }

  try {
    const command = new ListObjectsV2Command({
      Bucket: bucket,
      Prefix: directoryPrefix,
    });

    const response = await s3Client.send(command);
    
    if (!response.Contents) {
      return [];
    }

    // Filter for .json files and exclude specified files
    const jsonFiles = response.Contents
      .filter(object => {
        if (!object.Key || !object.Key.endsWith('.json')) {
          return false;
        }
        
        // Only include files in the top level of the directory (no subdirectories)
        const relativePath = object.Key.replace(directoryPrefix, '');
        if (relativePath.includes('/')) {
          return false; // Skip files in subdirectories
        }
        
        // Extract filename from the full key
        const filename = object.Key.split('/').pop() || '';
        return !exclude.includes(filename);
      })
      .map(object => object.Key!)
      .sort();

    // Read the content of each JSON file
    const results = await Promise.all(
      jsonFiles.map(async (key) => {
        try {
          const data = await readJsonFromS3(key);
          return { key, data };
        } catch (error) {
          console.error(`Error reading JSON file ${key}:`, error);
          throw new Error(`Failed to read JSON file ${key}: ${error}`);
        }
      })
    );

    return results;
  } catch (error) {
    console.error("Error listing and reading JSON files from S3:", { directoryPrefix, error });
    throw new Error(`Error listing and reading JSON files from S3: ${error}`);
  }
}

/*
  File: lib/send-email.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/send-email.ts
  Directory: lib
*/

--- File: lib/send-email.ts ---

import sgMail from "@sendgrid/mail"

if (!process.env.SENDGRID_API_KEY) {
  throw new Error("Missing SENDGRID_API_KEY environment variable")
}

sgMail.setApiKey(process.env.SENDGRID_API_KEY)

interface SendEmailOptions {
  to: string
  subject: string
  text: string
  html?: string
}

export async function sendEmail({ to, subject, text, html }: SendEmailOptions) {
  const msg = {
    to,
    from: process.env.SENDGRID_SENDER || "noreply@example.com",
    subject,
    text,
    html: html || text,
  }

  try {
    await sgMail.send(msg)
  } catch (error) {
    console.error("Error sending email:", error)
    throw error
  }
} 

/*
  File: lib/services/mailing-list.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/services/mailing-list.ts
  Directory: lib/services
*/

--- File: lib/services/mailing-list.ts ---

import { convex, api } from "@/lib/convex/server";
import { Doc } from "@/convex/_generated/dataModel";

export type MailingListSubscription = Doc<"mailing_list_subscriptions">;

/**
 * Retrieves all mailing list subscriptions from Convex
 */
export async function getMailingListSubscriptions(): Promise<MailingListSubscription[]> {
  try {
    return await convex.query(api.mailingList.getSubscriptions, {});
  } catch (error) {
    console.error('Error getting mailing list subscriptions:', error);
    return [];
  }
}

/**
 * Adds a new email subscription to the mailing list
 */
export async function addMailingListSubscription(data: { 
  userId: string, 
  email: string, 
  name?: string | undefined,
  preferences?: {
    marketing: boolean,
    updates: boolean
  }
}): Promise<MailingListSubscription | null> {
  try {
    return await convex.mutation(api.mailingList.subscribe, data);
  } catch (error) {
    console.error('Error adding mailing list subscription:', error);
    return null;
  }
}

/**
 * Removes an email subscription from the mailing list
 */
export async function removeMailingListSubscription(email: string): Promise<boolean> {
  try {
    return await convex.mutation(api.mailingList.unsubscribe, { email });
  } catch (error) {
    console.error('Error removing mailing list subscription:', error);
    return false;
  }
} 

/*
  File: lib/services/narrative-service.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/services/narrative-service.ts
  Directory: lib/services
*/

--- File: lib/services/narrative-service.ts ---

import { generateObject } from "@/lib/ai";
import wait from "waait";
import { z } from "zod";

const rollRequirementSchema = z.object({
  rollType: z.string(),
  difficulty: z.number(),
  modifier: z.number().optional(),
});

const rollModifierSchema = z.object({
  modifier: z.number(),
});

export async function isRedundantOrMinimalAction(action: string, aiNarrative: string, characterName: string): Promise<boolean> {
  const prompt = `
Given the following player action and AI-generated narrative for the character ${characterName}, does the action add any meaningful, non-redundant content that avoids mentioning game mechanics to the narrative? If the action is generic, minimal, or already fully captured by the narrative, answer "yes". Otherwise, answer "no".

Player action:
${action}

AI narrative:
${aiNarrative}

Answer:`.trim();

  const res = await fetch("/api/ai/generate/text", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ input: prompt }),
  });
  if (!res.ok) throw new Error("Failed to judge redundancy");
  const data = await res.json();
  const answer = (data.result || data.text || "").trim().toLowerCase();
  return answer.startsWith("yes");
}

export async function ensureNarrativeAction(characterName: string, playerInput: string): Promise<string> {
  const prompt = `
If the following player action is already a well-written, third-person, present-tense narrative paragraph suitable for a fantasy novel, return it unchanged. Otherwise, rewrite it as such, expanding minimally if needed replacing game mechanics with well-written narrative in the style of a novel..

Character name: ${characterName}

Player input:
${playerInput}

Final narrative action:`.trim();

  const res = await fetch("/api/ai/generate/text", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ input: prompt }),
  });
  if (!res.ok) throw new Error("Failed to process player action");
  const data = await res.json();
  return data.result || data.text || "";
}

export async function generateNarrativeUpdate(previousNarrative: string, playerReply: string): Promise<string> {
  const prompt = `
Continue the following fantasy adventure story as a single, concise paragraph of immersive third-person narrative prose, as if writing a novel. Write exactly two sentences and do not exceed 60 words. Do not use lists, bullet points, or markdown formatting. Write in present tense. Continue naturally from the previous events and the player's latest action. Do not use semicolons in your response. Never mention game mechanics, dice, or rules in your response.

Previous narrative:
${previousNarrative}

Player action:
${playerReply}

Narrative continuation:`.trim();

  const res = await fetch("/api/ai/generate/text", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ input: prompt }),
  });
  if (!res.ok) throw new Error("Failed to generate narrative");
  const data = await res.json();
  return data.result || data.text || "";
}

export async function formatNarrativeAction({
  characterName,
  playerInput,
  narrativeContext,
}: {
  characterName: string;
  playerInput: string;
  narrativeContext: string;
}): Promise<string> {
  // First, check if dialogue should be generated
  const dialogueEvalPrompt = `
Context:
${narrativeContext}

Player's action for ${characterName}: "${playerInput}"

Does this player action suggest that ${characterName} should speak dialogue? Look for actions like "greet", "ask", "say", "tell", "speak", "respond", "answer", "call out", "whisper", "shout", or any action that implies the character is communicating verbally with someone.

Answer only "yes" or "no".`.trim();

  console.log("[formatNarrativeAction] dialogue evaluation prompt:\n", dialogueEvalPrompt);
  
  const dialogueEvalRes = await fetch("/api/ai/generate/text", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ input: dialogueEvalPrompt }),
  });
  
  if (!dialogueEvalRes.ok) throw new Error("Failed to evaluate dialogue need");
  const dialogueEvalData = await dialogueEvalRes.json();
  const shouldGenerateDialogue = (dialogueEvalData.result || dialogueEvalData.text || "").trim().toLowerCase().startsWith("yes");
  
  console.log("[formatNarrativeAction] should generate dialogue:", shouldGenerateDialogue);

  if (shouldGenerateDialogue) {
    // Generate dialogue
    const dialoguePrompt = `
Context:
${narrativeContext}

Player's action for ${characterName}: "${playerInput}"

Write a brief narrative paragraph in third-person present tense that includes actual dialogue for ${characterName}. Base the dialogue on what the player action suggests the character should say. Keep it concise and natural, with up to 2 sentences of narrative, in the style of a novel, with at least one complete sentence of prose. Include dialogue tags (e.g., "says", "asks", "replies"). Do not use semicolons. Never mention game mechanics, dice, or rules.

Output only the narrative paragraph with dialogue.`.trim();

    console.log("[formatNarrativeAction] dialogue generation prompt:\n", dialoguePrompt);
    const dialogueRes = await fetch("/api/ai/generate/text", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ input: dialoguePrompt }),
    });
    if (!dialogueRes.ok) throw new Error("Failed to generate dialogue");
    const dialogueData = await dialogueRes.json();
    const result = dialogueData.result || dialogueData.text || "";
    console.log("[formatNarrativeAction] dialogue result:", result);
    return result;
  }

  // Logic for non-dialogue actions
  const prompt = `
Context:
${narrativeContext}

Player's original action for ${characterName}: "${playerInput}"

Review the player's original action.
If the action is already a well-written, third-person, present-tense narrative paragraph describing what ${characterName} said or did, then return the player's original action verbatim.
Otherwise, rewrite the player's action into a vivid, engaging, third-person, present-tense narrative paragraph. If the action is minimal (like "attack" or "hide"), enhance it with appropriate descriptive details that fit the context. Describe how ${characterName} performs the action in a way that's immersive and engaging.
IMPORTANT:Do NOT write anything about the outcome of the action!
Use the provided context to inform appropriate details (weapons, environment, targets, etc.) but focus on ${characterName}'s specific actions. Write in the style of an adventure novel. Do not use semicolons. Never mention game mechanics, dice, or rules.

Output only the final narrative paragraph.`.trim();

  await wait(500)
  console.log("[formatNarrativeAction] standard formatting prompt:\n", prompt);
  const res = await fetch("/api/ai/generate/text", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ input: prompt }),
  });
  if (!res.ok) throw new Error("Failed to process player action");
  const data = await res.json();
  console.log("[formatNarrativeAction] standard result:", data.result || data.text || "");
  return data.result || data.text || "";
}

export async function generateRollOutcomeNarrativeWithContext({
  characterName,
  rollType,
  rollResult,
  rollDifficulty,
  rollSuccess,
  narrativeContext,
  encounterIntro,
  encounterInstructions,
  playerAction,
}: {
  characterName: string;
  rollType: string;
  rollResult: number;
  rollDifficulty: number;
  rollSuccess: boolean;
  narrativeContext: string;
  encounterIntro: string;
  encounterInstructions: string;
  playerAction: string;
}): Promise<string> {
  const prompt = `
Context:
${narrativeContext}

Encounter Intro:
${encounterIntro}

Encounter Instructions:
${encounterInstructions}

Player action: "${playerAction}"

A dice roll was made for ${characterName}: ${rollType} (Result: ${rollResult}, Difficulty: ${rollDifficulty}, Success: ${rollSuccess ? "yes" : "no"}).

Write a single, concise, immersive third-person narrative paragraph (exactly two sentences, max 60 words) describing the outcome of the roll. Only reference things present in the context and instructions above. Do not invent new objects, people, or events. Write in present tense. Do not use lists, bullet points, or markdown formatting. Do not use semicolons in your response. Never mention game mechanics, dice, or rules in your response.

Output only the narrative paragraph.`.trim();

  console.log("[generateRollOutcomeNarrativeWithContext] prompt:\n", prompt);
  const res = await fetch("/api/ai/generate/text", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ input: prompt }),
  });
  if (!res.ok) throw new Error("Failed to generate roll outcome narrative");
  const data = await res.json();
  console.log("[generateRollOutcomeNarrativeWithContext] AI result:", data.result || data.text || "");
  return data.result || data.text || "";
}

export async function getRollRequirementHelper(playerInput: string, context: { encounterIntro?: string; encounterInstructions?: string; narrativeContext?: string }) {
  const prompt = `
Encounter Intro:
${context.encounterIntro || ""}

Encounter Instructions:
${context.encounterInstructions || ""}

Narrative Context:
${context.narrativeContext || ""}

Player action or narrative: "${playerInput}"

Given the above, decide if a D&D-style roll is required. If so, return the type of roll (choose from: Perception, Investigation, Stealth, Athletics, Acrobatics, Survival, Deception, Persuasion, Intimidation, Insight, Nature, Animal Handling, Medicine, History, Arcana, Sleight of Hand, Performance, Attack, etc.) and a difficulty (DC) between 5 and 20.

Respond in JSON: { "rollType": string, "difficulty": number } or null if no roll is needed.
`;
  const result = await generateObject({ prompt, schema: rollRequirementSchema });
  if (result.object) return result.object;

  // --- Fallback: detect roll type keywords if LLM returns null ---
  // This ensures actions like "sneak away", "hide", "attack", etc. require the appropriate check
  const lower = playerInput.toLowerCase();
  // Attack
  if (/(attack|strike|shoot|stab|slash|hit|swing|fire|punch|kick|smash|lunge|thrust|snipe|ambush|assault|charge|fight|brawl|clash|engage|swing at|fire at|shoot at)/.test(lower)) {
    return { rollType: "Attack Roll", difficulty: 13 };
  }
  // Stealth
  if (/(sneak|hide|conceal|slip away|evade|escape|stealth|shadow|blend in|slink|creep|tiptoe|slither|prowl|skulk|lurk|camouflage|mask|cover|avoid|dodge|elude|flee|retreat|withdraw|vanish|disappear)/.test(lower)) {
    return { rollType: "Stealth Check", difficulty: 15 };
  }
  // Athletics
  if (/(climb|jump|run|swim|lift|push|pull|drag|break|force open|athletic|scale|vault|heave|hoist|tug|haul|sprint|dash|leap|wrestle|grapple|carry|throw|toss|hurl|shove|barge|ram|bust|burst|athletics)/.test(lower)) {
    return { rollType: "Athletics Check", difficulty: 14 };
  }
  // Acrobatics
  if (/(acrobatics|flip|tumble|roll|cartwheel|somersault|dive|dodge|evade|balance|tightrope|spring|vault|slide|slip|twist|spin|pirouette|leap|agile|agility|nimble|dexterous|somersault|handspring|backflip|frontflip|handstand)/.test(lower)) {
    return { rollType: "Acrobatics Check", difficulty: 14 };
  }
  // Survival
  if (/(track|forage|hunt|survive|navigate|find food|find water|build shelter|endure|weather|survival|trail|wilderness|outdoors|camp|trap|snare|follow tracks|read tracks|nature lore)/.test(lower)) {
    return { rollType: "Survival Check", difficulty: 13 };
  }
  // Deception
  if (/(deceiv|lie|bluff|trick|mislead|con|fake|forg|falsif|cheat|hoax|dupe|deception|fib|fabricat|pretend|disguise|mask intent|cover up|conceal intent)/.test(lower)) {
    return { rollType: "Deception Check", difficulty: 13 };
  }
  // Persuasion
  if (/(persuad|convince|influence|charm|appeal|negotiate|bargain|diplomacy|diplomat|reason with|plead|entreat|coax|sway|talk into|win over|persuasion)/.test(lower)) {
    return { rollType: "Persuasion Check", difficulty: 13 };
  }
  // Intimidation
  if (/(intimidat|threaten|bully|coerce|frighten|scare|menace|terrorize|daunt|cow|browbeat|overawe|dominate|intimidation)/.test(lower)) {
    return { rollType: "Intimidation Check", difficulty: 13 };
  }
  // Insight
  if (/(insight|sense motive|discern motive|read emotion|read intent|detect lie|intuition|gut feeling|hunch|perceive motive|perceive intent|understand motive|understand intent)/.test(lower)) {
    return { rollType: "Insight Check", difficulty: 12 };
  }
  // Investigation
  if (/(investigat|search for clues|examin|inspect|analy[sz]e|scrutinize|probe|study|investigation|look for evidence|find evidence|detect|deduce|uncover|solve|research|inquire|delve|explore|question|interrogate)/.test(lower)) {
    return { rollType: "Investigation Check", difficulty: 14 };
  }
  // Nature
  if (/(nature|identify plant|identify animal|recognize animal|recognize plant|natural world|wilderness lore|herbalism|animal lore|plant lore|track animal|animal tracks|plant identification|forage|herb|flora|fauna)/.test(lower)) {
    return { rollType: "Nature Check", difficulty: 13 };
  }
  // Animal Handling
  if (/(animal handling|calm animal|train animal|control animal|soothe animal|befriend animal|command animal|handle animal|ride animal|mount animal|tame|break horse|lead animal|animal empathy|pet|feed animal|groom animal)/.test(lower)) {
    return { rollType: "Animal Handling Check", difficulty: 12 };
  }
  // Medicine
  if (/(medicine|heal|treat wound|bandage|diagnose|cure|first aid|medical|doctor|nurse|tend wound|set bone|apply poultice|stop bleeding|check pulse|revive|resuscitate|medic|herbal remedy|herbal medicine)/.test(lower)) {
    return { rollType: "Medicine Check", difficulty: 12 };
  }
  // History
  if (/(history|recall history|remember event|ancient|legend|lore|historical|present event|old story|ancestry|genealogy|chronicle|record|archive|historian|antiquity|antique|artifact|relic|old tale|old legend)/.test(lower)) {
    return { rollType: "History Check", difficulty: 12 };
  }
  // Arcana
  if (/(arcana|magic|spell|identify spell|recognize spell|magical|arcane|wizardry|sorcery|enchantment|rune|glyph|sigil|ritual|incantation|occult|mystic|eldritch|divination|conjuration|abjuration|evocation|illusion|necromancy|transmutation|spellcraft|magical knowledge)/.test(lower)) {
    return { rollType: "Arcana Check", difficulty: 14 };
  }
  // Sleight of Hand
  if (/(sleight of hand|pickpocket|palm|conceal object|quick fingers|legerdemain|trickery|filch|swipe|steal|lift|plant|switch|swap|hand trick|card trick|coin trick|nimble fingers|deft fingers|dexterous fingers|slide of hand)/.test(lower)) {
    return { rollType: "Sleight of Hand Check", difficulty: 14 };
  }
  // Performance
  if (/(perform|performance|sing|dance|play instrument|recite|act|entertain|show|display talent|put on show|storytell|orate|speech|monologue|soliloquy|juggle|acrobatics performance|musical|theater|theatre|comedy|drama|improv|recital|concert|showcase|presentation)/.test(lower)) {
    return { rollType: "Performance Check", difficulty: 12 };
  }
  // Perception (keep last, as it's a common fallback)
  if (/(perceiv|perception|look|figure out|search|spot|notice|discern|determine|find|sense|scan|study|observe|see|hear|smell|taste|touch|listen|watch|glance|peek|peer|survey|examine|inspect|observe|check|detect|discover|recognize|identify|locate|explore|scout|patrol|monitor|track|survey|scrutinize|investigate)/.test(lower)) {
    return { rollType: "Perception Check", difficulty: 14 };
  }
  return null;
}

export async function getRollModifier(context: { scenario: unknown; rollRequirement: unknown; character: unknown }) {
  console.log('[getRollModifier] === STARTING MODIFIER CALCULATION ===')
  console.log('[getRollModifier] Input context:', JSON.stringify(context, null, 2))
  
  // First, calculate base attribute modifier
  const rollType = typeof context.rollRequirement === 'object' && 
                  context.rollRequirement !== null && 
                  'rollType' in context.rollRequirement ? 
                  String(context.rollRequirement.rollType) : ''
  
  console.log('[getRollModifier] Extracted roll type:', rollType)
  console.log('[getRollModifier] Character data being passed to calculateAttributeModifier:', JSON.stringify(context.character, null, 2))
  
  const { calculateAttributeModifier } = await import('@/lib/utils/modifier-utils')
  const baseAttributeModifier = calculateAttributeModifier(context.character, rollType)
  
  console.log('[getRollModifier] Base attribute modifier calculated:', baseAttributeModifier)
  
  // Then get situational modifier from LLM
  const prompt = `
Given the following scenario, roll requirement, and character (paying attention to their archetype, skills, and how they might interact with the environment), determine if there should be an additional situational bonus or penalty (modifier) to the roll.
This modifier should reflect:
1. Environmental factors (e.g., darkness, weather, noise).
2. How the character's specific archetype (e.g., a Ranger's attunement to forests, a Rogue's expertise in shadows) or skills (e.g., Survival, Stealth, Perception proficiency in certain conditions) would uniquely affect their performance in THIS specific situation.

Note: The character's raw ability score modifier (e.g., from Wisdom for Perception) has ALREADY been factored in. You are to provide ONLY the *additional* modifier based on the situation and the character's specific fitness for it.

Scenario: ${JSON.stringify(context.scenario, null, 2)}
Roll Requirement: ${JSON.stringify(context.rollRequirement, null, 2)}
Character: ${JSON.stringify(context.character, null, 2)}

Respond in JSON: { "modifier": number } (can be negative, zero, or positive).
`;
  console.log('[getRollModifier] LLM prompt for situational modifier:', prompt)
  
  const result = await generateObject({ prompt, schema: rollModifierSchema });
  const situationalModifier = result.object?.modifier ?? 0;
  
  console.log('[getRollModifier] LLM result object:', JSON.stringify(result.object, null, 2))
  console.log('[getRollModifier] Situational modifier from LLM:', situationalModifier)
  
  // Combine base attribute modifier with situational modifier
  const totalModifier = baseAttributeModifier + situationalModifier;
  
  console.log(`[getRollModifier] === FINAL CALCULATION ===`)
  console.log(`[getRollModifier] Roll Type: "${rollType}"`)
  console.log(`[getRollModifier] Base Attribute Modifier: ${baseAttributeModifier}`)
  console.log(`[getRollModifier] Situational Modifier: ${situationalModifier}`)
  console.log(`[getRollModifier] Total Modifier: ${totalModifier}`)
  console.log(`[getRollModifier] === END MODIFIER CALCULATION ===`)
  
  return totalModifier;
}

/**
 * Appends new narrative content to the previous narrative, ensuring consistent formatting.
 * Does NOT attempt to diff or remove duplication—callers must ensure newContent is truly new.
 * @param previousNarrative The narrative so far
 * @param newContent The new narrative content to append (string or array of strings)
 * @returns The updated narrative
 */
export function appendNarrative(previousNarrative: string, newContent: string | string[]): string {
  const toAppend = Array.isArray(newContent) ? newContent.filter(Boolean).join('\n') : newContent;
  if (!toAppend) return previousNarrative || '';
  if (!previousNarrative) return toAppend;
  // Always separate with two newlines for clarity
  return previousNarrative.trimEnd() + '\n\n' + toAppend.trimStart();
} 

/*
  File: lib/services/npc-turn-service.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/services/npc-turn-service.ts
  Directory: lib/services
*/

--- File: lib/services/npc-turn-service.ts ---

import { z } from "zod";
import { generateObject } from "@/lib/ai";
import { getRollRequirementForAction } from "@/lib/services/roll-requirement-service";
import { getRollModifier, appendNarrative } from "@/lib/services/narrative-service";
import { rollD20 } from "@/lib/utils";
import type { Turn, TurnCharacter } from "@/types/adventure";
import { convex } from "@/lib/convex/server";
import { api } from "@/convex/_generated/api";
import type { Id } from "@/convex/_generated/dataModel";
import { analyzeAndApplyDiceRoll } from "@/lib/services/turn-update-service";
import { readJsonFromS3 } from "@/lib/s3-utils";
import type { AdventurePlan, AdventureEncounter } from "@/types/adventure-plan";

// Step 1: Schema for LLM to decide NPC action
const npcActionSchema = z.object({
  actionSummary: z.string(), // e.g. "The goblin tries to sneak behind the hero and attack."
  narrative: z.string(), // Narrative update for the action
  actionType: z.enum(["attack", "skill", "skip", "pass", "other"]).default("other"), // Explicit action type
  effects: z.array(z.object({
    targetId: z.string(),
    equipmentToAdd: z.array(z.object({
      name: z.string(),
      description: z.string().optional(),
    })).optional(),
  })).optional(),
});

// Step 2: Schema for LLM to decide outcome of the action after roll
const npcActionOutcomeSchema = z.object({
  narrative: z.string(), // Narrative update for the outcome
  effects: z.array(z.object({
    targetId: z.string(),
    healthPercentDelta: z.number().optional(),
    status: z.string().optional(),
    equipmentToAdd: z.array(z.object({
      name: z.string(),
      description: z.string().optional(),
    })).optional(),
  })),
});

export async function processNpcTurnWithLLM({
  turn,
  npcId,
  encounterContext,
  sectionContext,
  sceneContext,
  adventureOverview,
}: {
  turn: Turn;
  npcId: string;
  encounterContext?: { intro?: string; instructions?: string };
  sectionContext?: { title?: string; summary?: string };
  sceneContext?: { title?: string; summary?: string };
  adventureOverview?: string;
}): Promise<{
  updatedNarrative: string;
  updatedCharacters: TurnCharacter[];
  actionSummary: string;
  rollInfo?: { rollType: string; difficulty: number; baseRoll: number; modifier: number; result: number; success: boolean };
  effects?: Array<{ targetId: string; healthPercentDelta?: number; status?: string; equipmentToAdd?: Array<{name: string, description?: string}> }>;
  shortcode?: string;
  narrativeToAppend: string;
}> {
  // Log new context fields
  if (adventureOverview) console.log("[NPC TURN] Adventure Overview:", adventureOverview);
  if (sectionContext) {
    console.log("[NPC TURN] Section Title:", sectionContext.title);
    console.log("[NPC TURN] Section Summary:", sectionContext.summary);
  }
  if (sceneContext) {
    console.log("[NPC TURN] Scene Title:", sceneContext.title);
    console.log("[NPC TURN] Scene Summary:", sceneContext.summary);
  }
  // 1. LLM decides NPC action
  const npc = turn.characters.find((c) => c.id === npcId);
  if (!npc) throw new Error("NPC not found");
  const narrativeContext = (turn.narrative || "").split(/\n\n+/).slice(-2).join("\n\n");
  const playerCharactersForPrompt1 = turn.characters.filter(c => c.type === 'pc');
  const playerCharacterNamesForPrompt1 = playerCharactersForPrompt1.map(c => c.name);
  // Build context string for prompt
  const contextString = [
    adventureOverview ? `Adventure Overview: ${adventureOverview}` : "",
    sectionContext && (sectionContext.title || sectionContext.summary) ? `Section Title: ${sectionContext.title || ""}\nSection Summary: ${sectionContext.summary || ""}` : "",
    sceneContext && (sceneContext.title || sceneContext.summary) ? `Scene Title: ${sceneContext.title || ""}\nScene Summary: ${sceneContext.summary || ""}` : "",
    encounterContext?.intro ? `Encounter Intro: ${encounterContext.intro}` : "",
    encounterContext?.instructions ? `Encounter Instructions: ${encounterContext.instructions}` : "",
    narrativeContext ? `Recent Narrative:\n${narrativeContext}` : "",
  ].filter(Boolean).join("\n\n");

  const prompt1 = `You are the DM for a tabletop RPG. Given the following context, decide what action the NPC should take this turn. Be creative and act as a real DM would. Output a short narrative for the action.

${contextString}

IMPORTANT: If the NPC would realistically speak during this action (conversations, negotiations, threats, commands, etc.), include their actual dialogue in quotes. However, if the NPC is a non-speaking creature (like a mindless beast or monster) or the action doesn't involve speaking (pure physical actions, stealth, etc.), use descriptive narrative instead.

If the NPC would realistically skip or pass their turn (e.g., waiting, observing, preparing, doing nothing), set actionType to "skip" or "pass" and provide appropriate narrative. For example:
- Skip action: 'The goblin scout remains hidden in the shadows, carefully observing the party's movements before making his next move.'
- Pass action: 'The wounded orc takes a defensive stance, catching his breath and waiting for an opening.'

Examples:
- Speaking NPC: 'Silas steps forward, his voice calm but firm. "We need to complete this task quickly and quietly," he says, his eyes scanning the area for threats.'
- Non-speaking creature: 'The dire wolf snarls, its hackles raised as it prepares to pounce on the nearest target.'
- Physical action: 'The guard silently draws his sword, positioning himself to block the exit.'

If the NPC's action involves giving items to a player character, include an "effects" array. Each object in "effects" should have a "targetId" (the ID of the character receiving items) and an "equipmentToAdd" array listing the items ({name: string, description?: string}).

Only include the NPC in the short narrative output: ${npc.name}
Targetable Player Characters: ${playerCharacterNamesForPrompt1.join(', ')} (IDs: ${playerCharactersForPrompt1.map(c => c.id).join(', ')})

Respond as JSON:
{
  actionSummary: string,
  narrative: string,
  actionType: "attack" | "skill" | "skip" | "pass" | "other",
  effects?: [ { targetId: string, equipmentToAdd?: [{name: string, description?: string}] } ]
}`;
  const actionResult = (await generateObject({ prompt: prompt1, schema: npcActionSchema })).object;

  let updatedNarrative = (turn.narrative || "");
  let narrativeToAppend = "";
  let updatedCharacters = [...turn.characters];
  let rollInfo = undefined;
  let effects: Array<{ targetId: string; healthPercentDelta?: number; status?: string; equipmentToAdd?: Array<{name: string, description?: string}> }> | undefined = undefined;
  let shortcode = undefined;

  // 2. Use roll requirement utility to determine if a roll is needed
  const rollRequirement = await getRollRequirementForAction(actionResult.actionSummary, npc);

  // Handle skip/pass actions explicitly
  if (actionResult.actionType === "skip" || actionResult.actionType === "pass") {
    narrativeToAppend = actionResult.narrative;
    updatedCharacters = updatedCharacters.map((c) => {
      if (c.id === npc.id) {
        return {
          ...c,
          hasReplied: true,
          isComplete: true,
          status: actionResult.actionType === "skip" ? "skipping" : "passing",
        };
      }
      return c;
    });
    updatedNarrative = appendNarrative(updatedNarrative, narrativeToAppend);
    return {
      updatedNarrative,
      updatedCharacters,
      actionSummary: actionResult.actionSummary,
      rollInfo: undefined,
      effects: undefined,
      shortcode: undefined,
      narrativeToAppend,
    };
  }

  if (rollRequirement && rollRequirement.rollType && rollRequirement.difficulty) {
    // 3. Get modifier
    const modifier = await getRollModifier({
      scenario: {
        encounterIntro: encounterContext?.intro || "",
        encounterInstructions: encounterContext?.instructions || "",
        narrativeContext: turn.narrative || "",
      },
      rollRequirement,
      character: npc,
    });
    // 4. Perform the roll
    const baseRoll = rollD20();
    const result = baseRoll + (modifier || 0);
    const success = result >= rollRequirement.difficulty;
    rollInfo = {
      rollType: rollRequirement.rollType,
      difficulty: rollRequirement.difficulty,
      baseRoll,
      modifier,
      result,
      success,
    };
    // 5. Build DiceRoll shortcode
    shortcode = `[DiceRoll:rollType=${rollRequirement.rollType};baseRoll=${baseRoll};modifier=${modifier >= 0 ? "+" + modifier : modifier};result=${result};difficulty=${rollRequirement.difficulty};character=${npc.name};image=${npc.image};success=${success}]\n`;
    // 6. LLM: Given the action, roll result, and context, generate the outcome
    const playerCharacters = turn.characters.filter(c => c.type === 'pc');
    const playerCharacterNames = playerCharacters.map(c => c.name);
    const prompt2 = `You are the DM for a tabletop RPG. Given the action, the dice roll result, and the context, write a short narrative describing the outcome. Focus the narrative on the interacting characters. **Do not narrate any actions or dialogue for player characters.**

${contextString}

IMPORTANT: If the NPC would realistically speak during this outcome (expressing success/failure, reactions, taunts, threats, etc.), include their actual dialogue in quotes. However, if the NPC is a non-speaking creature or the outcome doesn't involve speech, use descriptive narrative instead.

Then, output a JSON array of effects for any characters affected (targetId, healthPercentDelta, status). If the NPC's action results in any characters receiving items, specify these in an \`equipmentToAdd\` array (each item as \`{name: string, description?: string}\`) within the corresponding effect object for the target character.

NPC: ${npc.name}
Player Characters: ${playerCharacterNames.join(', ')}
Action: ${actionResult.actionSummary}
Roll Type: ${rollRequirement.rollType}
Roll Result: ${result} (difficulty: ${rollRequirement.difficulty}, success: ${success})

Respond as JSON:
{
  narrative: string,
  effects: [ { targetId: string, healthPercentDelta?: number, status?: string, equipmentToAdd?: [{name: string, description?: string}] } ]
}`;
    const outcomeResult = (await generateObject({ prompt: prompt2, schema: npcActionOutcomeSchema })).object;
    
    console.log("[NPC TURN] LLM-generated outcome result:", JSON.stringify(outcomeResult, null, 2));
    
    narrativeToAppend = (shortcode ? shortcode : "") + (outcomeResult.narrative || "");
    effects = outcomeResult.effects;
    
    console.log("[NPC TURN] Effects to apply:", JSON.stringify(effects, null, 2));
    
    // Log character health BEFORE applying effects
    console.log("[NPC TURN] Character health BEFORE applying effects:");
    updatedCharacters.forEach(c => {
      console.log(`  ${c.name} (${c.id}): ${c.healthPercent}%`);
    });
    
    // Apply effects to characters
    updatedCharacters = updatedCharacters.map((c) => {
      const effect = effects?.find((e) => e.targetId === c.id);
      const updated = { ...c };
      if (effect) {
        console.log(`[NPC TURN] Applying effect to ${c.name} (${c.id}):`, JSON.stringify(effect, null, 2));
        
        if (effect.healthPercentDelta !== undefined) {
          const oldHealth = c.healthPercent ?? 100;
          const newHealth = Math.max(0, oldHealth + effect.healthPercentDelta);
          updated.healthPercent = newHealth;
          console.log(`[NPC TURN] Health update for ${c.name}: ${oldHealth}% -> ${newHealth}% (delta: ${effect.healthPercentDelta})`);
        }
        
        updated.status = effect.status || c.status;
        if (effect.equipmentToAdd && effect.equipmentToAdd.length > 0) {
          const existingEquipment = Array.isArray(c.equipment) ? c.equipment : [];
          updated.equipment = [...existingEquipment, ...effect.equipmentToAdd];
          console.log(`[NPC TURN] Added equipment to ${c.name}:`, effect.equipmentToAdd);
        }
      }
      // Mark this NPC as having acted
      if (c.id === npc.id) {
        updated.hasReplied = true;
        updated.isComplete = true;
      }
      return updated;
    });
    
    // Log character health AFTER applying effects
    console.log("[NPC TURN] Character health AFTER applying effects:");
    updatedCharacters.forEach(c => {
      console.log(`  ${c.name} (${c.id}): ${c.healthPercent}%`);
    });
    
    // Logging for verification
    console.log("[NPC TURN] Roll required. Appending shortcode and outcome narrative...");

    // --- AI health update: analyzeAndApplyDiceRoll ---
    const diceRoll = {
      rollType: rollRequirement.rollType,
      baseRoll,
      modifier,
      result,
      difficulty: rollRequirement.difficulty,
      character: npc.name,
      // Try to infer the target from effects (first effect targetId)
      target: outcomeResult.effects && outcomeResult.effects[0] ? outcomeResult.effects[0].targetId : undefined,
      success,
    };
    
    console.log("[NPC TURN] Calling analyzeAndApplyDiceRoll with diceRoll:", JSON.stringify(diceRoll, null, 2));
    console.log("[NPC TURN] Character health BEFORE analyzeAndApplyDiceRoll:");
    updatedCharacters.forEach(c => {
      console.log(`  ${c.name} (${c.id}): ${c.healthPercent}%`);
    });
    
    const aiTurn = await analyzeAndApplyDiceRoll({
      turn: { ...turn, characters: updatedCharacters },
      diceRoll,
      narrative: appendNarrative(updatedNarrative, narrativeToAppend),
    });
    console.log("[NPC TURN] analyzeAndApplyDiceRoll result:", aiTurn.characters);
    
    // Log detailed comparison of AI updates
    console.log("[NPC TURN] Detailed AI character updates:");
    aiTurn.characters.forEach(aiChar => {
      const origChar = updatedCharacters.find(c => c.id === aiChar.id);
      if (origChar) {
        console.log(`  ${origChar.name} (${aiChar.id}):`);
        if (origChar.healthPercent !== aiChar.healthPercent) {
          console.log(`    Health: ${origChar.healthPercent}% -> ${aiChar.healthPercent}%`);
        }
        if (origChar.status !== aiChar.status) {
          console.log(`    Status: "${origChar.status}" -> "${aiChar.status}"`);
        }
      }
    });
    
    // Merge AI-updated fields into original TurnCharacter objects
    updatedCharacters = updatedCharacters.map(orig =>
      aiTurn.characters.find(ai => ai.id === orig.id)
        ? { ...orig, ...aiTurn.characters.find(ai => ai.id === orig.id) }
        : orig
    );
    
    // Log final character health state
    console.log("[NPC TURN] FINAL character health after AI merge:");
    updatedCharacters.forEach(c => {
      console.log(`  ${c.name} (${c.id}): ${c.healthPercent}%`);
    });
  } else {
    narrativeToAppend = actionResult.narrative;
    effects = actionResult.effects;

    updatedCharacters = updatedCharacters.map((c) => {
      const effect = effects?.find((e) => e.targetId === c.id);
      const updated = { ...c };
      if (effect) {
        if (effect.equipmentToAdd && effect.equipmentToAdd.length > 0) {
          const existingEquipment = Array.isArray(c.equipment) ? c.equipment : [];
          updated.equipment = [...existingEquipment, ...effect.equipmentToAdd];
        }
      }
      // Mark this NPC as having acted
      if (c.id === npc.id) {
        updated.hasReplied = true;
        updated.isComplete = true;
      }
      return updated;
    });
    // Logging for verification
    console.log("[NPC TURN] No roll required. Appending action narrative only:");
    console.log("[NPC TURN] Action narrative:", actionResult.narrative);
    if (effects && effects.length > 0) {
      console.log("[NPC TURN] Effects from no-roll action:", JSON.stringify(effects, null, 2));
    }
  }
  updatedNarrative = appendNarrative(updatedNarrative, narrativeToAppend);

  return {
    updatedNarrative,
    updatedCharacters,
    actionSummary: actionResult.actionSummary,
    rollInfo,
    effects,
    shortcode,
    narrativeToAppend,
  };
}

// Helper function to find encounter in plan
const findEncounterInPlan = (plan: AdventurePlan, encounterId: string): AdventureEncounter | null =>
  plan.sections
    .flatMap(section => section.scenes)
    .flatMap(scene => scene.encounters)
    .find(encounter => encounter.id === encounterId) ?? null;

export async function processNpcTurnsAfterCurrent(turnId: Id<"turns">) {
  let turn = await convex.query(api.adventure.getTurnById, { turnId });
  if (!turn) throw new Error("Turn not found");

  const adventure = await convex.query(api.adventure.getAdventureById, { adventureId: turn.adventureId });
  if (!adventure) throw new Error(`Adventure not found for ID: ${turn.adventureId.toString()}`);

  const plan = (await readJsonFromS3(`settings/${adventure.settingId}/${adventure.planId}.json`)) as AdventurePlan;
  if (!plan || !plan.id || !plan.sections || !plan.title) {
    throw new Error("Adventure plan is missing required fields or could not be loaded");
  }

  // Find current section and scene for context
  let currentSection = undefined;
  let currentScene = undefined;
  for (const section of plan.sections) {
    for (const scene of section.scenes) {
      if (scene.encounters.some(enc => enc.id === turn!.encounterId)) {
        currentSection = section;
        currentScene = scene;
        break;
      }
    }
    if (currentSection && currentScene) break;
  }

  const sectionContext = currentSection ? { title: currentSection.title, summary: currentSection.summary } : undefined;
  const sceneContext = currentScene ? { title: currentScene.title, summary: currentScene.summary } : undefined;
  const adventureOverview = plan.overview || undefined;

  let characters = turn.characters as TurnCharacter[];
  // Take a snapshot of the current initiative order
  const initiativeOrder = characters
    .filter((c) => !c.hasReplied && !c.isComplete)
    .sort((a, b) => (b.initiative ?? 0) - (a.initiative ?? 0));

  for (const char of initiativeOrder) {
    if (char.type !== "npc") break; // Process NPCs in order, then stop

    // Always reload the latest turn state before processing each NPC
    // as previous NPC actions in the same turn might have updated it.
    const currentTurnState = await convex.query(api.adventure.getTurnById, { turnId });
    if (!currentTurnState) {
      console.warn("[NPC TURN] Could not reload turn state, stopping NPC processing for this turn.");
      break;
    }
    turn = currentTurnState; // Update local turn variable
    characters = turn.characters as TurnCharacter[]; // Update local characters variable

    const npc = characters.find((c) => c.id === char.id && c.type === "npc" && !c.hasReplied && !c.isComplete);
    if (!npc) continue; // NPC already processed or no longer eligible

    const currentEncounterDetails = findEncounterInPlan(plan, turn.encounterId);
    let encounterContext: { intro?: string; instructions?: string } = {};
    if (currentEncounterDetails) {
      encounterContext = {
        intro: currentEncounterDetails.intro,
        instructions: currentEncounterDetails.instructions,
      };
    } else {
      console.warn(`[NPC TURN] Could not find details for encounter ${turn.encounterId} in the plan.`);
    }

    // Pass new context fields to processNpcTurnWithLLM
    const result = await processNpcTurnWithLLM({
      turn: { ...turn, id: turn._id, characters },
      npcId: npc.id,
      encounterContext,
      sectionContext,
      sceneContext,
      adventureOverview,
    });
    // Use appendNarrative utility for consistent narrative updates
    const newNarrative = appendNarrative(turn!.narrative || "", result.narrativeToAppend || "");
    
    await convex.mutation(api.turns.updateTurn, {
      turnId: turn._id,
      patch: {
        characters: result.updatedCharacters,
        narrative: newNarrative,
        updatedAt: Date.now(),
      },
    });
  }
} 

/*
  File: lib/services/roll-requirement-service.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/services/roll-requirement-service.ts
  Directory: lib/services
*/

--- File: lib/services/roll-requirement-service.ts ---

import { rollRequirementSchema } from "@/lib/validations/roll-requirement-schema";
import { generateObject } from "@/lib/ai";
import type { Character } from "@/types/character";

/**
 * Given an action or reply string and character context, determine if a dice roll is required.
 * Returns { rollType, difficulty } or null if no roll is required.
 */
export async function getRollRequirementForAction(action: string, character: Character) {
  // Format character context for the prompt
  const contextLines = [
    `Name: ${character.name}`,
    `Archetype: ${character.archetype}`,
    `Race: ${character.race}`,
    character.spells && character.spells.length > 0 ? `Spells: ${character.spells.map(s => s.name).join(", ")}` : undefined,
    character.skills && character.skills.length > 0 ? `Skills: ${character.skills.join(", ")}` : undefined,
    character.equipment && character.equipment.length > 0 ? `Equipment: ${character.equipment.map(e => e.name).join(", ")}` : undefined,
    character.specialAbilities && character.specialAbilities.length > 0 ? `Special Abilities: ${character.specialAbilities.join(", ")}` : undefined,
  ].filter(Boolean);
  const characterContext = contextLines.length > 0 ? `Character Context:\n${contextLines.join("\n")}\n` : "";

  const prompt = `
${characterContext}
Given the following player or NPC action, determine if a dice roll is required for the character to attempt the action. If a roll is required, return a JSON object with "rollType" (choose the most appropriate from the list below) and "difficulty" (a number between 5 and 25). If no roll is required, return the JSON value null (not a string).

Use the character's spells, skills, equipment, special abilities, archetype, and race to determine the most appropriate roll type and difficulty. If the action involves casting a spell (e.g., 'casts charm person', 'casts fireball'), use 'Spellcasting Check' as the rollType, unless the spell is an attack (then use 'Attack Roll').

When assigning difficulty, use the following guidance:
- The average/typical difficulty should be 10 or 11 for most normal actions.
- Use 5 for very easy actions, 6-9 for easy, 10-11 for average actions, 15+ for hard actions, and 18-20 for very hard or nearly impossible actions.
- Most actions should be around 10 or 11 unless the action is clearly much easier or harder than normal.

Possible roll types:
- Perception Check
- Investigation Check
- Insight Check
- Stealth Check
- Athletics Check
- Acrobatics Check
- Survival Check
- Nature Check
- Arcana Check
- History Check
- Medicine Check
- Animal Handling Check
- Persuasion Check
- Deception Check
- Intimidation Check
- Performance Check
- Sleight of Hand Check
- Strength Check
- Dexterity Check
- Constitution Check
- Intelligence Check
- Wisdom Check
- Charisma Check
- Attack Roll
- Spellcasting Check
- Saving Throw
- Initiative Roll
- Luck Check
- Reflex Saving Throw
- Fortitude Saving Throw
- Will Saving Throw
- Concentration Check
- Endurance Check
- Religion Check
- Technology Check
- Engineering Check
- Piloting Check
- Driving Check
- Climbing Check
- Swimming Check
- Jumping Check
- Disguise Check
- Bluff Check
- Sense Motive Check
- Use Magic Device Check
- Use Rope Check
- Escape Artist Check
- Appraise Check
- Disable Device Check
- Knowledge (Any) Check
- Perform (Any) Check
- Craft (Any) Check
- Profession (Any) Check
- Read Lips Check
- Tumble Check
- Balance Check
- Ride Check
- Handle Animal Check
- Gather Information Check
- Search Check
- Listen Check
- Spot Check
- Open Lock Check
- Forgery Check
- Diplomacy Check
- Intuition Check
- Morale Check
- Sanity Check
- Willpower Check
- Faith Check
- Social Check
- Streetwise Check
- Investigation Check
- Technology Use Check
- Computer Use Check
- Hacking Check
- Science Check
- Alchemy Check
- Herbalism Check
- Tracking Check
- Navigation Check
- Weather Sense Check
- Cooking Check
- Brewing Check
- Gambling Check
- Barter Check
- Leadership Check
- Strategy Check
- Tactics Check
- Animal Empathy Check
- Psionics Check
- Telepathy Check
- Intuition Check

Examples:
Action: "Try to sneak past the guards."
Result: { "rollType": "Stealth Check", "difficulty": 12 }

Action: "Attack the goblin."
Result: { "rollType": "Attack Roll", "difficulty": 10 }

Action: "Try to determine what the sound is."
Result: { "rollType": "Perception Check", "difficulty": 8 }

Action: "Say hello."
Result: null

Action: "Lyra casts charm person on Silas."
Result: { "rollType": "Spellcasting Check", "difficulty": 11 }

Now, given the following action, determine the roll requirement.

Action: "${action}"
`;
  try {
    const result = await generateObject({
      schema: rollRequirementSchema,
      prompt,
    });
    if (
      result.object &&
      typeof result.object === "object" &&
      "rollType" in result.object &&
      (result.object.rollType === "null" || result.object.rollType === "none" || result.object.rollType === "")
    ) {
      return null;
    }
    return result.object ?? null;
  } catch (error) {
    throw error;
  }
} 

/*
  File: lib/services/turn-update-service.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/services/turn-update-service.ts
  Directory: lib/services
*/

--- File: lib/services/turn-update-service.ts ---

import { generateObject } from "@/lib/ai";
import { z } from "zod";
import type { Turn, DiceRoll } from "@/types/adventure";

// Zod schema for the AI's expected output
const characterUpdateSchema = z.object({
  id: z.string(), // character id
  healthPercent: z.number().min(0).max(100),
  status: z.string().optional(),
});

/**
 * Extracts the narrative text that follows the last [DiceRoll:...] shortcode.
 */
function extractNarrativeAfterLastDiceRoll(narrative: string): string | null {
  const diceRollRegex = /\[DiceRoll:[^\]]+\]/g;
  let match: RegExpExecArray | null;
  let lastIndex = -1;
  while ((match = diceRollRegex.exec(narrative)) !== null) {
    lastIndex = match.index + match[0].length;
  }
  if (lastIndex === -1) return null;
  return narrative.slice(lastIndex).trim();
}

/**
 * Uses generateObject to analyze the most recent dice roll and outcome narrative,
 * and returns an updated turn object with the character's healthPercent and status updated as needed.
 */
export async function analyzeAndApplyDiceRoll({
  turn,
  diceRoll,
  narrative,
}: {
  turn: Turn;
  diceRoll: DiceRoll;
  narrative: string;
}): Promise<Turn> {
  // Extract only the narrative following the last dice roll shortcode
  const relevantNarrative = extractNarrativeAfterLastDiceRoll(narrative);

  if (!relevantNarrative) {
    // If we can't find the relevant narrative, return the turn unchanged
    return turn;
  }

  // Determine if this is a natural 1 or 20, or calculate performance delta
  let narrativeGuidance = "";
  
  if (diceRoll.baseRoll === 1) {
    narrativeGuidance = "This was a catastrophic failure. The narrative should reflect dramatic, unexpected negative consequences that go beyond a simple failure.";
  } else if (diceRoll.baseRoll === 20) {
    narrativeGuidance = "This was a spectacular success. The narrative should reflect exceptional, dramatically positive outcomes that exceed normal success.";
  } else {
    const delta = diceRoll.result - diceRoll.difficulty;
    if (delta > 0) {
      narrativeGuidance = `This was a success that exceeded the target by ${delta} points. The narrative should reflect how well the action was performed.`;
    } else {
      narrativeGuidance = `This was a failure that missed the target by ${Math.abs(delta)} points. The narrative should reflect the degree of the failure.`;
    }
  }

  // Compose a prompt for the AI
  const prompt = `
Given the outcome narrative and performance context, decide if any character's healthPercent or status should be updated. Only update if the narrative describes harm, healing, or a condition change.

${narrativeGuidance}

Outcome Narrative: ${relevantNarrative}
Current Characters: ${JSON.stringify(turn.characters)}

Return an object with the character id, new healthPercent (0-100), and optional status if any changes are warranted.
`;

  // Call the AI
  const update = await generateObject({
    prompt,
    schema: characterUpdateSchema,
  });

  console.log("[analyzeAndApplyDiceRoll] update:", JSON.stringify(update.object, null, 2))

  // If the AI didn't return a valid update, return the turn unchanged
  if (!update.object || !update.object.id) return turn;

  // Find and update the character in the turn
  const updatedCharacters = turn.characters.map((c) =>
    c.id === update.object.id
      ? {
          ...c,
          healthPercent: typeof update.object.healthPercent === "number" ? update.object.healthPercent : c.healthPercent,
        }
      : c
  );

  // Return the updated turn
  return {
    ...turn,
    characters: updatedCharacters,
  };
} 

/*
  File: lib/services/visits.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/services/visits.ts
  Directory: lib/services
*/

--- File: lib/services/visits.ts ---

import { convex, api } from "@/lib/convex/server";

/**
 * Records a new visit to a page
 */
export async function recordVisit(data: {
  path: string;
  userId: string | null;
  metadata: Record<string, unknown>;
}) {
  return await convex.mutation(api.visits.recordVisit, data);
}

/**
 * Gets visits for a specific user
 */
export async function getVisitsByUser(userId: string | null, limit?: number) {
  return await convex.query(api.visits.getVisits, { userId, limit });
}

/**
 * Gets visits for a specific path
 */
export async function getVisitsByPath(path: string, limit?: number) {
  return await convex.query(api.visits.getVisitsByPath, { path, limit });
}

/**
 * Gets all visits
 */
export async function getAllVisits(limit?: number) {
  return await convex.query(api.visits.getVisits, { limit });
} 

/*
  File: lib/stripe.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/stripe.ts
  Directory: lib
*/

--- File: lib/stripe.ts ---

import Stripe from "stripe"

// Environment variables
const stripeSecretKey = process.env.STRIPE_SECRET_KEY

// Log missing variables in development only
if (process.env.NODE_ENV === 'development' && !stripeSecretKey) {
  console.warn('Missing Stripe secret key environment variable')
}

// Function to check if Stripe is configured
export function isStripeConfigured(): boolean {
  return Boolean(stripeSecretKey)
}

// Create a Stripe instance if configured
export const stripe = stripeSecretKey
  ? new Stripe(stripeSecretKey, {
      apiVersion: "2025-04-30.basil",
    })
  : null

// Function to check Stripe connection
export async function checkStripeConnection(): Promise<{
  success: boolean
  message: string
  details?: {
    error?: unknown
  }
}> {
  if (!isStripeConfigured()) {
    return {
      success: false,
      message: 'Stripe is not configured',
      details: {
        error: 'Missing required environment variables'
      }
    }
  }

  try {
    // Try to make a simple API call to verify connection
    await stripe?.balance.retrieve()
    
    return {
      success: true,
      message: 'Successfully connected to Stripe'
    }
  } catch (err) {
    console.error('Unexpected error checking Stripe connection:', err)
    return {
      success: false,
      message: `Unexpected error: ${err instanceof Error ? err.message : String(err)}`,
      details: { error: err }
    }
  }
} 

/*
  File: lib/upload-utils.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/upload-utils.ts
  Directory: lib
*/

--- File: lib/upload-utils.ts ---

"use client"

import { useState } from "react"

interface UploadOptions {
  folder?: string
  maxSize?: number // in bytes
  allowedTypes?: string[]
}

const defaultOptions: UploadOptions = {
  folder: "uploads",
  maxSize: 10 * 1024 * 1024, // 10MB
  allowedTypes: ["image/jpeg", "image/png", "image/webp", "image/gif", "image/svg+xml"],
}

export async function uploadFile(file: File, options: UploadOptions = {}): Promise<string> {
  const { folder = "uploads", maxSize, allowedTypes } = { ...defaultOptions, ...options }

  if (!file) {
    throw new Error("No file provided")
  }

  // Validate file type if allowedTypes is provided
  if (allowedTypes && !allowedTypes.includes(file.type)) {
    throw new Error(`File type not allowed. Please upload one of: ${allowedTypes.join(", ")}`)
  }

  // Validate file size if maxSize is provided
  if (maxSize && file.size > maxSize) {
    throw new Error(`File size exceeds ${Math.round(maxSize / (1024 * 1024))}MB limit`)
  }

  const formData = new FormData()
  formData.append("file", file)
  formData.append("folder", folder)

  try {
    const response = await fetch("/api/upload", {
      method: "POST",
      body: formData,
    })

    if (!response.ok) {
      const data = await response.json()
      throw new Error(data.error || "Failed to upload file")
    }

    const data = await response.json()
    return data.url
  } catch (error) {
    console.error("Error uploading file:", error)
    throw error
  }
}

export function useFileUpload(options: UploadOptions = {}) {
  const [isUploading, setIsUploading] = useState(false)

  const upload = async (file: File): Promise<string> => {
    setIsUploading(true)
    try {
      const url = await uploadFile(file, options)
      return url
    } finally {
      setIsUploading(false)
    }
  }

  return {
    upload,
    isUploading,
  }
} 

/*
  File: lib/utils/case-transforms.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/utils/case-transforms.ts
  Directory: lib/utils
*/

--- File: lib/utils/case-transforms.ts ---

import { camelCase, snakeCase } from 'lodash-es'

// Type transformations for TypeScript type system
type CamelToSnakeCase<S extends string> = S extends `${infer T}${infer U}`
  ? T extends Uppercase<T>
    ? `_${Lowercase<T>}${CamelToSnakeCase<U>}`
    : `${T}${CamelToSnakeCase<U>}`
  : S

type SnakeToCamelCase<S extends string> = S extends `${infer T}_${infer U}`
  ? `${T}${Capitalize<SnakeToCamelCase<U>>}`
  : S

type TransformKeys<T, Transform extends (str: string) => string> = T extends object
  ? {
      [K in keyof T as K extends string
        ? string extends K
          ? string
          : Transform extends typeof snakeCase
            ? Uncapitalize<CamelToSnakeCase<K>>
            : Uncapitalize<SnakeToCamelCase<K>>
        : K]: T[K] extends object
        ? TransformKeys<T[K], Transform>
        : T[K]
    }
  : T

/**
 * Transforms an object's keys from camelCase to snake_case recursively
 */
export function toSnakeCase<T extends object>(obj: T): TransformKeys<T, typeof snakeCase> {
  if (Array.isArray(obj)) {
    return obj.map((item) =>
      typeof item === 'object' ? toSnakeCase(item) : item
    ) as TransformKeys<T, typeof snakeCase>
  }

  if (obj === null || typeof obj !== 'object') {
    return obj as TransformKeys<T, typeof snakeCase>
  }

  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => [
      snakeCase(key),
      typeof value === 'object' ? toSnakeCase(value) : value,
    ])
  ) as TransformKeys<T, typeof snakeCase>
}

/**
 * Transforms an object's keys from snake_case to camelCase recursively
 */
export function toCamelCase<T extends object>(obj: T): TransformKeys<T, typeof camelCase> {
  if (Array.isArray(obj)) {
    return obj.map((item) =>
      typeof item === 'object' ? toCamelCase(item) : item
    ) as TransformKeys<T, typeof camelCase>
  }

  if (obj === null || typeof obj !== 'object') {
    return obj as TransformKeys<T, typeof camelCase>
  }

  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => [
      camelCase(key),
      typeof value === 'object' ? toCamelCase(value) : value,
    ])
  ) as TransformKeys<T, typeof camelCase>
}

/**
 * Alias for toCamelCase, used for consistency with existing codebase
 */
export const deepToCamelCase = toCamelCase

/**
 * Type helper to convert a type from camelCase to snake_case
 * @example
 * interface UserInput {
 *   firstName: string
 *   lastName: string
 * }
 * 
 * type DatabaseUser = ToSnakeCase<UserInput>
 * // Result: { first_name: string, last_name: string }
 */
export type ToSnakeCase<T> = TransformKeys<T, typeof snakeCase>

/**
 * Type helper to convert a type from snake_case to camelCase
 * @example
 * interface DatabaseUser {
 *   first_name: string
 *   last_name: string
 * }
 * 
 * type ClientUser = ToCamelCase<DatabaseUser>
 * // Result: { firstName: string, lastName: string }
 */
export type ToCamelCase<T> = TransformKeys<T, typeof camelCase>

// Types for backward compatibility
export type Primitive = string | number | boolean | null | undefined
export type TransformableObject = { [key: string]: Transformable }
export type TransformableArray = Transformable[]
export type Transformable = Primitive | TransformableObject | TransformableArray 

/*
  File: lib/utils/modifier-utils.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/utils/modifier-utils.ts
  Directory: lib/utils
*/

--- File: lib/utils/modifier-utils.ts ---

import type { Attributes } from "@/types/character"

/**
 * Calculate D&D-style ability modifier from ability score
 * 10-11 = +0, 12-13 = +1, 8-9 = -1, etc.
 */
export function getAbilityModifier(score: number): number {
  const modifier = Math.floor((score - 10) / 2)
  console.log(`[getAbilityModifier] Score ${score} → modifier ${modifier}`)
  return modifier
}

/**
 * Map roll types to their primary attribute
 */
export function getPrimaryAttributeForRoll(rollType: string): keyof Attributes | null {
  const rollTypeLower = rollType.toLowerCase()
  
  // Strength-based
  if (rollTypeLower.includes('athletics') || rollTypeLower.includes('strength')) {
    console.log(`[getPrimaryAttributeForRoll] "${rollType}" → strength`)
    return 'strength'
  }
  
  // Dexterity-based  
  if (rollTypeLower.includes('stealth') || 
      rollTypeLower.includes('acrobatics') || 
      rollTypeLower.includes('sleight of hand') ||
      rollTypeLower.includes('dexterity')) {
    console.log(`[getPrimaryAttributeForRoll] "${rollType}" → dexterity`)
    return 'dexterity'
  }
  
  // Constitution-based
  if (rollTypeLower.includes('constitution') || 
      rollTypeLower.includes('endurance')) {
    console.log(`[getPrimaryAttributeForRoll] "${rollType}" → constitution`)
    return 'constitution'
  }
  
  // Intelligence-based
  if (rollTypeLower.includes('investigation') ||
      rollTypeLower.includes('arcana') ||
      rollTypeLower.includes('history') ||
      rollTypeLower.includes('nature') ||
      rollTypeLower.includes('religion') ||
      rollTypeLower.includes('intelligence')) {
    console.log(`[getPrimaryAttributeForRoll] "${rollType}" → intelligence`)
    return 'intelligence'
  }
  
  // Wisdom-based
  if (rollTypeLower.includes('perception') ||
      rollTypeLower.includes('insight') ||
      rollTypeLower.includes('medicine') ||
      rollTypeLower.includes('survival') ||
      rollTypeLower.includes('animal handling') ||
      rollTypeLower.includes('wisdom')) {
    console.log(`[getPrimaryAttributeForRoll] "${rollType}" → wisdom`)
    return 'wisdom'
  }
  
  // Charisma-based
  if (rollTypeLower.includes('persuasion') ||
      rollTypeLower.includes('deception') ||
      rollTypeLower.includes('intimidation') ||
      rollTypeLower.includes('performance') ||
      rollTypeLower.includes('charisma')) {
    console.log(`[getPrimaryAttributeForRoll] "${rollType}" → charisma`)
    return 'charisma'
  }
  
  console.log(`[getPrimaryAttributeForRoll] "${rollType}" → no matching attribute`)
  return null
}

/**
 * Calculate base mechanical modifier from character attributes for a given roll type
 */
export function calculateAttributeModifier(character: unknown, rollType: string): number {
  console.log(`[calculateAttributeModifier] Processing character for "${rollType}":`)
  console.log('[calculateAttributeModifier] Character data:', JSON.stringify(character, null, 2))
  
  // Type guard to check if character has attributes
  if (!character || 
      typeof character !== 'object' || 
      !('attributes' in character) || 
      !character.attributes ||
      typeof character.attributes !== 'object') {
    console.log('[calculateAttributeModifier] No valid attributes found, returning 0')
    return 0
  }
  
  const primaryAttribute = getPrimaryAttributeForRoll(rollType)
  if (!primaryAttribute) {
    console.log('[calculateAttributeModifier] No primary attribute mapped, returning 0')
    return 0
  }
  
  const attributes = character.attributes as Record<string, unknown>
  console.log('[calculateAttributeModifier] Character attributes:', JSON.stringify(attributes, null, 2))
  
  const attributeScore = attributes[primaryAttribute]
  console.log(`[calculateAttributeModifier] ${primaryAttribute} score:`, attributeScore)
  
  if (typeof attributeScore !== 'number') {
    console.log(`[calculateAttributeModifier] ${primaryAttribute} is not a number, returning 0`)
    return 0
  }
  
  const modifier = getAbilityModifier(attributeScore)
  console.log(`[calculateAttributeModifier] Final result: ${primaryAttribute} ${attributeScore} → modifier ${modifier}`)
  return modifier
} 

/*
  File: lib/utils/parse-narrative.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/utils/parse-narrative.ts
  Directory: lib/utils
*/

--- File: lib/utils/parse-narrative.ts ---

// Utility to parse narrative with [DiceRoll:rollType=...;result=...;difficulty=...;character=...;image=...;success=...]

export type NarrativePart =
  | { type: 'paragraph'; value: string }
  | { type: 'diceroll'; rollType: string; baseRoll?: number; modifier?: number; result: number; difficulty: number; character: string; image?: string; success: boolean };

const diceRollRegex = /^\[DiceRoll:([^\]]+)\]$/i;

export function parseNarrative(narrative: string): NarrativePart[] {
  // Convert escaped newlines to actual newlines
  const processedNarrative = narrative.replace(/\\n/g, '\n');
  
  return processedNarrative.split(/\n/).map<NarrativePart>(line => {
    const trimmed = line.trim();
    const match = trimmed.match(diceRollRegex);
    if (match) {
      // Parse key=value pairs
      const fields = Object.fromEntries(
        match[1].split(';').map(pair => {
          const [key, ...rest] = pair.split('=');
          return [key.trim(), rest.join('=').trim()];
        })
      );
      return {
        type: 'diceroll',
        rollType: fields.rollType || '',
        baseRoll: fields.baseRoll !== undefined && fields.baseRoll !== '' ? Number(fields.baseRoll) : undefined,
        modifier: fields.modifier !== undefined && fields.modifier !== '' ? Number(fields.modifier) : undefined,
        result: Number(fields.result),
        difficulty: Number(fields.difficulty),
        character: fields.character || '',
        image: fields.image || '',
        success: fields.success === 'true',
      } as const;
    }
    return { type: 'paragraph', value: trimmed } as const;
  }).filter(part => part.type === 'diceroll' || (part.type === 'paragraph' && part.value.length > 0));
} 

/*
  File: lib/utils.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/utils.ts
  Directory: lib
*/

--- File: lib/utils.ts ---

import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"
import { IMAGE_HOST } from "@/lib/config"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

/**
 * Constructs a proper image URL, avoiding doubling up the IMAGE_HOST
 * @param imagePath - The image path (can be relative or absolute URL)
 * @returns A properly constructed image URL
 */
export function getImageUrl(imagePath: string): string {
  if (!imagePath) return imagePath

  // If it's already a full URL (starts with http:// or https://), return as-is
  if (imagePath.startsWith("http://") || imagePath.startsWith("https://")) {
    return imagePath
  }

  // If it's already prefixed with our IMAGE_HOST, return as-is
  if (imagePath.startsWith(IMAGE_HOST)) {
    return imagePath
  }

  // Remove leading slash from relative path and construct full URL
  const cleanPath = imagePath.replace(/^\/+/, "")
  return `${IMAGE_HOST}/${cleanPath}`
}

/**
 * Strips the IMAGE_HOST from a URL to get the relative path for storage
 * @param url - The full URL or relative path
 * @returns The relative path without IMAGE_HOST
 */
export function stripImageHost(url: string): string {
  if (!url) return url

  // Remove the IMAGE_HOST domain if present
  if (url.startsWith(IMAGE_HOST)) {
    return url.replace(IMAGE_HOST, "").replace(/^\/+/, "") // Remove leading slashes
  }

  // Also handle the case where the URL might be from the CloudFront domain directly
  // Extract domain from IMAGE_HOST to handle both with and without protocols
  const imageHostDomain = IMAGE_HOST.replace(/^https?:\/\//, "")
  if (url.startsWith(`https://${imageHostDomain}/`)) {
    return url.replace(`https://${imageHostDomain}/`, "")
  }
  if (url.startsWith(`http://${imageHostDomain}/`)) {
    return url.replace(`http://${imageHostDomain}/`, "")
  }

  // If it's already a relative path, return as-is
  if (!url.startsWith("http://") && !url.startsWith("https://")) {
    return url
  }

  return url
}

/**
 * Format a date string to a more readable format
 * @param dateString ISO date string
 * @returns Formatted date string (e.g., "Jan 1, 2023")
 */
export function formatDate(dateString: string): string {
  const date = new Date(dateString)
  return date.toLocaleDateString("en-US", {
    month: "short",
    day: "numeric",
    year: "numeric",
  })
}

export function formatCurrency(amount: number) {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(amount)
}

export const getInitials = (name: string) => {
  return name
    .split(" ")
    .map((n) => n[0])
    .join("")
    .toUpperCase()
    .substring(0, 2)
}

export function hasBooleanProp(obj: unknown, prop: string): obj is { [key: string]: boolean } {
  return !!obj && typeof obj === "object" && prop in obj && typeof (obj as { [key: string]: unknown })[prop] === "boolean"
}
export function hasNumberProp(obj: unknown, prop: string): obj is { [key: string]: number } {
  return !!obj && typeof obj === "object" && prop in obj && typeof (obj as { [key: string]: unknown })[prop] === "number"
}
export function isRollRequired(obj: unknown): obj is { rollType: string; difficulty?: number; modifier?: number } {
  return !!obj && typeof obj === "object" && "rollType" in obj
}

/**
 * Map a Convex turn document to the frontend Turn type
 * @param raw Convex turn document
 * @returns Turn or null
 */
export function mapConvexTurnToTurn(raw: unknown): import("@/types/adventure").Turn | null {
  if (!raw || typeof raw !== "object" || !("encounterId" in raw) || !("title" in raw)) return null;
  const t = raw as { _id: string; encounterId: string; title: string; narrative: string; characters: import("@/types/adventure").TurnCharacter[]; adventureId: string; isFinalEncounter?: boolean };
  return {
    id: t._id,
    encounterId: t.encounterId,
    title: t.title,
    narrative: t.narrative,
    characters: t.characters,
    adventureId: t.adventureId,
    isFinalEncounter: t.isFinalEncounter,
  };
}

export function rollD20(): number {
  return Math.floor(Math.random() * 20) + 1;
}

export function formatNumberToK(num: number): string {
  if (num >= 1000000) {
    return (num / 1000000).toFixed(1).replace(/\.0$/, "") + "m";
  }
  if (num >= 1000) {
    return (num / 1000).toFixed(1).replace(/\.0$/, "") + "k";
  }
  return Math.round(num).toString();
}

/**
 * Converts a slugified string back to a readable title
 * @param slug - The slugified string (e.g., "dragon-of-icespire-peak")
 * @returns A readable title with proper capitalization (e.g., "Dragon of Icespire Peak")
 */
export function reverseSlugify(slug: string): string {
  return slug
    .split("-")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(" ")
}


/*
  File: lib/validations/roll-requirement-schema.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/lib/validations/roll-requirement-schema.ts
  Directory: lib/validations
*/

--- File: lib/validations/roll-requirement-schema.ts ---

import { z } from "zod";

export const rollRequirementSchema = z.union([
  z.object({
    rollType: z.string().describe("The type of roll required, e.g. 'Stealth Check'"),
    difficulty: z.number().describe("The difficulty class (DC) for the roll"),
    modifier: z.number().optional().describe("Bonus or penalty to the roll, e.g. +2 or -1"),
  }),
  z.null()
]);

export type RollRequirement = z.infer<typeof rollRequirementSchema>; 

/*
  File: middleware.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/middleware.ts
  Directory: .
*/

--- File: middleware.ts ---

import { clerkMiddleware } from '@clerk/nextjs/server'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export default clerkMiddleware((auth, req: NextRequest) => {
  // Get the default response from Clerk
  const res = NextResponse.next();
  // Set the pathname as a custom header
  res.headers.set('x-pathname', req.nextUrl.pathname);
  return res;
});

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}

/*
  File: next.config.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/next.config.ts
  Directory: .
*/

--- File: next.config.ts ---

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'vibecodeparty-public.s3.us-east-1.amazonaws.com',
      },
      {
        protocol: 'https',
        hostname: 'vibecodeparty-public.s3.amazonaws.com',
      },
      {
        protocol: 'https',
        hostname: 'img.clerk.com',
      },
      {
        protocol: 'https',
        hostname: 'd1dkwd3w4hheqw.cloudfront.net',
      },
    ],
  },
};

export default nextConfig;


/*
  File: package.json
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/package.json
  Directory: .
*/

--- File: package.json ---

{
  "name": "d20adventures.com",
  "version": "0.1.0",
  "license": "None",
  "description": "A new narrative-driven RPG platform that blends play-by-post gameplay and real-time updates facilitated by an AI Game Master.",
  "keywords": [
    "nextjs",
    "template",
    "starter",
    "vibecoding"
  ],
  "author": "johnpolacek",
  "scripts": {
    "kill:ports": "kill-port 3000 4000 4400 4500 5001 8080 8085 9000 9099 9199 || true",
    "dev": "pnpm kill:ports && concurrently \"pnpm convex:dev\" \"next dev -p ${PORT:-3000}\" --kill-others --names \"convex,next\" --prefix-colors \"yellow.bold,cyan.bold\"",
    "convex:dev": "convex dev",
    "convex:deploy": "convex deploy",
    "build": "pnpm generate:routes && next build",
    "postinstall": "npx convex codegen",
    "start": "next start",
    "lint": "next lint",
    "boot:convex": "sh ./scripts/boot-convex.sh",
    "boot:github": "brew install gh && gh auth login",
    "boot:vercel": "pnpm i -g vercel",
    "boot:repo": "chmod +x ./scripts/init-repo.sh && ./scripts/init-repo.sh",
    "boot": "pnpm boot:github && pnpm boot:vercel && pnpm boot:convex && pnpm boot:repo",
    "go": "pnpm generate:routes && git add . && aicommits && pnpm generate:llm && git add . && git commit -m 'update llm.txt' && git push origin main",
    "test:run": "playwright test",
    "test:wait": "wait-on tcp:3000 tcp:4000 && pnpm test:run",
    "test": "pnpm build && concurrently \"pnpm dev\" \"pnpm test:wait\" --success first --kill-others --names \"dev,test\" --prefix-colors \"yellow.bold,cyan.bold\"",
    "ship": "pnpm test && pnpm go",
    "test:clean": "rm -rf ~/.cache/ms-playwright-tests test-results/ playwright-report/",
    "pw": "playwright test --ui --debug",
    "pw:headless": "playwright test",
    "db:admin": "open https://dashboard.convex.dev",
    "generate:routes": "tsx scripts/generate-routes.ts",
    "generate:llm": "tsx scripts/bundle-code.ts . llm.txt",
    "test:setup": "pnpm dev",
    "test:full": "pnpm test:setup && pnpm test"
  },
  "dependencies": {
    "@ai-sdk/google": "^1.2.18",
    "@ai-sdk/openai": "^1.3.22",
    "@ai-sdk/react": "^1.2.12",
    "@ai-sdk/replicate": "^0.2.8",
    "@aws-sdk/client-s3": "^3.812.0",
    "@aws-sdk/s3-request-presigner": "^3.812.0",
    "@clerk/backend": "^1.32.3",
    "@clerk/nextjs": "^6.19.5",
    "@clerk/themes": "^2.2.46",
    "@heroicons/react": "^2.2.0",
    "@octokit/rest": "^21.1.1",
    "@radix-ui/react-accordion": "^1.2.10",
    "@radix-ui/react-alert-dialog": "^1.1.13",
    "@radix-ui/react-avatar": "^1.1.9",
    "@radix-ui/react-checkbox": "^1.3.1",
    "@radix-ui/react-collapsible": "^1.1.10",
    "@radix-ui/react-dialog": "^1.1.13",
    "@radix-ui/react-dropdown-menu": "^2.1.14",
    "@radix-ui/react-hover-card": "^1.1.14",
    "@radix-ui/react-icons": "^1.3.2",
    "@radix-ui/react-label": "^2.1.6",
    "@radix-ui/react-popover": "^1.1.13",
    "@radix-ui/react-progress": "^1.1.6",
    "@radix-ui/react-radio-group": "^1.3.6",
    "@radix-ui/react-scroll-area": "^1.2.8",
    "@radix-ui/react-select": "^2.2.4",
    "@radix-ui/react-separator": "^1.1.6",
    "@radix-ui/react-slot": "^1.2.2",
    "@radix-ui/react-switch": "^1.2.4",
    "@radix-ui/react-tabs": "^1.1.11",
    "@sendgrid/mail": "^8.1.5",
    "@stripe/react-stripe-js": "^3.7.0",
    "@stripe/stripe-js": "^7.3.0",
    "@types/lodash-es": "^4.17.12",
    "@types/react-google-recaptcha": "^2.1.9",
    "ai": "^4.3.16",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "convex": "^1.24.1",
    "date-fns": "^4.1.0",
    "eslint-config-prettier": "^10.1.5",
    "eslint-plugin-prettier": "^5.4.0",
    "ignore": "^7.0.4",
    "lodash-es": "^4.17.21",
    "lucide-react": "^0.511.0",
    "next": "15.3.2",
    "next-themes": "^0.4.6",
    "number-to-words": "^1.2.4",
    "playwright": "link:@clerk/testing/playwright",
    "prettier": "^3.5.3",
    "react": "^19.1.0",
    "react-day-picker": "8.10.1",
    "react-dom": "^19.1.0",
    "react-google-recaptcha": "^3.1.0",
    "react-icons": "^5.5.0",
    "react-markdown": "^10.1.0",
    "server": "link:@clerk/nextjs/server",
    "slugify": "^1.6.6",
    "sonner": "^2.0.3",
    "stripe": "^18.1.1",
    "tailwind-merge": "^3.3.0",
    "tailwindcss-animate": "^1.0.7",
    "uuid": "^11.1.0",
    "waait": "^1.0.5",
    "zod": "^3.25.7",
    "zod-to-json-schema": "^3.24.5"
  },
  "devDependencies": {
    "@clerk/testing": "^1.7.2",
    "@eslint/eslintrc": "^3.3.1",
    "@playwright/test": "^1.52.0",
    "@tailwindcss/postcss": "^4.1.7",
    "@tailwindcss/typography": "^0.5.16",
    "@types/node": "^22.15.19",
    "@types/react": "^19.1.4",
    "@types/react-dom": "^19.1.5",
    "@types/uuid": "^10.0.0",
    "concurrently": "^9.1.2",
    "dotenv": "^16.5.0",
    "dotenv-cli": "^8.0.0",
    "eslint": "^9.27.0",
    "eslint-config-next": "15.3.2",
    "kill-port": "^2.0.1",
    "tailwindcss": "^4.1.7",
    "ts-node": "^10.9.2",
    "tsx": "^4.19.4",
    "typescript": "^5.8.3",
    "wait-on": "^8.0.3"
  }
}

/*
  File: playwright.config.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/playwright.config.ts
  Directory: .
*/

--- File: playwright.config.ts ---

import { defineConfig, devices } from '@playwright/test';
import path from 'path';

/**
 * Read environment variables from file.
 * https://github.com/motdotla/dotenv
 */
import dotenv from 'dotenv';
// Load environment variables in order of precedence (later files take precedence)
dotenv.config({ path: path.resolve(__dirname, '.env') });
dotenv.config({ path: path.resolve(__dirname, '.env.test') });
dotenv.config({ path: path.resolve(__dirname, '.env.local') });

/**
 * See https://playwright.dev/docs/test-configuration.
 */
export default defineConfig({
  testDir: './tests',
  /* Run tests in files in parallel - except in UI mode */
  fullyParallel: false,
  /* Fail the build on CI if you accidentally left test.only in the source code. */
  forbidOnly: !!process.env.CI,
  /* Retry on CI only */
  retries: process.env.CI ? 2 : 0,
  /* Opt out of parallel tests on CI or in UI mode */
  workers: 1,
  /* Reporter to use. See https://playwright.dev/docs/test-reporters */
  reporter: 'html',
  /* Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions. */
  use: {
    /* Base URL to use in actions like `await page.goto('/')`. */
    baseURL: 'http://localhost:3000',

    /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */
    trace: 'on-first-retry',
  },

  /* Configure projects for major browsers */
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },

    // {
    //   name: 'firefox',
    //   use: { ...devices['Desktop Firefox'] },
    // },

    // {
    //   name: 'webkit',
    //   use: { ...devices['Desktop Safari'] },
    // },

    /* Test against mobile viewports. */
    // {
    //   name: 'Mobile Chrome',
    //   use: { ...devices['Pixel 5'] },
    // },
    // {
    //   name: 'Mobile Safari',
    //   use: { ...devices['iPhone 12'] },
    // },

    /* Test against branded browsers. */
    // {
    //   name: 'Microsoft Edge',
    //   use: { ...devices['Desktop Edge'], channel: 'msedge' },
    // },
    // {
    //   name: 'Google Chrome',
    //   use: { ...devices['Desktop Chrome'], channel: 'chrome' },
    // },
  ],

  /* Since we're running the Next.js server separately, we don't need the webServer config */
  // webServer: {
  //   command: 'pnpm dev',
  //   url: 'http://127.0.0.1:3000',
  //   reuseExistingServer: !process.env.CI,
  //   timeout: 120000,
  // },
  
  /* Global setup to run before all tests */
  globalSetup: process.env.PLAYWRIGHT_UI_MODE ? undefined : './tests/global-setup.ts',
});


/*
  File: postcss.config.mjs
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/postcss.config.mjs
  Directory: .
*/

--- File: postcss.config.mjs ---

const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;


/*
  File: scripts/boot-convex.sh
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/scripts/boot-convex.sh
  Directory: scripts
*/

--- File: scripts/boot-convex.sh ---

#!/bin/bash

# Install Convex CLI globally
pnpm add -g convex@latest

# Check for CONVEX_DEPLOYMENT in Convex production environment
DEPLOY_KEY=$(npx convex env --prod get CONVEX_DEPLOYMENT 2>&1)

if echo "$DEPLOY_KEY" | grep -q 'not found'; then
  echo "\n\033[0;31m✖ Environment variable 'CONVEX_DEPLOYMENT' not found.\033[0m"
  echo "\nTo deploy with Convex, you need to set your deploy key."
  echo "1. Visit your Convex dashboard: https://dashboard.convex.dev"
  echo "2. Go to your project settings and copy the Deploy Key."
  echo "3. Add it to your environment variables as CONVEX_DEPLOYMENT."
  echo "\nExample (.env):\nCONVEX_DEPLOYMENT=your-deploy-key-here\n"
  # Try to get CONVEX_DEPLOYMENT from local .env
  if [ -f .env ]; then
    LOCAL_KEY=$(grep '^CONVEX_DEPLOYMENT=' .env | cut -d '=' -f2-)
    if [ -n "$LOCAL_KEY" ]; then
      echo "\033[0;34mFound CONVEX_DEPLOYMENT in local .env. Attempting to add to Vercel production env...\033[0m"
      TMPFILE=$(mktemp)
      echo "$LOCAL_KEY" > "$TMPFILE"
      if vercel env add CONVEX_DEPLOYMENT production < "$TMPFILE"; then
        echo "\033[0;32m✓ Successfully added CONVEX_DEPLOYMENT to Vercel production environment.\033[0m"
      else
        echo "\033[0;31m✖ Failed to add CONVEX_DEPLOYMENT to Vercel. Please add it manually.\033[0m"
      fi
      rm "$TMPFILE"
    fi
  fi
else
  echo "\033[0;32m✓ CONVEX_DEPLOYMENT found in Convex production environment.\033[0m"
fi 

/*
  File: scripts/bundle-code.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/scripts/bundle-code.ts
  Directory: scripts
*/

--- File: scripts/bundle-code.ts ---

#!/usr/bin/env node

import fs from 'fs/promises';
import path from 'path';
import ignore from 'ignore';
import type { Dirent } from 'fs'; // Import Dirent type

// --- Configuration ---

// Directories to exclude entirely
const EXCLUDED_DIRS: Set<string> = new Set([
    'node_modules',
    '.git',
    '.next',
    'dist',
    'build',
    'out',
    'coverage',
    '.vscode',
    '.idea',
    'public', // Often contains large assets, adjust if needed
    // Add any other directories you want to skip
]);

// Specific files or patterns to exclude
const EXCLUDED_FILES_PATTERNS: string[] = [
    'package-lock.json',
    'yarn.lock',
    'pnpm-lock.yaml',
    '.DS_Store',
    // Add any specific files or patterns
];

// File extensions or specific filenames to include (add more as needed)
const INCLUDED_EXTENSIONS: Set<string> = new Set([
    // Extensions
    '.js',
    '.jsx',
    '.ts',
    '.tsx',
    '.mjs',
    '.cjs',
    '.css',
    '.scss',
    '.sass',
    '.less',
    '.html',
    '.md',
    '.json',
    '.yaml',
    '.yml',
    '.sh',
    '.env',
    '.env.local',
    '.env.development',
    '.env.production',
    '.env.example', // Often useful for context
    '.gitignore', // Useful for context
    '.npmrc',
    // Specific filenames (often config files)
    'next.config.js',
    'next.config.mjs',
    'postcss.config.js',
    'tailwind.config.js',
    'tailwind.config.ts',
    'tsconfig.json',
    'jsconfig.json',
    '.eslintrc.json',
    '.prettierrc',
    'Dockerfile',
    // Add specific filenames relevant to your project
]);

// Initialize gitignore
let ig = ignore();

async function loadGitignore(projectRoot: string): Promise<void> {
    try {
        const gitignorePath = path.join(projectRoot, '.gitignore');
        const gitignoreContent = await fs.readFile(gitignorePath, 'utf-8');
        ig = ignore().add(gitignoreContent);
    } catch (err: unknown) {
        if (err && typeof err === 'object' && 'code' in err && err.code === 'ENOENT') {
            console.log('No .gitignore file found, continuing without it');
        } else if (err instanceof Error) {
            console.error('Error reading .gitignore:', err.message);
        }
    }
}

// --- Helper Functions ---

function isExcluded(entryPath: string, entryName: string, isDirectory: boolean): boolean {
    // Check gitignore patterns first
    const relativePath = entryPath.replace(/\\/g, '/'); // Normalize path separators
    if (ig.ignores(relativePath)) {
        return true;
    }

    // Then check our manual exclusions
    if (isDirectory && EXCLUDED_DIRS.has(entryName)) {
        return true;
    }
    if (!isDirectory && EXCLUDED_FILES_PATTERNS.some(pattern => entryName === pattern)) {
        // Add more complex pattern matching here if needed (e.g., regex)
        return true;
    }
     // Check if the path contains an excluded directory component
    const pathParts = entryPath.split(path.sep);
    if (pathParts.some(part => EXCLUDED_DIRS.has(part))) {
       return true;
    }
    return false;
}

function isIncluded(entryName: string): boolean {
    const ext = path.extname(entryName).toLowerCase();
    // Check by specific name first, then by extension
    return INCLUDED_EXTENSIONS.has(entryName) || (ext !== '' && INCLUDED_EXTENSIONS.has(ext));
}

async function walkDir(dir: string, projectRoot: string, allContents: string[]): Promise<void> {
    let entries: Dirent[];
    try {
        entries = await fs.readdir(dir, { withFileTypes: true });
    } catch (err: unknown) {
        if (err instanceof Error) {
            console.error(`Error reading directory ${dir}: ${err.message}`);
        }
        return; // Skip directories we can't read
    }

    for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        const relativePath = path.relative(projectRoot, fullPath);

        if (isExcluded(relativePath, entry.name, entry.isDirectory())) {
            console.log(`(-) Excluding: ${relativePath}`);
            continue;
        }

        if (entry.isDirectory()) {
            await walkDir(fullPath, projectRoot, allContents);
        } else if (entry.isFile() && isIncluded(entry.name)) {
            try {
                console.log(`(+) Including: ${relativePath}`);
                const content = await fs.readFile(fullPath, 'utf-8');
                // Normalize line endings to prevent excessive diffs if files have mixed endings
                const normalizedContent = content.replace(/\r\n/g, '\n');
                // Directory structure (relative, split by path.sep, joined by /)
                const dirStructure = path.dirname(relativePath).split(path.sep).filter(Boolean).join('/');
                // Reference comment block
                const referenceBlock = `/*\n  File: ${relativePath}\n  Absolute: ${fullPath}\n  Directory: ${dirStructure || '.'}\n*/\n`;
                allContents.push(`${referenceBlock}\n--- File: ${relativePath} ---\n\n${normalizedContent}\n\n`);
            } catch (err: unknown) {
                if (err instanceof Error) {
                    console.error(`Error reading file ${fullPath}: ${err.message}`);
                    // Directory structure for error case
                    const dirStructure = path.dirname(relativePath).split(path.sep).filter(Boolean).join('/');
                    const referenceBlock = `/*\n  File: ${relativePath}\n  Absolute: ${fullPath}\n  Directory: ${dirStructure || '.'}\n*/\n`;
                    allContents.push(`${referenceBlock}\n--- File: ${relativePath} ---\n\n!!! Error reading file: ${err.message} !!!\n\n`);
                }
            }
        } else {
             // Optional: Log files that are neither excluded nor included
             // console.log(`(?) Skipping (not included): ${relativePath}`);
        }
    }
}

// --- Main Execution ---

async function main(): Promise<void> {
    // Basic argument parsing: tsx scripts/bundle-code.ts [targetDir] [outputFile]
    const args: string[] = process.argv.slice(2);
    const targetDirArg: string | undefined = args[0];
    const outputFileArg: string | undefined = args[1];

    const targetDir: string = path.resolve(targetDirArg || '.'); // Default to current directory
    const outputFilePath: string | null = outputFileArg ? path.resolve(outputFileArg) : null; // Default to console output

    // Load .gitignore before processing
    await loadGitignore(targetDir);

    console.log(`Scanning directory: ${targetDir}`);
    if (outputFilePath) {
        console.log(`Output will be written to: ${outputFilePath}`);
    } else {
        console.log(`Output will be printed to console.`);
    }

    const allContents: string[] = [];
    try {
        // Check if target directory exists
        const stats = await fs.stat(targetDir);
        if (!stats.isDirectory()) {
            throw new Error(`Target path is not a directory: ${targetDir}`);
        }

        await walkDir(targetDir, targetDir, allContents);

        const combinedOutput: string = allContents.join('');

        if (outputFilePath) {
            await fs.writeFile(outputFilePath, combinedOutput);
            console.log(`\n✅ Successfully wrote bundled code to ${outputFilePath}`);
        } else {
            console.log("\n--- BUNDLED CODE OUTPUT ---");
            console.log(combinedOutput);
            console.log("--- END BUNDLED CODE OUTPUT ---");
            console.log(`\n✅ Successfully generated bundled code.`);
        }

    } catch (err: unknown) {
        if (err && typeof err === 'object' && 'code' in err && err.code === 'ENOENT') {
            console.error(`\n❌ Error: Target directory not found: ${targetDir}`);
        } else if (err instanceof Error) {
            console.error(`\n❌ An error occurred: ${err.message}`);
            console.error(err.stack); // Print stack trace for debugging
        }
        process.exit(1); // Exit with error code
    }
}

main();

/*
  File: scripts/generate-routes.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/scripts/generate-routes.ts
  Directory: scripts
*/

--- File: scripts/generate-routes.ts ---

import fs from 'fs'
import path from 'path'

// Function to get all route paths from the app directory
function getRoutePaths(dir: string, basePath: string = ''): string[] {
  const entries = fs.readdirSync(dir, { withFileTypes: true })
  const paths: string[] = []

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name)
    const routePath = path.join(basePath, entry.name)

    if (entry.isDirectory()) {
      // Skip private folders (starting with _) and api routes
      if (entry.name.startsWith('_') || entry.name === 'api') {
        continue
      }

      // Handle dynamic routes
      const routeName = entry.name.startsWith('[') ? entry.name : null
      if (routeName) {
        // Add the dynamic route pattern
        paths.push(path.join(basePath, '*'))
      } else {
        // Recursively get routes from subdirectories
        paths.push(...getRoutePaths(fullPath, routePath))
      }
    } else if (entry.name === 'page.tsx' || entry.name === 'page.ts') {
      // Add the route path for page files
      paths.push(basePath)
    }
  }

  return paths
}

// Generate the routes file
function generateRoutesFile() {
  const appDir = path.join(process.cwd(), 'app')
  const routePaths = getRoutePaths(appDir)
  
  // Format the paths
  const formattedPaths = routePaths
    .map(p => p.replace(/\\/g, '/')) // Convert Windows paths to forward slashes
    .map(p => p || '/') // Convert empty string to root path
    .sort()

  // Generate the file content
  const fileContent = `// This file is auto-generated. DO NOT EDIT IT MANUALLY.
// It is used to generate the validRoutes for tracking user visits.
// To regenerate, run: pnpm generate:routes

export const validRoutes = new Set([
  ${formattedPaths.map(p => `'${p}'`).join(',\n  ')}
])
`

  // Write the file
  const outputPath = path.join(process.cwd(), 'lib', 'generated', 'routes.ts')
  fs.mkdirSync(path.dirname(outputPath), { recursive: true })
  fs.writeFileSync(outputPath, fileContent)

  console.log('✅ Generated routes file')
}

generateRoutesFile() 

/*
  File: scripts/init-repo.sh
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/scripts/init-repo.sh
  Directory: scripts
*/

--- File: scripts/init-repo.sh ---

#!/bin/bash

# --- Configuration ---
# Set this to the main branch name you prefer (usually main or master)
MAIN_BRANCH_NAME="main"
# Set to 'true' if you want to automatically confirm Vercel deployments
AUTO_CONFIRM_VERCEL="true"

# --- Error Handling ---
# Exit immediately if a command exits with a non-zero status.
set -e

# Keep track of errors
ERRORS=()

# Function to report errors and exit
handle_error() {
    local command="$1"
    local message="$2"
    ERRORS+=("Error running command: $command")
    ERRORS+=("Details: $message")
    echo "-----------------------------------------------------" >&2
    echo "❌ FATAL ERROR during setup process ❌" >&2
    echo "Command failed: $command" >&2
    echo "Error details: $message" >&2
    echo "Setup process aborted." >&2
    echo "-----------------------------------------------------" >&2
    if [ ${#ERRORS[@]} -gt 0 ]; then
        echo "Summary of errors:" >&2
        for error in "${ERRORS[@]}"; do
            echo "- $error" >&2
        done
    fi
    exit 1
}

# Function to open URL in browser based on OS
open_url() {
    local url=$1
    case "$OSTYPE" in
        "darwin"*) # macOS
            open "$url"
            ;;
        "linux"*) # Linux
            if command -v xdg-open > /dev/null; then
                xdg-open "$url"
            elif command -v gnome-open > /dev/null; then
                gnome-open "$url"
            else
                echo "Could not detect the web browser to use."
            fi
            ;;
        *) # Other OS
            echo "Could not detect the web browser to use."
            ;;
    esac
}

# Function to read value from .env file
get_env_value() {
    local key=$1
    local value=""
    if [ -f ".env" ]; then
        value=$(grep "^${key}=" .env | cut -d '=' -f2)
    fi
    echo "$value"
}

# Function to add or update value in .env file
update_env_file() {
    local key=$1
    local value=$2
    local env_file=".env"
    
    # Create .env if it doesn't exist
    if [ ! -f "$env_file" ]; then
        touch "$env_file"
    fi
    
    # Check if key exists and replace, otherwise add
    if grep -q "^${key}=" "$env_file"; then
        if [[ "$OSTYPE" == "darwin"* ]]; then
            sed -i '' "s|^${key}=.*|${key}=${value}|" "$env_file"
        else
            sed -i "s|^${key}=.*|${key}=${value}|" "$env_file"
        fi
    else
        echo "${key}=${value}" >> "$env_file"
    fi
}

# Function to deploy all env vars to Vercel
deploy_env_to_vercel() {
    local env_file=".env"
    if [ ! -f "$env_file" ]; then
        echo "No .env file found. Skipping environment variable deployment."
        return
    fi

    echo "Deploying environment variables to Vercel..."
    
    # Read each line from .env
    while IFS= read -r line || [ -n "$line" ]; do
        # Skip empty lines and comments
        if [ -z "$line" ] || [[ $line == \#* ]]; then
            continue
        fi
        
        # Extract key and value
        if [[ $line =~ ^([^=]+)=(.*)$ ]]; then
            key="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"
            
            # Remove any surrounding quotes from the value
            value=$(echo "$value" | sed -e 's/^"//' -e 's/"$//' -e "s/^'//" -e "s/'$//")
            
            echo "Setting $key in Vercel..."
            
            # Add to environment
            vercel env add "$key" production "$value" > /dev/null 2>&1
        fi
    done < "$env_file"
    
    echo "✅ Environment variables deployed to Vercel"
}

# --- Get User Input ---

echo "🚀 Starting Project Initialization 🚀"
echo ""

# Get current directory name as default repo name
DEFAULT_REPO_NAME=$(basename "$PWD")

# Prompt for the GitHub repository name with default suggestion
read -p "Enter the desired GitHub repository name [$DEFAULT_REPO_NAME]: " REPO_NAME
REPO_NAME=${REPO_NAME:-$DEFAULT_REPO_NAME}

if [ -z "$REPO_NAME" ]; then
  handle_error "User Input" "No repository name provided."
fi

# Prompt for repository visibility with public as default
read -p "Enter repository visibility [public/private]: " REPO_VISIBILITY_INPUT
REPO_VISIBILITY=${REPO_VISIBILITY_INPUT:-"public"}

# Validate repository visibility input
REPO_VISIBILITY=$(echo "$REPO_VISIBILITY" | tr '[:upper:]' '[:lower:]') # Convert to lowercase
if [[ "$REPO_VISIBILITY" != "public" && "$REPO_VISIBILITY" != "private" ]]; then
  handle_error "User Input" "Invalid visibility '$REPO_VISIBILITY_INPUT'. Please enter 'public' or 'private'."
fi

# Get the GitHub username using the authenticated GH CLI
GITHUB_USERNAME=$(gh api user --jq .login 2>/dev/null) || handle_error "gh api user" "Could not retrieve GitHub username. Is 'gh auth login' complete?"

FULL_REPO_NAME="$GITHUB_USERNAME/$REPO_NAME"
GIT_REMOTE_URL="git@github.com:$FULL_REPO_NAME.git" # Using SSH URL

echo ""
echo "--- Project Details ---"
echo "Local Directory: $(pwd)"
echo "GitHub Repository: $FULL_REPO_NAME ($REPO_VISIBILITY)"
echo "Vercel Linking Git URL: $GIT_REMOTE_URL"
echo "Main Branch: $MAIN_BRANCH_NAME"
echo "-----------------------"
echo ""
read -p "Does this look correct? [Y/n]: " confirm
if [[ "$confirm" =~ ^[Nn]$ ]]; then
    echo "Setup cancelled by user."
    exit 1
fi

echo "" # Add space before next section

# --- Step 1: Initialize Git Repository (if not already) ---
echo "--- 1/4: Setting up local Git repository ---"

# Check if .git directory exists. If not, initialize.
if [ ! -d ".git" ]; then
  git init || handle_error "git init" "Failed to initialize Git repository."
  echo "Git repository initialized."
else
  echo "Existing Git repository found."
fi

# Update config.ts with GitHub URL before initial commit if public repo
if [ "$REPO_VISIBILITY" == "public" ]; then
    config_file="lib/config.ts"
    if [ -f "$config_file" ]; then
        # Use sed to update the github field in config.ts
        # The pattern looks for the 'github: ""' line and replaces it with the new URL
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS requires an empty string after -i
            sed -i '' "s|github: \".*\"|github: \"https://github.com/$FULL_REPO_NAME\"|" "$config_file"
        else
            # Linux version
            sed -i "s|github: \".*\"|github: \"https://github.com/$FULL_REPO_NAME\"|" "$config_file"
        fi
        echo "Updated $config_file with GitHub repository URL"
    else
        ERRORS+=("Warning: Could not find $config_file to update GitHub URL")
    fi
fi

# Add all current files and commit
git add . || handle_error "git add ." "Failed to add files to staging."
# Check if there are staged changes before committing
if git diff --cached --quiet; then
    echo "No new changes to commit. Skipping commit step."
else
    git commit -m "Initial commit from init script" || handle_error "git commit" "Failed to create initial commit."
    echo "Initial commit created."
fi


# Ensure the main branch exists and is named correctly
# Use '--force' to rename if it exists with a different case (like master)
if git branch --list | grep -q "\b$MAIN_BRANCH_NAME\b"; then
    echo "Branch '$MAIN_BRANCH_NAME' already exists."
elif git branch --list | grep -q "\bmaster\b" && [ "$MAIN_BRANCH_NAME" == "main" ]; then
    git branch -m $MAIN_BRANCH_NAME || handle_error "git branch -m" "Failed to rename branch from 'master' to '$MAIN_BRANCH_NAME'."
    echo "Renamed 'master' branch to '$MAIN_BRANCH_NAME'."
else
     # Create the branch if it doesn't exist and there's no master to rename
     # This case is less common after git init and commit, but good practice
     # Check if HEAD exists first (implies a commit has been made)
     if git rev-parse --verify HEAD > /dev/null 2>&1; then
        git branch $MAIN_BRANCH_NAME || handle_error "git branch" "Failed to create '$MAIN_BRANCH_NAME' branch."
        git checkout $MAIN_BRANCH_NAME || handle_error "git checkout" "Failed to checkout '$MAIN_BRANCH_NAME' branch."
        echo "Created and checked out '$MAIN_BRANCH_NAME' branch."
     else
         # No commits yet, branch will be created upon first commit/push
         echo "No commits yet, branch '$MAIN_BRANCH_NAME' will be set on push."
     fi
fi
git checkout $MAIN_BRANCH_NAME > /dev/null 2>&1 || handle_error "git checkout" "Failed to ensure checkout of '$MAIN_BRANCH_NAME'."
echo "Ensured checkout of branch '$MAIN_BRANCH_NAME'."


echo "Local Git setup complete."
echo ""

# --- Step 2: Create GitHub Repository and Push ---
echo "--- 2/4: Creating GitHub repository and pushing ---"

# Check if origin remote already exists and points to the correct repo
echo "Checking for existing git remote..."
CURRENT_ORIGIN=$(git remote get-url origin 2>/dev/null || echo "")

if [ -n "$CURRENT_ORIGIN" ]; then
    echo "Found existing remote: $CURRENT_ORIGIN"
    # Normalize the URLs for comparison (both SSH format)
    EXPECTED_URL="git@github.com:$FULL_REPO_NAME.git"
    if [ "$CURRENT_ORIGIN" = "$EXPECTED_URL" ]; then
        echo "✓ Git remote 'origin' already exists and points to correct repository"
        echo "Continuing with existing remote..."
    else
        echo "Warning: Git remote 'origin' exists but points to unexpected repository"
        echo "Current:  $CURRENT_ORIGIN"
        echo "Expected: $EXPECTED_URL"
        handle_error "Git Remote Conflict" "Existing 'origin' remote points to unexpected repository. Please resolve manually."
    fi
else
    echo "No existing remote found. Creating new repository..."
    
    # Create the repository and push in one command
    echo "Creating GitHub repository '$FULL_REPO_NAME' ($REPO_VISIBILITY)..."
    
    CREATE_COMMAND=""
    if [ "$REPO_VISIBILITY" == "private" ]; then
        CREATE_COMMAND="gh repo create \"$REPO_NAME\" --private --source=. --remote=origin --push"
    else
        CREATE_COMMAND="gh repo create \"$REPO_NAME\" --public --source=. --remote=origin --push"
    fi
    
    echo "Executing: $CREATE_COMMAND"
    eval "$CREATE_COMMAND" || {
        echo "Error occurred while creating repository. Exit code: $?"
        handle_error "gh repo create" "Failed to create and push to $REPO_VISIBILITY GitHub repository '$FULL_REPO_NAME'."
    }
    
    echo "GitHub repository created and code pushed successfully."
fi

echo "GitHub setup and push complete."
echo ""

# --- Step 3: Link Project to Vercel and GitHub ---
echo "--- 3/4: Linking project to Vercel and GitHub ---"

# Check if Vercel project is already linked
if vercel status --connected 2>/dev/null; then
    echo "Vercel project is already linked."
else
    echo "Linking project to Vercel..."
    # First link the project
    echo "Running: vercel link"
    vercel link || handle_error "vercel link" "Failed to link project to Vercel."
fi

# Check if Git is already connected
echo "Checking Git connection status..."
if vercel git ls 2>&1 | grep -q "$FULL_REPO_NAME"; then
    echo "✓ GitHub repository $FULL_REPO_NAME is already connected to Vercel"
else
    # Connect to GitHub
    echo "Connecting to GitHub repository..."
    echo "Running: vercel git connect"
    if ! output=$(vercel git connect 2>&1); then
        # Check if the error is just that it's already connected
        if echo "$output" | grep -q "is already connected to your project"; then
            echo "✓ GitHub repository is already connected to Vercel"
        else
            echo "$output"
            handle_error "vercel git connect" "Failed to connect GitHub repository to Vercel."
        fi
    fi
fi

echo "Project linked to Vercel and GitHub connection established."
echo ""

# Set up Clerk environment variables if not in .env
echo ""
echo "Setting up Clerk environment variables..."
echo "These are required for authentication to work. You can find them in your Clerk Dashboard."
echo "Visit https://dashboard.clerk.com/ to get your keys."
echo ""

# Try to get values from .env first
CLERK_PUB_KEY=$(get_env_value "NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY")
CLERK_SECRET_KEY=$(get_env_value "CLERK_SECRET_KEY")

# Function to validate Clerk key format
validate_clerk_key() {
    local key=$1
    local key_type=$2
    
    if [ -z "$key" ]; then
        return 1
    fi
    
    # Public key should start with pk_test_ or pk_live_
    if [ "$key_type" = "public" ] && ! [[ $key =~ ^pk_(test|live)_ ]]; then
        return 1
    fi
    
    # Secret key should start with sk_test_ or sk_live_
    if [ "$key_type" = "secret" ] && ! [[ $key =~ ^sk_(test|live)_ ]]; then
        return 1
    fi
    
    return 0
}

# Handle public key
if validate_clerk_key "$CLERK_PUB_KEY" "public"; then
    echo "✓ Using existing NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY from .env"
else
    while ! validate_clerk_key "$CLERK_PUB_KEY" "public"; do
        if [ -n "$CLERK_PUB_KEY" ]; then
            echo "❌ Invalid Clerk publishable key format. It should start with pk_test_ or pk_live_"
        else
            echo "NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY not found in .env"
        fi
        echo "Visit https://dashboard.clerk.com/last-active/api-keys to get your publishable key"
        read -p "Enter your NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: " CLERK_PUB_KEY
    done
    # Only update .env if we had to ask for a new value
    update_env_file "NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY" "$CLERK_PUB_KEY"
fi

# Handle secret key
if validate_clerk_key "$CLERK_SECRET_KEY" "secret"; then
    echo "✓ Using existing CLERK_SECRET_KEY from .env"
else
    while ! validate_clerk_key "$CLERK_SECRET_KEY" "secret"; do
        if [ -n "$CLERK_SECRET_KEY" ]; then
            echo "❌ Invalid Clerk secret key format. It should start with sk_test_ or sk_live_"
        else
            echo "CLERK_SECRET_KEY not found in .env"
        fi
        echo "Visit https://dashboard.clerk.com/last-active/api-keys to get your secret key"
        read -p "Enter your CLERK_SECRET_KEY: " CLERK_SECRET_KEY
    done
    # Only update .env if we had to ask for a new value
    update_env_file "CLERK_SECRET_KEY" "$CLERK_SECRET_KEY"
fi

# Function to add env var to Vercel for production
add_vercel_env() {
    local key=$1
    local value=$2
    
    echo "----------------------------------------"
    echo "🔄 Setting up $key for production environment"
    
    # First try to remove any existing value
    echo "Removing existing $key from production environment if it exists..."
    vercel env rm "$key" production || {
        echo "Note: No existing variable to remove or removal failed (this is usually ok)"
    }
    
    # Create a temporary file
    local tmp_file
    tmp_file=$(mktemp)
    echo "$value" > "$tmp_file"
    
    # Add the new value
    echo "Adding $key to production environment..."
    echo "Running environment variable add command..."
    if vercel env add "$key" production < "$tmp_file"; then
        echo "✅ Successfully added $key to production environment"
        rm "$tmp_file"
    else
        local exit_code=$?
        echo "❌ Failed to add environment variable"
        echo "Exit code: $exit_code"
        rm "$tmp_file"
        handle_error "vercel env add" "Failed to add $key to Vercel production environment (exit code: $exit_code)"
    fi
    echo "----------------------------------------"
}

# Add variables to production environment
echo "🔐 Setting up Clerk environment variables in Vercel..."
echo ""
add_vercel_env "NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY" "$CLERK_PUB_KEY"
add_vercel_env "CLERK_SECRET_KEY" "$CLERK_SECRET_KEY"

echo ""
echo "✅ Clerk environment variables have been set up successfully."
echo ""

# --- Step 4: Final Vercel Deployment ---
echo "--- 4/4: Initiating Vercel deployment ---"

VERCEL_DEPLOY_COMMAND="vercel deploy --confirm"
echo "Running: $VERCEL_DEPLOY_COMMAND"
$VERCEL_DEPLOY_COMMAND || handle_error "$VERCEL_DEPLOY_COMMAND" "Failed to initiate Vercel deployment."
echo "Vercel deployment initiated."
echo ""


# --- Completion ---
echo "🎉 Project Initialization Complete! 🎉"
echo "Your project is now:"
echo "- Local Git repository initialized and committed."
echo "- GitHub repository created at https://github.com/$FULL_REPO_NAME"
echo "- Code pushed to the '$MAIN_BRANCH_NAME' branch on GitHub."
echo "- Vercel project linked to the GitHub repository."
echo "- Vercel deployment triggered. Visit your Vercel dashboard to see the status."

# Open Vercel project in browser
echo ""
echo "Opening Vercel project in browser..."
VERCEL_PROJECT_URL=$(vercel project ls --json | grep -o '"url":"[^"]*"' | head -1 | cut -d'"' -f4)
if [ -n "$VERCEL_PROJECT_URL" ]; then
    open_url "https://$VERCEL_PROJECT_URL"
else
    echo "Could not determine Vercel project URL."
fi

if [ ${#ERRORS[@]} -gt 0 ]; then
    echo ""
    echo "⚠️ Warnings and Non-Fatal Issues Encountered: ⚠️"
    for error in "${ERRORS[@]}"; do
        # Filter out the fatal error header if it was added by handle_error
        if [[ "$error" != *"FATAL ERROR"* && "$error" != *"Summary of errors:"* && "$error" != *"- Error running command:"* && "$error" != *"- Details:"* ]]; then
            echo "- $error"
        fi
    done
    echo "Please review the output above for details."
fi

exit 0


/*
  File: tailwind.config.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/tailwind.config.ts
  Directory: .
*/

--- File: tailwind.config.ts ---

import type { Config } from "tailwindcss"
import tailwindcssAnimate from "tailwindcss-animate"
import typography from '@tailwindcss/typography'

const config = {
  darkMode: "class",
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
    "*.{js,ts,jsx,tsx,mdx}",
  ],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar))",
          foreground: "hsl(var(--sidebar-foreground))",
          border: "hsl(var(--sidebar-border))",
          primary: "hsl(var(--sidebar-primary))",
          "primary-foreground": "hsl(var(--sidebar-primary-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
        float: {
          "0%, 100%": { transform: "translateY(0)" },
          "50%": { transform: "translateY(-20px)" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        float: "float 15s ease-in-out infinite",
      },
      typography: {
        DEFAULT: {
          css: {
            maxWidth: 'none',
            color: 'hsl(var(--foreground))',
            a: {
              color: 'hsl(var(--primary))',
              textDecoration: 'underline',
              fontWeight: '500',
            },
            h1: {
              color: 'hsl(var(--foreground))',
            },
            h2: {
              color: 'hsl(var(--foreground))',
            },
            h3: {
              color: 'hsl(var(--foreground))',
            },
            h4: {
              color: 'hsl(var(--foreground))',
            },
            code: {
              color: 'hsl(var(--foreground))',
              backgroundColor: 'hsl(var(--muted))',
              borderRadius: '0.25rem',
              padding: '0.15rem 0.3rem',
            },
            pre: {
              backgroundColor: 'hsl(var(--muted))',
              borderRadius: '0.5rem',
              padding: '1rem',
            },
            blockquote: {
              color: 'hsl(var(--muted-foreground))',
              borderLeftColor: 'hsl(var(--border))',
            },
            hr: {
              borderColor: 'hsl(var(--border))',
            },
            strong: {
              color: 'hsl(var(--foreground))',
            },
            thead: {
              color: 'hsl(var(--foreground))',
              borderBottomColor: 'hsl(var(--border))',
            },
            tbody: {
              tr: {
                borderBottomColor: 'hsl(var(--border))',
              },
            },
          },
        },
      },
    },
  },
  plugins: [
    tailwindcssAnimate,
    typography,
  ],
} satisfies Config

export default config



/*
  File: tests/admin.spec.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/tests/admin.spec.ts
  Directory: tests
*/

--- File: tests/admin.spec.ts ---

import { test, expect } from '@playwright/test';
import { setupAuthenticatedUser, setupCleanDatabase } from './utils/test-helpers';

test('should not be public', async ({ page }) => {
  await page.goto('/admin');
  await expect(page.getByRole('heading', { name: 'Access Denied' })).toBeVisible();
  await expect(page.getByRole('heading', { name: 'Development Environment' })).toBeVisible();
});

test('should load the admin dashboard', async ({ page }) => {
  // Reset database before this test
    await setupCleanDatabase();
    
    // Login as test user
    await setupAuthenticatedUser(page);
    
    // Navigate to the page
    await page.goto('/admin');
    await expect(page.getByRole('heading', { name: 'Admin Dashboard' })).toBeVisible();
});

test('can view analytics', async ({ page }) => {
  // Reset database before this test
    await setupCleanDatabase();
    
    // Login as test user
    await setupAuthenticatedUser(page);
    
    // Navigate to the page
    await page.goto('/admin/analytics');
    await expect(page.getByRole('heading', { name: 'Analytics' })).toBeVisible();
    await expect(page.getByRole('heading', { name: 'Total Visits (30 Days)' })).toBeVisible();
    await expect(page.getByRole('heading', { name: 'Recent Visits' })).toBeVisible();
});

test('can view mailing list', async ({ page }) => {
  // Reset database before this test
    await setupCleanDatabase();
    
    // Login as test user
    await setupAuthenticatedUser(page);

    // Navigate to the page
    await page.goto('/admin/mailing-list');
    await expect(page.getByRole('heading', { name: 'Mailing List' })).toBeVisible();    
});
  

/*
  File: tests/auth.spec.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/tests/auth.spec.ts
  Directory: tests
*/

--- File: tests/auth.spec.ts ---

import { test, expect } from '@playwright/test';

test('should be able to fill out the sign up form', async ({ page }) => {
  await page.goto('http://localhost:3000');
  await page.getByRole('button', { name: 'Sign Up' }).click();
  await page.getByRole('textbox', { name: 'Email address' }).fill('hey@gmail.com');
  await page.getByRole('textbox', { name: 'Password' }).fill('GoodVibrations');
  await expect(page.getByRole('button', { name: 'Continue' })).toBeVisible();
});


/*
  File: tests/contact.spec.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/tests/contact.spec.ts
  Directory: tests
*/

--- File: tests/contact.spec.ts ---

import { test, expect } from '@playwright/test';

test('should be able to fill out the contact form', async ({ page }) => {
  await page.goto('http://localhost:3000/contact');
  await expect(page.getByText('Contact Us')).toBeVisible();
  await page.getByRole('textbox', { name: 'Name' }).fill('Kickin Poppin');
  await page.getByRole('textbox', { name: 'Email' }).fill('kickin@poppin.com');
  await page.getByRole('textbox', { name: 'Message' }).fill('Hey Yo');
});


/*
  File: tests/global-setup.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/tests/global-setup.ts
  Directory: tests
*/

--- File: tests/global-setup.ts ---

import { setupTestDatabase } from "./utils/db-reset"

/**
 * Global setup function that runs before all tests
 */
export default async function globalSetup() {
  await setupTestDatabase()
} 

/*
  File: tests/subscribe.spec.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/tests/subscribe.spec.ts
  Directory: tests
*/

--- File: tests/subscribe.spec.ts ---

import { test, expect } from '@playwright/test';
import { setupAuthenticatedUser, setupCleanDatabase } from './utils/test-helpers';
import { ConvexHttpClient } from "convex/browser";
import { api } from "@/convex/_generated/api";
import { Doc } from "@/convex/_generated/dataModel";

type MailingListSubscription = Doc<"mailing_list_subscriptions">;

// Initialize Convex client for test verification
const convex = new ConvexHttpClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

// Helper function to safely cast Convex response
async function getSubscriptions() {
  const response = await convex.query(api.mailingList.getSubscriptions);
  return response as unknown as MailingListSubscription[];
}

test('should have to sign in to subscribe', async ({ page }) => {
  await page.goto('http://localhost:3000/mailing-list');
  await expect(page.getByText('Please sign in to subscribe')).toBeVisible();
});

test('should be able to subscribe to the mailing list when signed in', async ({ page }) => {
  // Reset database before this test
  await setupCleanDatabase();
  
  // Login as test user
  await setupAuthenticatedUser(page);

  // Subscribe
  await page.goto('http://localhost:3000/mailing-list');
  
  // Wait for the form to be ready
  await page.waitForSelector('button:has-text("Subscribe")');

  // Click subscribe and wait for navigation/refresh
  await page.getByRole('button', { name: 'Subscribe' }).click();
  await page.waitForLoadState('networkidle');
  
  // Check for success message
  const toastText = await page.getByText('Successfully subscribed').textContent();
  console.log('Toast message:', toastText);
  
  // Check subscription status
  const statusText = await page.getByText('You are currently subscribed').textContent();
  console.log('Status message:', statusText);

  // Verify the document in Convex
  const subscriptions = await getSubscriptions();
  const subscription = subscriptions.find(s => s.email === 'john.polacek@gmail.com');
  expect(subscription).toBeTruthy();
  expect(subscription?.email).toBe('john.polacek@gmail.com');
  expect(subscription?.subscribedAt).toBeTruthy();
  expect(subscription?.unsubscribedAt).toBeNull();

  // Navigate to admin and check list
  await page.goto('http://localhost:3000/admin/mailing-list');
  await page.waitForLoadState('networkidle');

  // Wait for page to load and data to be fetched
  await expect(page.getByRole('heading', { name: 'Mailing List Subscribers' })).toBeVisible();
  
  // Check if email is in the list
  const emailCell = page.getByRole('cell', { name: 'john.polacek@gmail.com' });
  const isEmailVisible = await emailCell.isVisible();
  console.log('Email visible in admin list:', isEmailVisible);
  await expect(emailCell).toBeVisible();
  
  // Unsubscribe
  await page.goto('http://localhost:3000/mailing-list');
  await page.getByRole('button', { name: 'Unsubscribe' }).click();
  await expect(page.getByText('Subscribe to Our Mailing List')).toBeVisible();
  await page.goto('http://localhost:3000/admin/mailing-list');
  await expect(page.getByRole('cell', { name: 'john.polacek@gmail.com' })).toBeVisible();
  await expect(page.getByText('Unsubscribed')).toBeVisible();

  // Verify unsubscribe in Convex
  const updatedSubscriptions = await getSubscriptions();
  const unsubscription = updatedSubscriptions.find(s => s.email === 'john.polacek@gmail.com');
  expect(unsubscription).toBeTruthy();
  expect(unsubscription?.unsubscribedAt).toBeTruthy();
});


/*
  File: tests/utils/auth-helpers.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/tests/utils/auth-helpers.ts
  Directory: tests/utils
*/

--- File: tests/utils/auth-helpers.ts ---

import { Page, expect } from '@playwright/test';
import { clerk, clerkSetup } from '@clerk/testing/playwright';

/**
 * Login credentials for test user
 */
export const TEST_USER = {
  email: process.env.TEST_USER_EMAIL!,
  password: process.env.TEST_USER_PASSWORD!,
  fullName: process.env.TEST_USER_FULL_NAME!,
  username: process.env.TEST_USER_USERNAME!,
  userId: process.env.TEST_USER_ID!
};

/**
 * Login a test user using Clerk authentication
 * @param page - Playwright page object
 */
export async function loginTestUser(page: Page): Promise<void> {
  // Navigate to an unprotected page that loads Clerk
  await page.goto('/');

  // Setup Clerk for testing
  await clerkSetup();

  // Use Clerk's testing utilities to sign in
  await clerk.signIn({
    page,
    signInParams: {
      strategy: 'password',
      identifier: TEST_USER.email,
      password: TEST_USER.password
    }
  });

  // Navigate to the home page and verify we're logged in
  await page.goto('/');
  await expect(page.getByRole('button', { name: 'Open user button' })).toBeVisible({timeout: 30000});
}

/**
 * Helper function to fill in login credentials and wait for successful login
 */
export async function fillLoginCredentials(page: Page): Promise<void> {
  await page.getByRole('textbox', { name: 'Email address' }).fill(TEST_USER.email);
  await page.waitForTimeout(500);
  await page.getByRole('button', { name: 'Continue' }).click();
  await page.waitForTimeout(500);
  await page.getByRole('textbox', { name: 'Password' }).fill(TEST_USER.password);
  await page.waitForTimeout(1000);
  await page.getByRole('button', { name: 'Continue' }).click();
  await expect(page.getByRole('button', { name: 'Open user button' })).toBeVisible({timeout: 30000});
}

/**
 * Logout the current user
 * @param page - Playwright page object
 */
export async function logoutUser(page: Page): Promise<void> {
  // Navigate to an unprotected page that loads Clerk
  await page.goto('/');
  
  await clerk.signOut({ page });
  await page.waitForTimeout(500);
} 

/*
  File: tests/utils/db-reset.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/tests/utils/db-reset.ts
  Directory: tests/utils
*/

--- File: tests/utils/db-reset.ts ---

import { ConvexHttpClient } from "convex/browser"
import { api } from "@/convex/_generated/api"
import dotenv from 'dotenv'

dotenv.config()
const NODE_ENV = process.env.NODE_ENV || 'test'

// Ensure we're in test environment
if (NODE_ENV !== 'test' && NODE_ENV !== 'development') {
  throw new Error('Database reset utilities should only be used in test or development environment')
}

// Initialize Convex client
const convex = new ConvexHttpClient(process.env.NEXT_PUBLIC_CONVEX_URL!)

const TABLES_TO_RESET = ['mailing_list_subscriptions', 'visits'] as const
// Restrict to allowed table names for type safety
type TableName = typeof TABLES_TO_RESET[number]

/**
 * Delete all documents in a table
 */
export async function deleteCollection(tableName: TableName): Promise<void> {
  try {
    await convex.mutation(api.testing.deleteAll, { tableName })
    console.log(`Deleted all documents from ${tableName}`)
  } catch (error) {
    console.warn(`Warning: Failed to delete table ${tableName}:`, error)
  }
}

/**
 * Reset database for testing
 */
export async function resetDatabase(): Promise<void> {
  console.log('Resetting database...')
  for (const table of TABLES_TO_RESET) {
    await deleteCollection(table)
  }
  console.log('Database reset complete')
}

/**
 * Seed test data using Convex test mutation
 */
export async function seedTestData(): Promise<void> {
  console.log('Seeding test data...')
  await convex.mutation(api.testing.seedTestData, {})
  console.log('Test data seeding complete')
}

/**
 * Verify that all tables are empty
 */
export async function verifyDatabaseReset(): Promise<boolean> {
  try {
    for (const table of TABLES_TO_RESET) {
      const count = await convex.query(api.testing.countDocuments, { tableName: table })
      if (count > 0) {
        console.error(`Table ${table} is not empty`)
        return false
      }
    }
    return true
  } catch (error) {
    console.error('Error verifying database reset:', error)
    return false
  }
}

/**
 * Reset database for testing
 */
export async function setupTestDatabase(): Promise<void> {
  await resetDatabase()
  const isReset = await verifyDatabaseReset()
  if (!isReset) {
    throw new Error('Failed to reset database')
  }
} 

/*
  File: tests/utils/test-helpers.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/tests/utils/test-helpers.ts
  Directory: tests/utils
*/

--- File: tests/utils/test-helpers.ts ---

import { test, expect, Page } from '@playwright/test';
import { resetDatabase, seedTestData } from './db-reset';
import { loginTestUser, logoutUser } from './auth-helpers';

/**
 * Reset the database before a test or group of tests
 */
export async function setupCleanDatabase() {
  await resetDatabase();
}

/**
 * Reset the database and seed it with test data
 */
export async function setupSeededDatabase() {
  await resetDatabase();
  await seedTestData();
}

/**
 * Login a test user
 * @param page - Playwright page object
 */
export async function setupAuthenticatedUser(page: Page) {
  await loginTestUser(page);
}

/**
 * Logout a user
 * @param page - Playwright page object
 */
export async function teardownAuthenticatedUser(page: Page) {
  await logoutUser(page).catch(e => console.warn('Failed to logout:', e));
}

// Export test and expect for convenience
export { test, expect }; 

/*
  File: tsconfig.json
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/tsconfig.json
  Directory: .
*/

--- File: tsconfig.json ---

{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


/*
  File: types/adventure-plan.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/types/adventure-plan.ts
  Directory: types
*/

--- File: types/adventure-plan.ts ---

import type { Character, PCTemplate } from "./character";

export interface AdventurePlan {
  id: string;
  settingId: string;
  title: string;
  author: string;
  version: string;
  teaser: string;
  overview: string;
  party: [number, number];
  tags: string[];
  image: string;
  start: string;
  sections: AdventureSection[];
  premadePlayerCharacters: PCTemplate[];
  npcs: Record<string, Character>;
}

export interface AdventureSection {
  title: string;
  summary: string;
  image?: string;
  scenes: AdventureScene[];
}

export interface AdventureScene {
  title: string;
  summary: string;
  image?: string;
  encounters: AdventureEncounter[];
}

export interface AdventureEncounter {
  id: string;
  title: string;
  intro: string;
  instructions?: string;
  image?: string;
  transitions?: EncounterTransition[];
  npc?: EncounterCharacterRef[];
  skipInitialNpcTurns?: boolean;
  resetHealth?: boolean;
}

export interface EncounterTransition {
  condition: string;
  encounter: string;
}

export interface EncounterCharacterRef {
  id: string;
  behavior: string;
  initialInitiative?: number;
}

/*
  File: types/adventure.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/types/adventure.ts
  Directory: types
*/

--- File: types/adventure.ts ---

import type { PC, NPC } from "./character";
import type { RollRequirement } from "@/lib/validations/roll-requirement-schema";

export interface Adventure {
  id: string;
  title: string;
  adventurePlanId: string;
  settingId: string;
  status?: "waitingForPlayers" | "active" | "completed";
  party: PC[];
  turns: Turn[];
  startedAt: string;
  endedAt?: string;
  pausedAt?: string;
}

export type TurnCharacter =
  | (PC & { 
      type: "pc"; 
      initiative: number; 
      hasReplied?: boolean; 
      isComplete?: boolean;
      rollRequired?: RollRequirement;
      rollResult?: number;
    })
  | (NPC & { 
      type: "npc"; 
      initiative: number; 
      hasReplied?: boolean; 
      isComplete?: boolean;
      rollRequired?: RollRequirement;
      rollResult?: number;
    });

export interface Turn {
  id: string;
  encounterId: string;
  title: string;
  narrative: string;
  characters: TurnCharacter[];
  adventureId: string;
  isFinalEncounter?: boolean;
}

export interface DiceRoll {
  rollType: string;
  baseRoll: number;
  modifier: string | number;
  result: number;
  difficulty: number;
  character: string;
  success: boolean;
}

/*
  File: types/character.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/types/character.ts
  Directory: types
*/

--- File: types/character.ts ---

import { z } from "zod"

// Equipment item schema and type
export const equipmentItemSchema = z.object({
  name: z.string(),
  description: z.string().optional(),
})

export type EquipmentItem = z.infer<typeof equipmentItemSchema>

export const spellSchema = z.object({
  name: z.string(),
  description: z.string().optional(),
  isUsed: z.boolean().optional(),
})

export const specialAbilitySchema = z.object({
  name: z.string(),
  description: z.string().optional(),
  isUsed: z.boolean().optional(),
})

export type Spell = z.infer<typeof spellSchema>

export const attributesSchema = z.object({
  strength: z.number().min(1).max(20),
  dexterity: z.number().min(1).max(20),
  constitution: z.number().min(1).max(20),
  intelligence: z.number().min(1).max(20),
  wisdom: z.number().min(1).max(20),
  charisma: z.number().min(1).max(20),
})

export type Attributes = z.infer<typeof attributesSchema>

export const effectSchema = z.object({
  name: z.string(),        // e.g. "Charmed"
  description: z.string(), // e.g. "Regards the caster as a friendly acquaintance"
  duration: z.number(),    // number of turns remaining
});

export type Effect = z.infer<typeof effectSchema>;

export const baseCharacterSchema = z.object({
  id: z.string(),
  name: z.string(),
  image: z.string(),
  archetype: z.string(),
  race: z.string(),
  gender: z.string().optional(),
  appearance: z.string(),
  personality: z.string().optional(),
  background: z.string().optional(),
  motivation: z.string().optional(),
  behavior: z.string().optional(),
  healthPercent: z.number().min(0).max(100), // 0-100, percentage
  equipment: z.array(equipmentItemSchema).optional(),
  skills: z.array(z.string()).optional(),
  spells: z.array(spellSchema).optional(),
  specialAbilities: z.array(z.string()).optional(),
  effects: z.array(effectSchema).optional(),
})

export type BaseCharacter = z.infer<typeof baseCharacterSchema>

// Player Character (PC) schema and type
export const pcSchema = baseCharacterSchema.extend({
  type: z.literal("pc"),
  userId: z.string(), // Clerk user id
  attributes: attributesSchema,
  status: z.string().optional(),
})

export type PC = z.infer<typeof pcSchema>

// Non-Player Character (NPC) schema and type
export const npcSchema = baseCharacterSchema.extend({
  type: z.literal("npc"),
  attributes: attributesSchema.partial().optional(),
  status: z.string().optional(),
})

export type NPC = z.infer<typeof npcSchema>

// Pre-rolled Player Character template schema and type (no userId)
export const pcTemplateSchema = baseCharacterSchema.extend({
  type: z.literal("pc"),
  attributes: attributesSchema,
})

export type PCTemplate = z.infer<typeof pcTemplateSchema>

// Union schema and type for all characters
export const characterSchema = z.union([pcSchema, npcSchema])
export type Character = z.infer<typeof characterSchema>

// Generation schemas (without id and image for AI generation)
export const baseCharacterGenerationSchema = baseCharacterSchema.omit({ id: true, image: true })

export const npcGenerationSchema = baseCharacterGenerationSchema.extend({
  type: z.literal("npc"),
  attributes: attributesSchema.partial().optional(),
})

export const pcTemplateGenerationSchema = baseCharacterGenerationSchema.extend({
  type: z.literal("pc"),
  attributes: attributesSchema,
})

export const characterGenerationSchema = z.union([npcGenerationSchema, pcTemplateGenerationSchema]) 

/*
  File: types/mailing-list.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/types/mailing-list.ts
  Directory: types
*/

--- File: types/mailing-list.ts ---

export interface MailingListPreferences {
  marketing: boolean
  updates: boolean
}

export interface MailingListSubscription {
  id: string
  user_id: string
  email: string
  name: string | null
  subscribed_at: string
  unsubscribed_at: string | null
  preferences: MailingListPreferences
  created_at: string
  updated_at: string
}

export type CreateMailingListSubscription = Pick<MailingListSubscription, 'user_id' | 'email' | 'name'> & {
  preferences?: Partial<MailingListPreferences>
}

export type UpdateMailingListSubscription = Partial<Pick<MailingListSubscription, 'name' | 'unsubscribed_at'>> & {
  preferences?: Partial<MailingListPreferences>
} 

/*
  File: types/setting.ts
  Absolute: /Users/johnpolacek/Projects/d20adventures.com/types/setting.ts
  Directory: types
*/

--- File: types/setting.ts ---

export interface Organization {
  name: string;
  description: string;
  image: string;
}

export interface Location {
  name: string;
  description: string;
  image: string;
  history: string;
  inhabitants: string;
  organizations: Organization[];
}

export interface Setting {
  name: string;
  description: string;
  genre: string;
  image: string;
  technology: string;
  magic: string;
  locations: Location[];
  isPublic: boolean;
}


